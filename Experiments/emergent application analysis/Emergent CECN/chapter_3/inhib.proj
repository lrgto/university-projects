// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [2] {
    taDoc @[0] { };
    taDoc @[1] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [4] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem_Group @.gp[0] = [8] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	  EditMbrItem @[7] { };
	};
	EditMbrItem_Group @.gp[1] = [9] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	  EditMbrItem @[7] { };
	  EditMbrItem @[8] { };
	};
	EditMbrItem_Group @.gp[2] = [2] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	};
      };

      EditMthItem_Group @.mths = [7] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
	EditMthItem @[5] { };
	EditMthItem @[6] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [2] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp[1] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [9] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [3] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { };
	  float_Data @[2] { };
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [3] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [15] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
	ProgVar @[10] { };
	ProgVar @[11] { };
	ProgVar @[12] { };
	ProgVar @[13] { };
	ProgVar @[14] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [43] {
	Comment @[0] { };
	MemberAssign @[1] { };
	MemberAssign @[2] { };
	MemberAssign @[3] { };
	MemberAssign @[4] { };
	MemberAssign @[5] { };
	MemberAssign @[6] { };
	MemberAssign @[7] { };
	MemberAssign @[8] { };
	MemberAssign @[9] { };
	MemberAssign @[10] { };
	MemberAssign @[11] { };
	MemberAssign @[12] { };
	MemberAssign @[13] { };
	MemberAssign @[14] { };
	MemberAssign @[15] { };
	Comment @[16] { };
	MemberAssign @[17] { };
	MemberAssign @[18] { };
	MemberAssign @[19] { };
	MemberAssign @[20] { };
	MemberAssign @[21] { };
	MemberAssign @[22] { };
	MemberAssign @[23] { };
	MemberAssign @[24] { };
	MemberAssign @[25] { };
	MemberAssign @[26] { };
	MemberAssign @[27] { };
	MemberAssign @[28] { };
	MemberAssign @[29] { };
	MemberAssign @[30] { };
	MemberAssign @[31] { };
	Comment @[32] { };
	MemberAssign @[33] { };
	MemberAssign @[34] { };
	MemberAssign @[35] { };
	MemberAssign @[36] { };
	MethodCall @[37] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	MethodCall @[38] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	Comment @[39] { };
	OtherProgramVar @[40] { };
	MethodCall @[41] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	MethodCall @[42] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [1] {
	DynEnumType @[0] { 
	  DynEnumItem_List @.enums = [2] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	  };
	};
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [3] {
	IfElse @[0] { 
	  ProgEl_List @.true_code = [4] {
	    MemberAssign @[0] { };
	    MemberAssign @[1] { };
	    MemberAssign @[2] { };
	    MemberAssign @[3] { };
	  };

	  ProgEl_List @.false_code = [4] {
	    MemberAssign @[0] { };
	    MemberAssign @[1] { };
	    MemberAssign @[2] { };
	    MemberAssign @[3] { };
	  };
	};
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
      };
    };
    Program @[2] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [1] {
	DataGenCall @[0] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [8] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[4] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [6] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[5] { };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [2] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [9] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [3] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [3] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [2] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [1] {
		    ScaleRange @[0] { };
		  };
		};
		GraphTableView @[1] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [2] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [4] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		  };
		};
		GraphTableView @[1] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [2] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [2] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [6] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraUnitSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.noise_sched = [0] {
	      };
	    };
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [2] {
	    LeabraConSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraConSpec @[4] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraConSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraBiasSpec @[5] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
      };

      Layer_Group @.layers = [3] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [100] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [100] {
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [20] {
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
    LeabraNetwork @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [6] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraUnitSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.noise_sched = [0] {
	      };
	    };
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [2] {
	    LeabraConSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraConSpec @[4] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraConSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraBiasSpec @[5] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
      };

      Layer_Group @.layers = [5] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [100] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [100] {
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [4] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	    LeabraPrjn @[3] { };
	  };

	  Unit_Group @.units = [20] {
	  };
	};
	LeabraLayer @[3] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [100] {
	  };
	};
	LeabraLayer @[4] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [20] {
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
= Feedforward and Feedback Inhibition =

The network in the right view panel contains a 10x10 unit input layer, which projects to both the 10x10 hidden layer of excitatory units, and a layer of 20 inhibitory neurons (figure~3.20 in the textbook).  These inhibitory neurons will regulate the activation level of the hidden layer units, and should be thought of as the inhibitory units for the hidden layer (even though they are in their own layer for the purposes of this simulation).  The ratio of 20 inhibitory units to 120 total hidden units (17 percent) is like that found in the cortex, which is commonly cited as roughly 15 percent (White, 1989a; Zilles, 1990).  The inhibitory neurons are just like the excitatory neurons, except that their outputs contribute to the inhibitory conductance of a neuron instead of its excitatory conductance.  We have also set one of the activation parameters to be different for these inhibitory neurons, as discussed below.

Let's begin as usual by viewing the weights of the network.

* Select <code>r.wt</code> in the [[.PanelTab.FFExcite]] netview control panel and then click on some of the hidden layer and inhib layer units with the red arrow.

Most of the weights are random, except for those from the inhibitory units, which are fixed at a constant value of .5.  Notice also that the hidden layer excitatory units receive from the input and inhibitory units, while the inhibitory units receive feedforward connections from the input layer, and feedback connections from the excitatory hidden units, as well as inhibitory connections from themselves.

Now, we will run the network. Note the graph view above the network, which will record the overall levels of activation (average activation) in the hidden and inhibitory units.

* Now, select <code>act</code> to view activations in the network window, and press [[.programs.LeabraEpoch.Init()|Init]] and [[.programs.LeabraEpoch.Run()|Run]] in the [[.PanelTab.ControlPanel]].

You will see the input units activated by a random activity pattern, and after several cycles of activation updating, the hidden and inhibitory units will become active.  The activation appears quite controlled, as the inhibition counterbalances the excitation from the input layer.  Note that the level of the leak current, g_bar.l, is very small at .01, so that virtually all of the counterbalancing of excitation is being performed by the inhibition, not by the leak current.  From the average activity plotted in the graph window (figure 3.21 in the textbook), you should see that the hidden layer (black line) has around 10 percent activation.

In the next sections, we manipulate some of the parameters in the control panel to get a better sense of the principles underlying the inhibitory dynamics in the network.  Because we will be running the network many times, you may want to toggle the network display off to speed up the settling process (the graph log contains the relevant information anyway).

* To toggle the display off, click the Display button in the upper left-hand corner of the network view panel window.

== Strength of Inhibitory Conductances ==

Let's start by manipulating the maximal conductance for the inhibitory current into the excitatory units, <code>ff_hidden_g_bar.i</code>, which multiplies the level of inhibition coming into the hidden layer (excitatory) neurons.  Clearly, one would predict that this plays an important role.

* Decrease ff_hidden_g_bar.i from 5 to 3 and press Run.  Then increase it to 7 and press Run.

<hr>

'''Question 3.10 (a)''' ''What effect does decreasing ff_hidden_g_bar_i have on the average level of excitation of the hidden units and of the inhibitory units?'' '''(b)''' ''What effect does increasing ff_hidden_g_bar.i have on the average level of excitation of the hidden units and of the inhibitory units?'' '''(c)''' ''Explain this pattern of results.''

<hr>

* Set ff_hidden_g_bar.i back to 5.

Now, let's see what happens when we manipulate the corresponding parameter for the inhibition coming into the inhibitory neurons, <code>ff_inhib_g_bar.i</code>.  You might expect to get results similar to those just obtained for ff_hidden_g_bar.i, but be careful -- inhibition upon inhibitory neurons could have interesting consequences.  

* First Init and Run with a ff_inhib_g_bar.i of 4 for comparison.  Then decrease ff_inhib_g_bar.i to 3 and Run, and next increase ff_inhib_g_bar.i to 5 and Run.
  
With a ff_inhib_g_bar.i of 3, you should see that the excitatory activation drops, but the inhibitory level stays roughly the same!  With a value of 5, the excitatory activation level increases, but the inhibition again remains the same.  This is a difficult phenomenon to understand, but the following provide a few ways of thinking about what is going on.

First, it seems straightforward that reducing the amount of inhibition on the inhibitory neurons should result in more activation of the inhibitory neurons.  If you just look at the very first blip of activity for the inhibitory neurons, this is true (as is the converse that increasing the inhibition results in lower activation).  However, once the feedback inhibition starts to kick in as the hidden units become active, the inhibitory activity returns to the same level for all runs.  This makes sense if the greater activation of the inhibitory units for the ff_inhib_g_bar.i = 3 case then inhibits the hidden units more (which it does, causing them to have lower activation), which then would result in {\\em less} activation of the inhibitory units coming from the feedback from the hidden units.  This reduced activation of the inhibitory neurons cancels out the increased activation from the lower ff_inhib_g_bar.i value, resulting in the same inhibitory activation level.  The mystery is why the hidden units remain at their lower activation levels once the inhibition goes back to its original activation level.

One way we can explain this is by noting that this is a ''dynamic'' system, not a static balance of excitation and inhibition.  Every time the excitatory hidden units start to get a little bit more active, they in turn activate the inhibitory units more easily (because they are less apt to inhibit themselves), which in turn provides just enough extra inhibition to offset the advance of the hidden units.  This battle is effectively played out at the level of the ''derivatives'' (changes) in activations in the two pools of units, not their absolute levels, which would explain why we cannot really see much evidence of it by looking at only these absolute levels.

A more intuitive (but somewhat inaccurate in the details) way of understanding the effect of inhibition on inhibitory neurons is in terms of the location of the thermostat relative to the AC output vent -- if you place the thermostat very close to the AC vent (while you are sitting some constant distance away from the vent), you will be warmer than if the thermostat was far away from the AC output.  Thus, how strongly the thermostat is driven by the AC output vent is analogous to the ff_inhib_g_bar.i parameter -- larger values of ff_inhib_g_bar.i are like having the thermostat closer to the vent, and will result in higher levels of activation (greater warmth) in the hidden layer, and the converse for smaller values.

* Set ff_inhib_g_bar.i back to 4 before continuing (or hit Defaults). 

== Roles of Feedforward and Feedback Inhibition ==

Next we assess the importance and properties of the feedforward versus feedback inhibitory projections by manipulating their relative strengths.  The control panel has two parameters that determine the relative contribution of the feedforward and feedback inhibitory pathways: ff_ff_wt_scale applies to the feedforward weights from the input to the inhibitory units, and ff_fb_wt_scale applies to the feedback weights from the hidden layer to the inhibitory units.  These parameters (specifically the .rel components of them) uniformly scale the strengths of an entire projection of connections from one layer to another, and are the arbitrary wt_scale.rel (r_k) relative scaling parameters described in section 2.5.1 of the textbook.

* Set ff_ff_wt_scale.rel to 0, effectively eliminating the feedforward excitatory inputs to the inhibitory neurons from the input layer.

<hr>

'''Question 3.11 (a)''' ''How does this affect the behavior of the excitatory and inhibitory average activity levels?'' '''(b)''' ''Explain this result. (Hint: think about the anticipatory effects of feedforward inhibition.)  Next, set ff_ff_wt_scale.rel back to .35 and set ff_fb_wt_scale.rel to 0 to turn off the feedback inhibition.''  '''(c)''' ''Now what happens?'' '''(d)''' ''Try finding a value of ff_ff_wt_scale.rel (in increments of .05) that gives roughly the same activity level as the initial default system -- how does this differ from the initial system?  Explain this pattern of results.'' '''(e)''' ''Explain why both kinds of inhibition are useful for producing a system that responds in a rapid but controlled way to excitatory inputs.''

<hr>

== Time Constants and Feedforward Anticipation ==

We just saw that feedforward inhibition is important for anticipating and offsetting the excitation coming from the inputs to the hidden layer.  In addition to this feedforward inhibitory connectivity, the anticipatory effect depends on a difference between excitatory and inhibitory neurons in their rate of updating, which is controlled by the dt.vm parameters <code>hidden_dt.vm</code> and <code>inhib_dt.vm</code> in the control panel (cf. section 2.4.5, equation 2.7 in the textbook).  As you can see, the excitatory neurons are updated at .04 (slower), while the inhibitory are at .15 (faster).  The faster updating of the inhibitory neurons allows them to more quickly become activated by the feedforward input, and send anticipatory inhibition to the excitatory hidden units before they actually get activated.

* To verify this, click on Defaults, set inhib_dt.vm to .04 (instead of .15), and then Run.

The faster time constant also enables inhibition to more rapidly adapt to changes in the overall excitation level.  There is ample evidence that cortical inhibitory neurons respond faster to inputs than pyramidal neurons (e.g., Douglas & Martin, 1990).

One other important practical point about these update rate constants will prove to be an important advantage of the simplified inhibitory functions described in the next section.  These rate constants must be set to be relatively slow to prevent oscillatory behavior.  

* To see this, press Defaults, and then set inhib_dt.vm to .2, and hidden_dt.vm to .1 and Run.

These oscillations are largely prevented with finer time scale upgrading, because the excitatory neurons update their activity in smaller steps, to which the inhibitory neurons are better able to smoothly react.  

== Effects of Learning ==

One of the important things that inhibition must do is to compensate adequately for the changes in weight values that accompany learning.  Typically, as units learn, they develop greater levels of variance in the amount of excitatory input received from the input patterns, with some patterns providing strong excitation to a given unit and others producing less.  This is a natural result of the specialization of units for representing (detecting) some things and not others.  We can test whether the current inhibitory mechanism adequately handles these changes by simulating the effects of learning, by giving units excitatory weight values with a higher level of variance.

* First, press Defaults to return to the default parameters.  Run this case to get a baseline for comparison.

In this case, the network's weights are produced by generating random numbers with a mean of .25, and a uniform variance around that mean of .2.  

* Next, set the <code>wt_type</code> parameter in the control panel to TRAINED, and hit the <code>SetWeights</code> button. 

The weights are then initialized with the same mean but a variance of .7 using Gaussian (normally) distributed values.  This produces a much higher variance of excitatory net inputs for units in the hidden layer.  There is also an increase in the total overall weight strength with the increase in variance because there is more room for larger weights above the .25 mean, but not much more below it.  

* Press Run to see what difference this makes for the overall excitatory level.

You should observe a greater level of excitation using the trained weights compared to the initial untrained weights.

* You can verify that the system can compensate for this change by increasing the ff_hidden_g_bar_i to 8.

== Bidirectional Excitation ==

To make things simpler at the outset, we have so far been exploring a relatively easy case for inhibition where the network does not have the bidirectional excitatory connectivity that overwhelmed the constant leak counterweight in section 3.4.3 of the textbook.  Now, let's try running a network with two bidirectionally connected hidden layers (figure 3.22).  

* First, select Defaults to get back the default parameters, do a Run for comparison, and then set network in the control panel to BidirExcite instead of FFExcite.  Then click on the [[.T3Tab.BidirExcite]] tab in the right viewer panel to view this network.

In extending the network to the bidirectional case, we also have to extend our notions of what feedforward inhibition is.  In general, the role of feedforward inhibition is to anticipate and counterbalance the level of excitatory input coming into a layer.  Thus, in a network with bidirectional excitatory connectivity, the inhibitory neurons for a given layer also have to receive the top-down excitatory connections, which play the role of \"feedforward\" inhibition.  

* Verify that this network has both bidirectional excitatory connectivity and the \"feedforward\" inhibition coming back from the second hidden layer by examining the r.wt weights as usual.

* Now Run this network.

The graph view (figure 3.23) shows the average activity for only the first hidden and inhibitory layers (as before).  Note that the initial part up until the point where the second hidden layer begins to be active is the same as before, but as the second layer activates, it feeds back to the first layer inhibitory neurons, which become more active, as do the excitatory neurons.  However, the overall activity level remains quite under control and not substantially different than before, which is in distinct contrast to the earlier simulations with just a leak current operating.

Next, we will see that inhibition is differentially important for bidirectionally connected networks.

* Set the bd_hidden_g_bar.i parameter (note the bd -- in the 2nd group of parameters) to 3, and Run.

This reduces the amount of inhibition on the excitatory neurons.  Note that this has a relatively small impact on the initial, feedforward portion of the activity curve, but when the second hidden layer becomes active, the network becomes catastrophically over activated -- an epileptic fit!  

* Set the bd_hidden_g_bar.i parameter back to 5.

== Set Point Behavior ==

Our final exploration of inhibition provides some motivation for the summary inhibition functions presented in the next section.  Here, we explore what happens to the activity levels when different overall levels of excitatory input are presented to the network.  

* First, press Init on the control panel and Run the network for purposes of comparison.}

The input pattern is set to have the default of 20 (out of 100) units active, which is what we have been using all along.  

* Change the input_pct field in the control panel to 15 instead of 20, Apply, and then hit the SetInputPct button to make a new input pattern with this new percentage activity.  Then do Run.

This changes the input pattern to have 15 units active.  When you Run now, the activity level is not substantially different from the previous case (a difference of 1--2%).

* Next, set input_pct to 25, Apply, SetInputPct, and Run.

Again, you should observe only modest increases in activity level.

Thus, the network appears to be relatively robust to changes in overall input excitation, though it does show some effect.  Perhaps a more dramatic demonstration comes from the relatively small differences between the initial activity level in the hidden units compared to the subsequent level after the input from the second hidden layer has kicked in.  It is this approximate {\\em set point} behavior, where the system tends to produce a relatively fixed level of activity regardless of the magnitude of the excitatory input, that is captured by the inhibition functions described in the next section.

<hr>

'''Question 3.12''' ''Explain in general terms why the system exhibits this set point behavior.''

<hr>

* Last, you can also change the activation function, using the act_fun setting in the control panel.

You should see that the same basic principles apply when the units use a spiking activation function.

== Exploration of kWTA Inhibition (Section 3.5.4) ==

* Reset the parameters to their default values using the Defaults button, set the network to BidirExcite, and Run to get the initial state of the network.

This should reproduce the standard activation graph for the case with actual inhibitory neurons.

* Now, set the <code>bdir_inhib.type</code> to KWTA_INHIB instead of the default UNIT_INHIB to use the basic kWTA function described in the text.  Also '''set the bdir_hidden_g_bar.i parameter to 1.0, and the bdir_hidden_dt.vm parameter to to .2''' (if you don't set g_bar.i to 1.0, no units will get active, because the inhibition will be 5 times as strong as it should be!).  Hit Apply.

The ''k'' value of this function is set according to the <code>bdir kwta.pct value</code> in the control panel (this proportion value of .15 is automatically translated into a corresponding k value, 15 in this case, by the software).  

* Press Run.

Notice that roughly the same level of activity results (the inhibitory activity is at zero, because these units are not used for this function).  Also, the activity function is somewhat smoother, because the kWTA function effectively does a perfect job of anticipating the appropriate level of inhibition required.  The faster bdir_hidden_dt.vm parameter makes the activation rise very quickly -- more on this below.

* Now select KWTA_AVG_INHIB for the bdir_inhib.type to use the average-based kWTA function, and set the kwta.pt value there to .6 instead of .25  (Apply), and Run again.

You should observe that the hidden layer activation stabilizes on the target activation level of 15 percent.

* To test the set point behavior of the kWTA functions, run the network with input_pct levels of 10 and 30 (do not forget to hit SetInputPct) in addition to the standard 20 (you can do this for both types of kWTA function).

Notice that these functions exhibit stronger set point behavior than the inhibitory unit based inhibition (with the average-based kWTA showing just slightly more variability in overall activity level). This is because the kWTA functions are designed explicitly to have a set point, whereas the inhibitory units only roughly produce set-point behavior.  Thus, we must always remember that the kWTA functions are merely an ''idealized approximation'' of the effects of inhibitory neurons, and do not behave in an identical fashion.

Next we will see one of the main advantages of the kWTA functions.

* Set the input_pct back to the default 20 (and SetInputPct).  Set bdir_inhib.type to KWTA_INHIB with kwta_pt set to .25, and try to find the fastest update parameter bdir_hidden_dt.vm (in increments of .1, to a maximum of 1) that does not result in significant oscillatory behavior.

<hr>

'''Question 3.13 (a)''' ''What was the highest value of bdir_hidden_dt.vm that you found?  How does this compare with the value of this parameter for unit-based inhibition (.04)?'' '''(b)''' ''Why do you think kWTA can use such a fast update rate where unit-based inhibition cannot?''

<hr>

* Return the bdir_hidden_dt.vm parameter to .2 before continuing.

For the ''k-or-less'' property of the basic kWTA function to apply, you have to set a leak current value g_bar.l that prevents weak excitation from activating the units, but allows strong excitation to produce activation.

* To see this k-or-less property, increase bdir_hidden_g_bar.l (in .1 increments) to find a value that prevents excitation from an input_pct of 10 or less from activating any of the hidden units, but allows excitation of 20 or more to activate both layers.

</body>
</html>
";
   html_text="<html><head></head><body>
<h1> Feedforward and Feedback Inhibition </h1>
<p>
The network in the right view panel contains a 10x10 unit input layer, which projects to both the 10x10 hidden layer of excitatory units, and a layer of 20 inhibitory neurons (figure~3.20 in the textbook).  These inhibitory neurons will regulate the activation level of the hidden layer units, and should be thought of as the inhibitory units for the hidden layer (even though they are in their own layer for the purposes of this simulation).  The ratio of 20 inhibitory units to 120 total hidden units (17 percent) is like that found in the cortex, which is commonly cited as roughly 15 percent (White, 1989a; Zilles, 1990).  The inhibitory neurons are just like the excitatory neurons, except that their outputs contribute to the inhibitory conductance of a neuron instead of its excitatory conductance.  We have also set one of the activation parameters to be different for these inhibitory neurons, as discussed below.
</p><p>
Let's begin as usual by viewing the weights of the network.
</p><p>
</p><ul><li> Select <code>r.wt</code> in the <a href=\"ta:.PanelTab.FFExcite\">FFExcite</a> netview control panel and then click on some of the hidden layer and inhib layer units with the red arrow.
</li></ul>
Most of the weights are random, except for those from the inhibitory units, which are fixed at a constant value of .5.  Notice also that the hidden layer excitatory units receive from the input and inhibitory units, while the inhibitory units receive feedforward connections from the input layer, and feedback connections from the excitatory hidden units, as well as inhibitory connections from themselves.
<p>
Now, we will run the network. Note the graph view above the network, which will record the overall levels of activation (average activation) in the hidden and inhibitory units.
</p><p>
</p><ul><li> Now, select <code>act</code> to view activations in the network window, and press <a href=\"ta:.programs.LeabraEpoch.Init()\">Init</a> and <a href=\"ta:.programs.LeabraEpoch.Run()\">Run</a> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>.
</li></ul>
You will see the input units activated by a random activity pattern, and after several cycles of activation updating, the hidden and inhibitory units will become active.  The activation appears quite controlled, as the inhibition counterbalances the excitation from the input layer.  Note that the level of the leak current, g_bar.l, is very small at .01, so that virtually all of the counterbalancing of excitation is being performed by the inhibition, not by the leak current.  From the average activity plotted in the graph window (figure 3.21 in the textbook), you should see that the hidden layer (black line) has around 10 percent activation.
<p>
In the next sections, we manipulate some of the parameters in the control panel to get a better sense of the principles underlying the inhibitory dynamics in the network.  Because we will be running the network many times, you may want to toggle the network display off to speed up the settling process (the graph log contains the relevant information anyway).
</p><p>
</p><ul><li> To toggle the display off, click the Display button in the upper left-hand corner of the network view panel window.
</li></ul>
<h2> Strength of Inhibitory Conductances </h2>
<p>
Let's start by manipulating the maximal conductance for the inhibitory current into the excitatory units, <code>ff_hidden_g_bar.i</code>, which multiplies the level of inhibition coming into the hidden layer (excitatory) neurons.  Clearly, one would predict that this plays an important role.
</p><p>
</p><ul><li> Decrease ff_hidden_g_bar.i from 5 to 3 and press Run.  Then increase it to 7 and press Run.
</li></ul>
<hr>
<p>
 <b>Question 3.10 (a)</b>   <i>What effect does decreasing ff_hidden_g_bar_i have on the average level of excitation of the hidden units and of the inhibitory units?</i>   <b>(b)</b>   <i>What effect does increasing ff_hidden_g_bar.i have on the average level of excitation of the hidden units and of the inhibitory units?</i>   <b>(c)</b>   <i>Explain this pattern of results.</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Set ff_hidden_g_bar.i back to 5.
</li></ul>
Now, let's see what happens when we manipulate the corresponding parameter for the inhibition coming into the inhibitory neurons, <code>ff_inhib_g_bar.i</code>.  You might expect to get results similar to those just obtained for ff_hidden_g_bar.i, but be careful -- inhibition upon inhibitory neurons could have interesting consequences.  
<p>
</p><ul><li> First Init and Run with a ff_inhib_g_bar.i of 4 for comparison.  Then decrease ff_inhib_g_bar.i to 3 and Run, and next increase ff_inhib_g_bar.i to 5 and Run.
  </li></ul>
With a ff_inhib_g_bar.i of 3, you should see that the excitatory activation drops, but the inhibitory level stays roughly the same!  With a value of 5, the excitatory activation level increases, but the inhibition again remains the same.  This is a difficult phenomenon to understand, but the following provide a few ways of thinking about what is going on.
<p>
First, it seems straightforward that reducing the amount of inhibition on the inhibitory neurons should result in more activation of the inhibitory neurons.  If you just look at the very first blip of activity for the inhibitory neurons, this is true (as is the converse that increasing the inhibition results in lower activation).  However, once the feedback inhibition starts to kick in as the hidden units become active, the inhibitory activity returns to the same level for all runs.  This makes sense if the greater activation of the inhibitory units for the ff_inhib_g_bar.i = 3 case then inhibits the hidden units more (which it does, causing them to have lower activation), which then would result in {\\em less} activation of the inhibitory units coming from the feedback from the hidden units.  This reduced activation of the inhibitory neurons cancels out the increased activation from the lower ff_inhib_g_bar.i value, resulting in the same inhibitory activation level.  The mystery is why the hidden units remain at their lower activation levels once the inhibition goes back to its original activation level.
</p><p>
One way we can explain this is by noting that this is a  <i>dynamic</i>  system, not a static balance of excitation and inhibition.  Every time the excitatory hidden units start to get a little bit more active, they in turn activate the inhibitory units more easily (because they are less apt to inhibit themselves), which in turn provides just enough extra inhibition to offset the advance of the hidden units.  This battle is effectively played out at the level of the  <i>derivatives</i>  (changes) in activations in the two pools of units, not their absolute levels, which would explain why we cannot really see much evidence of it by looking at only these absolute levels.
</p><p>
A more intuitive (but somewhat inaccurate in the details) way of understanding the effect of inhibition on inhibitory neurons is in terms of the location of the thermostat relative to the AC output vent -- if you place the thermostat very close to the AC vent (while you are sitting some constant distance away from the vent), you will be warmer than if the thermostat was far away from the AC output.  Thus, how strongly the thermostat is driven by the AC output vent is analogous to the ff_inhib_g_bar.i parameter -- larger values of ff_inhib_g_bar.i are like having the thermostat closer to the vent, and will result in higher levels of activation (greater warmth) in the hidden layer, and the converse for smaller values.
</p><p>
</p><ul><li> Set ff_inhib_g_bar.i back to 4 before continuing (or hit Defaults). 
</li></ul>
<h2> Roles of Feedforward and Feedback Inhibition </h2>
<p>
Next we assess the importance and properties of the feedforward versus feedback inhibitory projections by manipulating their relative strengths.  The control panel has two parameters that determine the relative contribution of the feedforward and feedback inhibitory pathways: ff_ff_wt_scale applies to the feedforward weights from the input to the inhibitory units, and ff_fb_wt_scale applies to the feedback weights from the hidden layer to the inhibitory units.  These parameters (specifically the .rel components of them) uniformly scale the strengths of an entire projection of connections from one layer to another, and are the arbitrary wt_scale.rel (r_k) relative scaling parameters described in section 2.5.1 of the textbook.
</p><p>
</p><ul><li> Set ff_ff_wt_scale.rel to 0, effectively eliminating the feedforward excitatory inputs to the inhibitory neurons from the input layer.
</li></ul>
<hr>
<p>
 <b>Question 3.11 (a)</b>   <i>How does this affect the behavior of the excitatory and inhibitory average activity levels?</i>   <b>(b)</b>   <i>Explain this result. (Hint: think about the anticipatory effects of feedforward inhibition.)  Next, set ff_ff_wt_scale.rel back to .35 and set ff_fb_wt_scale.rel to 0 to turn off the feedback inhibition.</i>    <b>(c)</b>   <i>Now what happens?</i>   <b>(d)</b>   <i>Try finding a value of ff_ff_wt_scale.rel (in increments of .05) that gives roughly the same activity level as the initial default system -- how does this differ from the initial system?  Explain this pattern of results.</i>   <b>(e)</b>   <i>Explain why both kinds of inhibition are useful for producing a system that responds in a rapid but controlled way to excitatory inputs.</i> 
</p><p>
</p><hr>
<p>
</p><h2> Time Constants and Feedforward Anticipation </h2>
<p>
We just saw that feedforward inhibition is important for anticipating and offsetting the excitation coming from the inputs to the hidden layer.  In addition to this feedforward inhibitory connectivity, the anticipatory effect depends on a difference between excitatory and inhibitory neurons in their rate of updating, which is controlled by the dt.vm parameters <code>hidden_dt.vm</code> and <code>inhib_dt.vm</code> in the control panel (cf. section 2.4.5, equation 2.7 in the textbook).  As you can see, the excitatory neurons are updated at .04 (slower), while the inhibitory are at .15 (faster).  The faster updating of the inhibitory neurons allows them to more quickly become activated by the feedforward input, and send anticipatory inhibition to the excitatory hidden units before they actually get activated.
</p><p>
</p><ul><li> To verify this, click on Defaults, set inhib_dt.vm to .04 (instead of .15), and then Run.
</li></ul>
The faster time constant also enables inhibition to more rapidly adapt to changes in the overall excitation level.  There is ample evidence that cortical inhibitory neurons respond faster to inputs than pyramidal neurons (e.g., Douglas &amp; Martin, 1990).
<p>
One other important practical point about these update rate constants will prove to be an important advantage of the simplified inhibitory functions described in the next section.  These rate constants must be set to be relatively slow to prevent oscillatory behavior.  
</p><p>
</p><ul><li> To see this, press Defaults, and then set inhib_dt.vm to .2, and hidden_dt.vm to .1 and Run.
</li></ul>
These oscillations are largely prevented with finer time scale upgrading, because the excitatory neurons update their activity in smaller steps, to which the inhibitory neurons are better able to smoothly react.  
<p>
</p><h2> Effects of Learning </h2>
<p>
One of the important things that inhibition must do is to compensate adequately for the changes in weight values that accompany learning.  Typically, as units learn, they develop greater levels of variance in the amount of excitatory input received from the input patterns, with some patterns providing strong excitation to a given unit and others producing less.  This is a natural result of the specialization of units for representing (detecting) some things and not others.  We can test whether the current inhibitory mechanism adequately handles these changes by simulating the effects of learning, by giving units excitatory weight values with a higher level of variance.
</p><p>
</p><ul><li> First, press Defaults to return to the default parameters.  Run this case to get a baseline for comparison.
</li></ul>
In this case, the network's weights are produced by generating random numbers with a mean of .25, and a uniform variance around that mean of .2.  
<p>
</p><ul><li> Next, set the <code>wt_type</code> parameter in the control panel to TRAINED, and hit the <code>SetWeights</code> button. 
</li></ul>
The weights are then initialized with the same mean but a variance of .7 using Gaussian (normally) distributed values.  This produces a much higher variance of excitatory net inputs for units in the hidden layer.  There is also an increase in the total overall weight strength with the increase in variance because there is more room for larger weights above the .25 mean, but not much more below it.  
<p>
</p><ul><li> Press Run to see what difference this makes for the overall excitatory level.
</li></ul>
You should observe a greater level of excitation using the trained weights compared to the initial untrained weights.
<p>
</p><ul><li> You can verify that the system can compensate for this change by increasing the ff_hidden_g_bar_i to 8.
</li></ul>
<h2> Bidirectional Excitation </h2>
<p>
To make things simpler at the outset, we have so far been exploring a relatively easy case for inhibition where the network does not have the bidirectional excitatory connectivity that overwhelmed the constant leak counterweight in section 3.4.3 of the textbook.  Now, let's try running a network with two bidirectionally connected hidden layers (figure 3.22).  
</p><p>
</p><ul><li> First, select Defaults to get back the default parameters, do a Run for comparison, and then set network in the control panel to BidirExcite instead of FFExcite.  Then click on the <a href=\"ta:.T3Tab.BidirExcite\">BidirExcite</a> tab in the right viewer panel to view this network.
</li></ul>
In extending the network to the bidirectional case, we also have to extend our notions of what feedforward inhibition is.  In general, the role of feedforward inhibition is to anticipate and counterbalance the level of excitatory input coming into a layer.  Thus, in a network with bidirectional excitatory connectivity, the inhibitory neurons for a given layer also have to receive the top-down excitatory connections, which play the role of \"feedforward\" inhibition.  
<p>
</p><ul><li> Verify that this network has both bidirectional excitatory connectivity and the \"feedforward\" inhibition coming back from the second hidden layer by examining the r.wt weights as usual.
</li></ul>
<ul><li> Now Run this network.
</li></ul>
The graph view (figure 3.23) shows the average activity for only the first hidden and inhibitory layers (as before).  Note that the initial part up until the point where the second hidden layer begins to be active is the same as before, but as the second layer activates, it feeds back to the first layer inhibitory neurons, which become more active, as do the excitatory neurons.  However, the overall activity level remains quite under control and not substantially different than before, which is in distinct contrast to the earlier simulations with just a leak current operating.
<p>
Next, we will see that inhibition is differentially important for bidirectionally connected networks.
</p><p>
</p><ul><li> Set the bd_hidden_g_bar.i parameter (note the bd -- in the 2nd group of parameters) to 3, and Run.
</li></ul>
This reduces the amount of inhibition on the excitatory neurons.  Note that this has a relatively small impact on the initial, feedforward portion of the activity curve, but when the second hidden layer becomes active, the network becomes catastrophically over activated -- an epileptic fit!  
<p>
</p><ul><li> Set the bd_hidden_g_bar.i parameter back to 5.
</li></ul>
<h2> Set Point Behavior </h2>
<p>
Our final exploration of inhibition provides some motivation for the summary inhibition functions presented in the next section.  Here, we explore what happens to the activity levels when different overall levels of excitatory input are presented to the network.  
</p><p>
</p><ul><li> First, press Init on the control panel and Run the network for purposes of comparison.}
</li></ul>
The input pattern is set to have the default of 20 (out of 100) units active, which is what we have been using all along.  
<p>
</p><ul><li> Change the input_pct field in the control panel to 15 instead of 20, Apply, and then hit the SetInputPct button to make a new input pattern with this new percentage activity.  Then do Run.
</li></ul>
This changes the input pattern to have 15 units active.  When you Run now, the activity level is not substantially different from the previous case (a difference of 1--2%).
<p>
</p><ul><li> Next, set input_pct to 25, Apply, SetInputPct, and Run.
</li></ul>
Again, you should observe only modest increases in activity level.
<p>
Thus, the network appears to be relatively robust to changes in overall input excitation, though it does show some effect.  Perhaps a more dramatic demonstration comes from the relatively small differences between the initial activity level in the hidden units compared to the subsequent level after the input from the second hidden layer has kicked in.  It is this approximate {\\em set point} behavior, where the system tends to produce a relatively fixed level of activity regardless of the magnitude of the excitatory input, that is captured by the inhibition functions described in the next section.
</p><p>
</p><hr>
<p>
 <b>Question 3.12</b>   <i>Explain in general terms why the system exhibits this set point behavior.</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Last, you can also change the activation function, using the act_fun setting in the control panel.
</li></ul>
You should see that the same basic principles apply when the units use a spiking activation function.
<p>
</p><h2> Exploration of kWTA Inhibition (Section 3.5.4) </h2>
<p>
</p><ul><li> Reset the parameters to their default values using the Defaults button, set the network to BidirExcite, and Run to get the initial state of the network.
</li></ul>
This should reproduce the standard activation graph for the case with actual inhibitory neurons.
<p>
</p><ul><li> Now, set the <code>bdir_inhib.type</code> to KWTA_INHIB instead of the default UNIT_INHIB to use the basic kWTA function described in the text.  Also  <b>set the bdir_hidden_g_bar.i parameter to 1.0, and the bdir_hidden_dt.vm parameter to to .2</b>  (if you don't set g_bar.i to 1.0, no units will get active, because the inhibition will be 5 times as strong as it should be!).  Hit Apply.
</li></ul>
The  <i>k</i>  value of this function is set according to the <code>bdir kwta.pct value</code> in the control panel (this proportion value of .15 is automatically translated into a corresponding k value, 15 in this case, by the software).  
<p>
</p><ul><li> Press Run.
</li></ul>
Notice that roughly the same level of activity results (the inhibitory activity is at zero, because these units are not used for this function).  Also, the activity function is somewhat smoother, because the kWTA function effectively does a perfect job of anticipating the appropriate level of inhibition required.  The faster bdir_hidden_dt.vm parameter makes the activation rise very quickly -- more on this below.
<p>
</p><ul><li> Now select KWTA_AVG_INHIB for the bdir_inhib.type to use the average-based kWTA function, and set the kwta.pt value there to .6 instead of .25  (Apply), and Run again.
</li></ul>
You should observe that the hidden layer activation stabilizes on the target activation level of 15 percent.
<p>
</p><ul><li> To test the set point behavior of the kWTA functions, run the network with input_pct levels of 10 and 30 (do not forget to hit SetInputPct) in addition to the standard 20 (you can do this for both types of kWTA function).
</li></ul>
Notice that these functions exhibit stronger set point behavior than the inhibitory unit based inhibition (with the average-based kWTA showing just slightly more variability in overall activity level). This is because the kWTA functions are designed explicitly to have a set point, whereas the inhibitory units only roughly produce set-point behavior.  Thus, we must always remember that the kWTA functions are merely an  <i>idealized approximation</i>  of the effects of inhibitory neurons, and do not behave in an identical fashion.
<p>
Next we will see one of the main advantages of the kWTA functions.
</p><p>
</p><ul><li> Set the input_pct back to the default 20 (and SetInputPct).  Set bdir_inhib.type to KWTA_INHIB with kwta_pt set to .25, and try to find the fastest update parameter bdir_hidden_dt.vm (in increments of .1, to a maximum of 1) that does not result in significant oscillatory behavior.
</li></ul>
<hr>
<p>
 <b>Question 3.13 (a)</b>   <i>What was the highest value of bdir_hidden_dt.vm that you found?  How does this compare with the value of this parameter for unit-based inhibition (.04)?</i>   <b>(b)</b>   <i>Why do you think kWTA can use such a fast update rate where unit-based inhibition cannot?</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Return the bdir_hidden_dt.vm parameter to .2 before continuing.
</li></ul>
For the  <i>k-or-less</i>  property of the basic kWTA function to apply, you have to set a leak current value g_bar.l that prevents weak excitation from activating the units, but allows strong excitation to produce activation.
<p>
</p><ul><li> To see this k-or-less property, increase bdir_hidden_g_bar.l (in .1 increments) to find a value that prevents excitation from an input_pct of 10 or less from activating any of the hidden units, but allows excitation of 20 or more to activate both layers.
</li></ul>


</body></html>";
  };
  taDoc @[1] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Inhibition";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Inhibition";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Inhibition,CECN1 Projects,Emergent,.PanelTab.FFExcite,.programs.LeabraEpoch.Init(),.programs.LeabraEpoch.Run(),.PanelTab.ControlPanel,.T3Tab.BidirExcite\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Inhibition - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Inhibition\";
		var wgTitle = \"CECN1 Inhibition\";
		var wgAction = \"view\";
		var wgArticleId = \"67\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 424;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Inhibition skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Inhibition</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Inhibition\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Inhibition</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Strength_of_Inhibitory_Conductances\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Strength of Inhibitory Conductances</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Roles_of_Feedforward_and_Feedback_Inhibition\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Roles of Feedforward and Feedback Inhibition</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Time_Constants_and_Feedforward_Anticipation\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Time Constants and Feedforward Anticipation</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Effects_of_Learning\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Effects of Learning</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Bidirectional_Excitation\"><span class=\"tocnumber\">2.5</span> <span class=\"toctext\">Bidirectional Excitation</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Set_Point_Behavior\"><span class=\"tocnumber\">2.6</span> <span class=\"toctext\">Set Point Behavior</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Exploration_of_kWTA_Inhibition_.28Section_3.5.4.29\"><span class=\"tocnumber\">2.7</span> <span class=\"toctext\">Exploration of kWTA Inhibition (Section 3.5.4)</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Inhibition\" id=\"Inhibition\"></a><h1> <span class=\"mw-headline\"> Inhibition </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/2/27/inhib.proj\" class=\"internal\" title=\"inhib.proj\">inhib.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p>The network in the right view panel contains a 10x10 unit input layer, which projects to both the 10x10 hidden layer of excitatory units, and a layer of 20 inhibitory neurons (figure~3.20 in the textbook).  These inhibitory neurons will regulate the activation level of the hidden layer units, and should be thought of as the inhibitory units for the hidden layer (even though they are in their own layer for the purposes of this simulation).  The ratio of 20 inhibitory units to 120 total hidden units (17 percent) is like that found in the cortex, which is commonly cited as roughly 15 percent (White, 1989a; Zilles, 1990).  The inhibitory neurons are just like the excitatory neurons, except that their outputs contribute to the inhibitory conductance of a neuron instead of its excitatory conductance.  We have also set one of the activation parameters to be different for these inhibitory neurons, as discussed below.
</p><p>Let's begin as usual by viewing the weights of the network.
</p>
<ul><li> Select <code>r.wt</code> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.FFExcite&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.FFExcite (page does not exist)\">.PanelTab.FFExcite</a> netview control panel and then click on some of the hidden layer and inhib layer units with the red arrow.
</li></ul>
<p>Most of the weights are random, except for those from the inhibitory units, which are fixed at a constant value of .5.  Notice also that the hidden layer excitatory units receive from the input and inhibitory units, while the inhibitory units receive feedforward connections from the input layer, and feedback connections from the excitatory hidden units, as well as inhibitory connections from themselves.
</p><p>Now, we will run the network. Note the graph view above the network, which will record the overall levels of activation (average activation) in the hidden and inhibitory units.
</p>
<ul><li> Now, select <code>act</code> to view activations in the network window, and press <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraEpoch.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraEpoch.Init() (page does not exist)\">Init</a> and <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraEpoch.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraEpoch.Run() (page does not exist)\">Run</a> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>.
</li></ul>
<p>You will see the input units activated by a random activity pattern, and after several cycles of activation updating, the hidden and inhibitory units will become active.  The activation appears quite controlled, as the inhibition counterbalances the excitation from the input layer.  Note that the level of the leak current, g_bar.l, 
is very small at .01, so that virtually all of the counterbalancing of excitation is being performed by the inhibition, not by the leak current.  From the average activity plotted in the graph window (figure 3.21 in the textbook), you should see that the hidden layer (black line) has around 10 percent activation.
</p><p>In the next sections, we manipulate some of the parameters in the control panel to get a better sense of the principles underlying the inhibitory dynamics in the network.  Because we will be running the network many times, you may want to toggle the network display off to speed up the settling process (the graph log contains the relevant information anyway).
</p>
<ul><li> To toggle the display off, click the Display button in the upper left-hand corner of the network view panel window.
</li></ul>
<a name=\"Strength_of_Inhibitory_Conductances\" id=\"Strength_of_Inhibitory_Conductances\"></a><h2> <span class=\"mw-headline\"> Strength of Inhibitory Conductances </span></h2>
<p>Let's start by manipulating the maximal conductance for the inhibitory current into the excitatory units, <code>ff_hidden_g_bar.i</code>, which multiplies the level of inhibition coming into the hidden layer (excitatory) neurons.  Clearly, one would predict that this plays an important role.
</p>
<ul><li> Decrease ff_hidden_g_bar.i from 5 to 3 and press Run.  Then increase it to 7 and press Run.
</li></ul>
<hr>
<p><b>Question 3.10 (a)</b> <i>What effect does decreasing ff_hidden_g_bar_i have on the average level of excitation of the hidden units and of the inhibitory units?</i> <b>(b)</b> <i>What effect does increasing ff_hidden_g_bar.i have on the average level of excitation of the hidden units and of the inhibitory units?</i> <b>(c)</b> <i>Explain this pattern of results.</i>
</p>
<hr>
<ul><li> Set ff_hidden_g_bar.i back to 5.
</li></ul>
<p>Now, let's see what happens when we manipulate the corresponding parameter for the inhibition coming into the inhibitory neurons, <code>ff_inhib_g_bar.i</code>.  You might expect to get results similar to those just obtained for ff_hidden_g_bar.i, but be careful -- inhibition upon inhibitory neurons could have interesting consequences.  
</p>
<ul><li> First Init and Run with a ff_inhib_g_bar.i of 4 for comparison.  Then decrease ff_inhib_g_bar.i to 3 and Run,
</li></ul>
<p>and next increase ff_inhib_g_bar.i to 5 and Run.
</p><p>With a ff_inhib_g_bar.i of 3, you should see that the excitatory activation drops, but the inhibitory level stays roughly the same!  With a value of 5, the excitatory activation level increases, but the inhibition again remains the same.  This is a difficult phenomenon to understand, but the following provide a few ways of thinking about what is going on.
</p><p>First, it seems straightforward that reducing the amount of inhibition on the inhibitory neurons should result in more activation of the inhibitory neurons.  If you just look at the very first blip of activity for the inhibitory neurons, this is true (as is the converse that increasing the inhibition results in lower activation).  However, once the feedback inhibition starts to kick in as the hidden units become active, the inhibitory activity returns to the same level for all runs.  This makes sense if the greater activation of the inhibitory units for the ff_inhib_g_bar.i = 3 case then inhibits the hidden units more (which it does, causing them to have lower activation), which then would result in {\\em less} activation of the inhibitory units coming from the feedback from the hidden units.  This reduced activation of the inhibitory neurons cancels out the increased activation from the lower ff_inhib_g_bar.i value, resulting in the same inhibitory activation level.  The mystery is why the hidden units remain at their lower activation levels once the inhibition goes back to its original activation level.
</p><p>One way we can explain this is by noting that this is a <i>dynamic</i> system, not a static balance of excitation and inhibition.  Every time the excitatory hidden units start to get a little bit more active, they in turn activate the inhibitory units more easily (because they are less apt to inhibit themselves), which in turn provides just enough extra inhibition to offset the advance of the hidden units.  This battle is effectively played out at the level of the <i>derivatives</i> (changes) in activations in the two pools of units, not their absolute levels, which would explain why we cannot really see much evidence of it by looking at only these absolute levels.
</p><p>A more intuitive (but somewhat inaccurate in the details) way of understanding the effect of inhibition on inhibitory neurons is in terms of the location of the thermostat relative to the AC output vent -- if you place the thermostat very close to the AC vent (while you are sitting some constant distance away from the vent), you will be warmer than if the thermostat was far away from the AC output.  Thus, how strongly the thermostat is driven by the AC output vent is analogous to the ff_inhib_g_bar.i parameter -- larger values of ff_inhib_g_bar.i are like having the thermostat closer to the vent, and will result in higher levels of activation (greater warmth) in the hidden layer, and the converse for smaller values.
</p>
<ul><li> Set ff_inhib_g_bar.i back to 4 before continuing (or hit Defaults). 
</li></ul>
<a name=\"Roles_of_Feedforward_and_Feedback_Inhibition\" id=\"Roles_of_Feedforward_and_Feedback_Inhibition\"></a><h2> <span class=\"mw-headline\"> Roles of Feedforward and Feedback Inhibition </span></h2>
<p>Next we assess the importance and properties of the feedforward versus feedback inhibitory projections by manipulating their relative strengths.  The control panel has two parameters that determine the relative contribution of the feedforward and feedback inhibitory pathways: ff_ff_wt_scale applies to the feedforward weights from the input to the inhibitory units, and ff_fb_wt_scale applies to the feedback weights from the hidden layer to the inhibitory units.  These parameters (specifically the .rel components of them) uniformly scale the strengths of an entire projection of connections from one layer to another, and are the arbitrary wt_scale.rel (r_k) relative scaling parameters described in section 2.5.1 of the textbook.
</p>
<ul><li> Set ff_ff_wt_scale.rel to 0, effectively eliminating the feedforward excitatory inputs to the inhibitory neurons from the input layer.
</li></ul>
<hr>
<p><b>Question 3.11 (a)</b> <i>How does this affect the behavior of the excitatory and inhibitory average activity levels?</i> <b>(b)</b> <i>Explain this result. (Hint: think about the anticipatory effects of feedforward inhibition.)  Next, set ff_ff_wt_scale.rel back to .35 and set ff_fb_wt_scale.rel to 0 to turn off the feedback inhibition.</i>  <b>(c)</b> <i>Now what happens?</i> <b>(d)</b> <i>Try finding a value of ff_ff_wt_scale.rel (in increments of .05) that gives roughly the same activity level as the initial default system -- how does this differ from the initial system?  Explain this pattern of results.</i> <b>(e)</b> <i>Explain why both kinds of inhibition are useful for producing a system that responds in a rapid but controlled way to excitatory inputs.</i>
</p>
<hr>
<a name=\"Time_Constants_and_Feedforward_Anticipation\" id=\"Time_Constants_and_Feedforward_Anticipation\"></a><h2> <span class=\"mw-headline\"> Time Constants and Feedforward Anticipation </span></h2>
<p>We just saw that feedforward inhibition is important for anticipating and offsetting the excitation coming from the inputs to the hidden layer.  In addition to this feedforward inhibitory connectivity, the anticipatory effect depends on a difference between excitatory and inhibitory neurons in their rate of updating, which is controlled by the dt.vm parameters <code>hidden_dt.vm</code> and <code>inhib_dt.vm</code> in the control panel (cf. section 2.4.5, equation 2.7 in the textbook).  As you can see, the excitatory neurons are updated at .04 (slower), while the inhibitory are at .15 (faster).  The faster updating of the inhibitory neurons allows them to more quickly become activated by the feedforward input, and send anticipatory inhibition to the excitatory hidden units before they actually get activated.
</p>
<ul><li> To verify this, click on Defaults, set inhib_dt.vm to .04 (instead of .15), and then Run.
</li></ul>
<p>The faster time constant also enables inhibition to more rapidly adapt to changes in the overall excitation level.  There is ample evidence that cortical inhibitory neurons respond faster to inputs than pyramidal neurons (e.g., Douglas &amp; Martin, 1990).
</p><p>One other important practical point about these update rate constants will prove to be an important advantage of the simplified inhibitory functions described in the next section.  These rate constants must be set to be relatively slow to prevent oscillatory behavior.  
</p>
<ul><li> To see this, press Defaults, and then set inhib_dt.vm to .2, and hidden_dt.vm to .1 and Run.
</li></ul>
<p>These oscillations are largely prevented with finer time scale upgrading, because the excitatory neurons update their activity in smaller steps, to which the inhibitory neurons are better able to smoothly react.  
</p>
<a name=\"Effects_of_Learning\" id=\"Effects_of_Learning\"></a><h2> <span class=\"mw-headline\"> Effects of Learning </span></h2>
<p>One of the important things that inhibition must do is to compensate adequately for the changes in weight values that accompany learning.  Typically, as units learn, they develop greater levels of variance in the amount of excitatory input received from the input patterns, with some patterns providing strong excitation to a given unit and others producing less.  This is a natural result of the specialization of units for representing (detecting) some things and not others.  We can test whether the current inhibitory mechanism adequately handles these changes by simulating the effects of learning, by giving units excitatory weight values with a higher level of variance.
</p>
<ul><li> First, press Defaults to return to the default parameters.  Run this case to get a baseline for comparison.
</li></ul>
<p>In this case, the network's weights are produced by generating random numbers with a mean of .25, and a uniform variance around that mean of .2.  
</p>
<ul><li> Next, set the <code>wt_type</code> parameter in the control panel to TRAINED, and hit the <code>SetWeights</code> button. 
</li></ul>
<p>The weights are then initialized with the same mean but a variance of .7 using Gaussian (normally) distributed values.  This produces a much higher variance of excitatory net inputs for units in the hidden layer.  There is also an increase in the total overall weight strength with the increase in variance because there is more room for larger weights above the .25 mean, but not much more below it.  
</p>
<ul><li> Press Run to see what difference this makes for the overall excitatory level.
</li></ul>
<p>You should observe a greater level of excitation using the trained weights compared to the initial untrained weights.
</p>
<ul><li> You can verify that the system can compensate for this change by increasing the ff_hidden_g_bar_i to 8.
</li></ul>
<a name=\"Bidirectional_Excitation\" id=\"Bidirectional_Excitation\"></a><h2> <span class=\"mw-headline\"> Bidirectional Excitation </span></h2>
<p>To make things simpler at the outset, we have so far been exploring a relatively easy case for inhibition where the network does not have the bidirectional excitatory connectivity that overwhelmed the constant leak counterweight in section 3.4.3 of the textbook.  Now, let's try running a network with two bidirectionally connected hidden layers (figure 3.22).  
</p>
<ul><li> First, select Defaults to get back the default parameters, do a Run for comparison, and then set network in the control panel to BidirExcite instead of FFExcite.  Then click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.BidirExcite&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.BidirExcite (page does not exist)\">.T3Tab.BidirExcite</a> tab in the right viewer panel to view this network.
</li></ul>
<p>In extending the network to the bidirectional case, we also have to extend our notions of what feedforward inhibition is.  In general, the role of feedforward inhibition is to anticipate and counterbalance the level of excitatory input coming into a layer.  Thus, in a network with bidirectional excitatory connectivity, the inhibitory neurons for a given layer also have to receive the top-down excitatory connections, which play the role of \"feedforward\" inhibition.  
</p>
<ul><li> Verify that this network has both bidirectional excitatory connectivity and the \"feedforward\" inhibition coming back from the second hidden layer by examining the r.wt weights as usual.
</li></ul>
<ul><li> Now Run this network.
</li></ul>
<p>The graph view (figure 3.23) shows the average activity for only the first hidden and inhibitory layers (as before).  Note that the initial part up until the point where the second hidden layer begins to be active is the same as before, but as the second layer activates, it feeds back to the first layer inhibitory neurons, which become more active, as do the excitatory neurons.  However, the overall activity level remains quite under control and not substantially different than before, which is in distinct contrast to the earlier simulations with just a leak current operating.
</p><p>Next, we will see that inhibition is differentially important for bidirectionally connected networks.
</p>
<ul><li> Set the bd_hidden_g_bar.i parameter (note the bd -- in the 2nd group of parameters) to 3, and Run.
</li></ul>
<p>This reduces the amount of inhibition on the excitatory neurons.  Note that this has a relatively small impact on the initial, feedforward portion of the activity curve, but when the second hidden layer becomes active, the network becomes catastrophically over activated -- an epileptic fit!  
</p>
<ul><li> Set the bd_hidden_g_bar.i parameter back to 5.
</li></ul>
<a name=\"Set_Point_Behavior\" id=\"Set_Point_Behavior\"></a><h2> <span class=\"mw-headline\"> Set Point Behavior </span></h2>
<p>Our final exploration of inhibition provides some motivation for the summary inhibition functions presented in the next section.  Here, we explore what happens to the activity levels when different overall levels of excitatory input are presented to the network.  
</p>
<ul><li> First, press Init on the control panel and Run the network for purposes of comparison.}
</li></ul>
<p>The input pattern is set to have the default of 20 (out of 100) units active, which is what we have been using all along.  
</p>
<ul><li> Change the input_pct field in the control panel to 15 instead of 20, Apply, and then hit the SetInputPct button to make a new input pattern with this new percentage activity.  Then do Run.
</li></ul>
<p>This changes the input pattern to have 15 units active.  When you Run now, the activity level is not substantially different from the previous case (a difference of 1--2%).
</p>
<ul><li> Next, set input_pct to 25, Apply, SetInputPct, and Run.
</li></ul>
<p>Again, you should observe only modest increases in activity level.
</p><p>Thus, the network appears to be relatively robust to changes in overall input excitation, though it does show some effect.  Perhaps a more dramatic demonstration comes from the relatively small differences between the initial activity level in the hidden units compared to the subsequent level after the input from the second hidden layer has kicked in.  It is this approximate {\\em set point} behavior, where the system tends to produce a relatively fixed level of activity regardless of the magnitude of the excitatory input, that is captured by the inhibition functions described in the next section.
</p>
<hr>
<p><b>Question 3.12</b> <i>Explain in general terms why the system exhibits this set point behavior.</i>
</p>
<hr>
<ul><li> Last, you can also change the activation function, using the act_fun setting in the control panel.
</li></ul>
<p>You should see that the same basic principles apply when the units use a spiking activation function.
</p>
<a name=\"Exploration_of_kWTA_Inhibition_.28Section_3.5.4.29\" id=\"Exploration_of_kWTA_Inhibition_.28Section_3.5.4.29\"></a><h2> <span class=\"mw-headline\"> Exploration of kWTA Inhibition (Section 3.5.4) </span></h2>
<ul><li> Reset the parameters to their default values using the Defaults button, set the network to BidirExcite, and Run to get the initial state of the network.
</li></ul>
<p>This should reproduce the standard activation graph for the case with actual inhibitory neurons.
</p>
<ul><li> Now, set the <code>bdir_inhib.type</code> to KWTA_INHIB instead of the default UNIT_INHIB to use the basic kWTA function described in the text.  Also, <b>set the bdir_hidden_g_bar.i parameter to 1.0, and the bdir_hidden_dt.vm parameter to to .2</b> (if you don't set g_bar.i to 1.0, no units will get active, because the inhibition will be 5 times as strong as it should be!).  Hit Apply.
</li></ul>
<p>The <i>k</i> value of this function is set according to the <code>bdir kwta.pct value</code> in the control panel (this proportion value of .15 is automatically translated into a corresponding k value, 15 in this case, by the software).  
</p>
<ul><li> Press Run.
</li></ul>
<p>Notice that roughly the same level of activity results (the inhibitory activity is at zero, because these units are not used for this function).  Also, the activity function is somewhat smoother, because the kWTA function effectively does a perfect job of anticipating the appropriate level of inhibition required.  The faster bdir_hidden_dt.vm parameter makes the activation rise very quickly -- more on this below.
</p>
<ul><li> Now select KWTA_AVG_INHIB for the bdir_inhib.type to use the average-based kWTA function, and set the kwta.pt value there to .6 instead of .25  (Apply), and Run again.
</li></ul>
<p>You should observe that the hidden layer activation stabilizes on the target activation level of 15 percent.
</p>
<ul><li> To test the set point behavior of the kWTA functions, run the network with input_pct levels of 10 and 30 (do not forget to hit SetInputPct) in addition to the standard 20 (you can do this for both types of kWTA function).
</li></ul>
<p>Notice that these functions exhibit stronger set point behavior than the inhibitory unit based inhibition (with the average-based kWTA showing just slightly more variability in overall activity level). This is because the kWTA functions are designed explicitly to have a set point, whereas the inhibitory units only roughly produce set-point behavior.  Thus, we must always remember that the kWTA functions are merely an {\\em idealized approximation} of the effects of inhibitory neurons, and do not behave in an identical fashion.
</p><p>Next we will see one of the main advantages of the kWTA functions.
</p>
<ul><li> Set the input_pct back to the default 20 (and SetInputPct).  Set bdir_inhib.type to KWTA_INHIB with kwta_pt set to .25, and try to find the fastest update parameter bdir_hidden_dt.vm (in increments of .1, to a maximum of 1) that does not result in significant oscillatory behavior.
</li></ul>
<hr>
<p><b>Question 3.13 (a)</b> <i>What was the highest value of bdir_hidden_dt.vm that you found?  How does this compare with the value of this parameter for unit-based inhibition (.04)?</i> <b>(b)</b> <i>Why do you think kWTA can use such a fast update rate where unit-based inhibition cannot?</i>
</p>
<hr>
<ul><li> Return the bdir_hidden_dt.vm parameter to .2 before continuing.
</li></ul>
<p>For the <i>k-or-less</i> property of the basic kWTA function to apply, you have to set a leak current value g_bar.l that prevents weak excitation from activating the units, but allows strong excitation to produce activation.
</p>
<ul><li> To see this k-or-less property, increase bdir_hidden_g_bar.l (in .1 increments) to find a value that prevents excitation from an input_pct of 10 or less from activating any of the hidden units, but allows excitation of 20 or more to activate both layers.
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 10/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:67-0!1!0!!en!2!edit=0 and timestamp 20090904004310 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Inhibition\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Inhibition</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Inhibition\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Inhibition&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Inhibition&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Inhibition&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Inhibition\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Inhibition\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Inhibition\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Inhibition&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Inhibition&amp;oldid=424\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Inhibition&amp;oldid=424&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Inhibition&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 22 February 2009, at 19:43.</li>
					<li id=\"viewcount\">This page has been accessed 1,534 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.200 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="control panel for inhibition simulations (feedforward, feedback)";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="network";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0].args[0]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="cycles";
     desc=" integer value (also for enum types)";
     cust_desc=0;
     base=.projects[0].programs.gp[0][2].vars[2]$$;
     mbr=ProgVar::int_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="wt_type";
     desc=" dynamic enum value<br>  enum type:  enum type information (list of enum labels)<br>  value:  current value, which for normal mutually-exclusive options is index into list of enums (-1 = not set), and for bits is the bit values";
     cust_desc=0;
     base=.projects[0].programs[1].vars[0]$$;
     mbr=ProgVar::dyn_enum_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="input_pct";
     desc=" integer value (also for enum types)";
     cust_desc=0;
     base=.projects[0].programs[2].vars[0]$$;
     mbr=ProgVar::int_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Feedforward Network Parameters";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="ff hidden g bar";
      desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
      cust_desc=0;
      base=.projects[0].networks[0].specs[0]$$;
      mbr=LeabraUnitSpec::g_bar;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="ff inhib g bar";
      desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
      cust_desc=0;
      base=.projects[0].networks[0].specs[0].children[0]$$;
      mbr=LeabraUnitSpec::g_bar;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="ff ff wt scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[0].specs[1].children[0]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="ff fb wt scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[0].specs[1].children[1]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="ff hidden dt";
      desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[0]$;
      mbr=LeabraUnitSpec::dt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="ff inhib dt";
      desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[0].children[0]$;
      mbr=LeabraUnitSpec::dt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[6] {
      label="ff inhib";
      desc=" how to compute inhibition -- for kwta modes, a single global inhibition value is computed for the entire layer<br>  type:  how to compute inhibition (g_i)<br>    KWTA INHIB:  between thresholds of k and k+1th most activated units (sets precise k value, should use i_kwta_pt = .25 std)<br>    KWTA AVG INHIB:  average of top k vs avg of rest (provides more flexibility in actual k value, should use i_kwta_pt = .6 std)<br>    KWTA KV2K:  average of top k vs avg of next k (2k) -- avoids long 'tail' of distribution of weakly active units, while providing similar flexibility as KWTA_AVG_INHIB, and also is equivalent to KWTA_INHIB for k=1 -- i_kwta_pt = .25 is std. In general, this is now preferred to KWTA_AVG_INHIB<br>    KWTA COMP COST:  competitor cost kwta function: inhibition is i_kwta_pt below the k'th unit's threshold inhibition value if there are no strong competitors (>comp_thr proportion of kth inhib val), and each competitor increases inhibition linearly (normalized by total possible = n-k) with gain comp_gain -- produces cleaner competitive dynamics and considerable kwta flexibility<br>    AVG MAX PT INHIB:  put inhib value at i_kwta_pt between avg and max values for layer<br>    MAX INHIB:  put inhib value at i_kwta_pt below max guy in layer<br>    UNIT INHIB:  unit-based inhibition (g_i from netinput -- requires connections with inhib flag set to provide inhibition)<br>  kwta pt: [Default: 0.25;0.6;0.2]  [Default: .25 for KWTA_INHIB and KWTA_KV2K, .6 for KWTA_AVG, .2 for AVG_MAX_PT_INHIB] point to place inhibition between k and k+1 (or avg and max for AVG_MAX_PT_INHIB)<br>  min i: [Default: 0]  minimum inhibition value -- set this higher than zero to prevent units from getting active even if there is not much overall excitation<br>  fb act thr: [Default: 0;0.5]  threshold for max activation in layer or group for full kwta inhibition value to be delivered -- below this threshold, the feedback portion of inhibition is proportional to the max act compared to this threshold -- ff_pct of inhibition is always delivered regardless -- allows for an initial wave of activation to get things flowing in the network, followed by inhibitory control<br>  ff pct: [Default: 0.5]  proportion of inhibition that is considered feed forward, and thus not subject to modulation from the fb_act_thr feedback threshold -- this portion of the kwta inhibition is always delivered regardless<br>  fb max dt: [Default: 0.1]  time constant of decay for max activation in the layer or group -- instantly goes to a new max value, but then decays back down with this time constant -- provides needed memory to the fb_act_thr dynamics<br>  comp thr:  [0-1] Threshold for competitors in KWTA_COMP_COST -- competitor threshold inhibition is normalized by k'th inhibition and those above this threshold are counted as competitors <br>  comp gain:  Gain for competitors in KWTA_COMP_COST -- how much to multiply contribution of competitors to increase inhibition level<br>  gp pt: [Default: 0.2]  for unit groups: point to place inhibition between avg and max for AVG_MAX_PT_INHIB";
      cust_desc=0;
      base=.projects[0].networks[0].specs[2]$$;
      mbr=LeabraLayerSpec::inhib;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[7] {
      label="ff kwta";
      desc=" desired activity level over entire layer (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)<br>  k from:  how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q<br>    USE K:  use the k specified directly<br>    USE PCT:  use the percentage pct to compute the k as a function of layer size<br>    USE PAT K:  use the activity level of the current event pattern (k = of units > pat_q)<br>  k:  desired number of active units in the layer<br>  pct:  desired proportion of activity (used to compute a k value based on layer size, .25 std)<br>  pat q: [Default: 0.2;0.5]  threshold for pat_k based activity level: add to k if ext > pat_q<br>  diff act pct: [Default: false]  if true, use different actual percent activity for overall layer activation<br>  act pct:  actual percent activity to put in kwta.pct field of layer<br>  gp i:  compute inhibition including all of the layers in the same group, or unit groups within the layer: each items computed inhib vals are multipled by gp_g scaling, then MAX'd, and each item's inhib is the MAX of this pooled MAX value and its original own value<br>  gp g:  how much this item (layer or unit group) contributes to the pooled layer group values";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[2]$;
      mbr=LeabraLayerSpec::kwta;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[1] {
     name="Bidirectional Network Parameters";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="bdir hidden g bar";
      desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
      cust_desc=0;
      base=.projects[0].networks[1].specs[0]$$;
      mbr=LeabraUnitSpec::g_bar;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="bdir inhib g bar";
      desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
      cust_desc=0;
      base=.projects[0].networks[1].specs[0].children[0]$$;
      mbr=LeabraUnitSpec::g_bar;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="bdir ff wt scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[1].specs[1].children[0]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="bdir fb wt scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[1].specs[1].children[1]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="bdir hidden dt";
      desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
      cust_desc=0;
      base=$.projects[0].networks[1].specs[0]$;
      mbr=LeabraUnitSpec::dt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="bdir inhib dt";
      desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
      cust_desc=0;
      base=$.projects[0].networks[1].specs[0].children[0]$;
      mbr=LeabraUnitSpec::dt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[6] {
      label="bdir act fun";
      desc=" activation function to use<br>  NOISY XX1:  x over x plus 1 convolved with Gaussian noise (noise is nvar)<br>  XX1:  x over x plus 1, hard threshold, no noise convolution<br>  NOISY LINEAR:  simple linear output function (still thesholded) convolved with Gaussian noise (noise is nvar)<br>  LINEAR:  simple linear output function (still thesholded)<br>  SPIKE:  discrete spiking activations (spike when > thr)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[0]$;
      mbr=LeabraUnitSpec::act_fun;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[7] {
      label="bdir inhib";
      desc=" how to compute inhibition -- for kwta modes, a single global inhibition value is computed for the entire layer<br>  type:  how to compute inhibition (g_i)<br>    KWTA INHIB:  between thresholds of k and k+1th most activated units (sets precise k value, should use i_kwta_pt = .25 std)<br>    KWTA AVG INHIB:  average of top k vs avg of rest (provides more flexibility in actual k value, should use i_kwta_pt = .6 std)<br>    KWTA KV2K:  average of top k vs avg of next k (2k) -- avoids long 'tail' of distribution of weakly active units, while providing similar flexibility as KWTA_AVG_INHIB, and also is equivalent to KWTA_INHIB for k=1 -- i_kwta_pt = .25 is std. In general, this is now preferred to KWTA_AVG_INHIB<br>    KWTA COMP COST:  competitor cost kwta function: inhibition is i_kwta_pt below the k'th unit's threshold inhibition value if there are no strong competitors (>comp_thr proportion of kth inhib val), and each competitor increases inhibition linearly (normalized by total possible = n-k) with gain comp_gain -- produces cleaner competitive dynamics and considerable kwta flexibility<br>    AVG MAX PT INHIB:  put inhib value at i_kwta_pt between avg and max values for layer<br>    MAX INHIB:  put inhib value at i_kwta_pt below max guy in layer<br>    UNIT INHIB:  unit-based inhibition (g_i from netinput -- requires connections with inhib flag set to provide inhibition)<br>  kwta pt: [Default: 0.25;0.6;0.2]  [Default: .25 for KWTA_INHIB and KWTA_KV2K, .6 for KWTA_AVG, .2 for AVG_MAX_PT_INHIB] point to place inhibition between k and k+1 (or avg and max for AVG_MAX_PT_INHIB)<br>  min i: [Default: 0]  minimum inhibition value -- set this higher than zero to prevent units from getting active even if there is not much overall excitation<br>  fb act thr: [Default: 0;0.5]  threshold for max activation in layer or group for full kwta inhibition value to be delivered -- below this threshold, the feedback portion of inhibition is proportional to the max act compared to this threshold -- ff_pct of inhibition is always delivered regardless -- allows for an initial wave of activation to get things flowing in the network, followed by inhibitory control<br>  ff pct: [Default: 0.5]  proportion of inhibition that is considered feed forward, and thus not subject to modulation from the fb_act_thr feedback threshold -- this portion of the kwta inhibition is always delivered regardless<br>  fb max dt: [Default: 0.1]  time constant of decay for max activation in the layer or group -- instantly goes to a new max value, but then decays back down with this time constant -- provides needed memory to the fb_act_thr dynamics<br>  comp thr:  [0-1] Threshold for competitors in KWTA_COMP_COST -- competitor threshold inhibition is normalized by k'th inhibition and those above this threshold are counted as competitors <br>  comp gain:  Gain for competitors in KWTA_COMP_COST -- how much to multiply contribution of competitors to increase inhibition level<br>  gp pt: [Default: 0.2]  for unit groups: point to place inhibition between avg and max for AVG_MAX_PT_INHIB";
      cust_desc=0;
      base=.projects[0].networks[1].specs[2]$$;
      mbr=LeabraLayerSpec::inhib;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[8] {
      label="bdir kwta";
      desc=" desired activity level over entire layer (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)<br>  k from:  how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q<br>    USE K:  use the k specified directly<br>    USE PCT:  use the percentage pct to compute the k as a function of layer size<br>    USE PAT K:  use the activity level of the current event pattern (k = of units > pat_q)<br>  k:  desired number of active units in the layer<br>  pct:  desired proportion of activity (used to compute a k value based on layer size, .25 std)<br>  pat q: [Default: 0.2;0.5]  threshold for pat_k based activity level: add to k if ext > pat_q<br>  diff act pct: [Default: false]  if true, use different actual percent activity for overall layer activation<br>  act pct:  actual percent activity to put in kwta.pct field of layer<br>  gp i:  compute inhibition including all of the layers in the same group, or unit groups within the layer: each items computed inhib vals are multipled by gp_g scaling, then MAX'd, and each item's inhib is the MAX of this pooled MAX value and its original own value<br>  gp g:  how much this item (layer or unit group) contributes to the pooled layer group values";
      cust_desc=0;
      base=$.projects[0].networks[1].specs[2]$;
      mbr=LeabraLayerSpec::kwta;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[2] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="FFExcite cycle";
      desc=" cycle counter: number of iterations of activation updating (settling) on the current external input pattern (updated by program)	";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=Network::cycle;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="BidirExcite cycle";
      desc=" cycle counter: number of iterations of activation updating (settling) on the current external input pattern (updated by program)	";
      cust_desc=0;
      base=.projects[0].networks[1]$$;
      mbr=Network::cycle;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Defaults";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[0]$$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[5] {
     label="SetWeights";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[1]$$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[6] {
     label="SetInputPct";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[2]$$;
     mth=Program::Run_Gui;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="InputPattern";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1879699230194092;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [1] "Input0";      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1879699230194092;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 10;10;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [10 10 1] 0;0;0;0;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
1;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;1;0;1;1;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;1;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;1;0;
0;0;0;0;0;1;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="CycleOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cycle";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[1] {
      name="Hidden_acts_avg";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="Inhib_acts_avg";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="SetDefaults";
   short_nm="SDflts";
   tags=;
   desc="restores default initial parameters in the simulation";
   flags=;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="ControlPanel";
     var_type=T_Object;
     object_type=SelectEdit;
     object_val=.projects[0].edits[0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="ffExciteUnits";
     var_type=T_Object;
     object_type=LeabraUnitSpec;
     object_val=$.projects[0].networks[0].specs[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="ffInhibUnits";
     var_type=T_Object;
     object_type=LeabraUnitSpec;
     object_val=$.projects[0].networks[0].specs[0].children[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="ffFFInhib";
     var_type=T_Object;
     object_type=LeabraConSpec;
     object_val=$.projects[0].networks[0].specs[1].children[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="ffFBInhib";
     var_type=T_Object;
     object_type=LeabraConSpec;
     object_val=$.projects[0].networks[0].specs[1].children[1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="ffLayerSpec";
     var_type=T_Object;
     object_type=LeabraLayerSpec;
     object_val=$.projects[0].networks[0].specs[2]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="bdExciteUnits";
     var_type=T_Object;
     object_type=LeabraUnitSpec;
     object_val=$.projects[0].networks[1].specs[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="bdInhibUnits";
     var_type=T_Object;
     object_type=LeabraUnitSpec;
     object_val=$.projects[0].networks[1].specs[0].children[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[8] {
     name="bdFFInhib";
     var_type=T_Object;
     object_type=LeabraConSpec;
     object_val=$.projects[0].networks[1].specs[1].children[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[9] {
     name="bdFBInhib";
     var_type=T_Object;
     object_type=LeabraConSpec;
     object_val=$.projects[0].networks[1].specs[1].children[1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[10] {
     name="bdLayerSpec";
     var_type=T_Object;
     object_type=LeabraLayerSpec;
     object_val=$.projects[0].networks[1].specs[2]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[11] {
     name="FFExcite";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[12] {
     name="BidirExcite";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[13] {
     name="input_pct";
     var_type=T_Int;
     int_val=20;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[14] {
     name="SetInputPct";
     var_type=T_Object;
     object_type=Program;
     object_val=$.projects[0].programs[2]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    Comment @[0] {
     desc="FFExcite Network";
     flags=;
    };
    MemberAssign @[1] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[1]$$;
     path="g_bar.e";
     expr {
      expr="1.0";
     };
     update_after=0;
    };
    MemberAssign @[2] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[1]$;
     path="g_bar.l";
     expr {
      expr="0.01";
     };
     update_after=0;
    };
    MemberAssign @[3] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[1]$;
     path="g_bar.i";
     expr {
      expr="5";
     };
     update_after=1;
    };
    MemberAssign @[4] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[1]$;
     path="dt.vm";
     expr {
      expr=".04";
     };
     update_after=1;
    };
    MemberAssign @[5] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[2]$$;
     path="g_bar.e";
     expr {
      expr="1";
     };
     update_after=0;
    };
    MemberAssign @[6] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[2]$;
     path="g_bar.l";
     expr {
      expr="0.01";
     };
     update_after=0;
    };
    MemberAssign @[7] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[2]$;
     path="g_bar.i";
     expr {
      expr="4";
     };
     update_after=1;
    };
    MemberAssign @[8] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[2]$;
     path="dt.vm";
     expr {
      expr=".15";
     };
     update_after=1;
    };
    MemberAssign @[9] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[3]$$;
     path="wt_scale.rel";
     expr {
      expr="0.35";
     };
     update_after=0;
    };
    MemberAssign @[10] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[3]$;
     path="wt_scale.abs";
     expr {
      expr="1";
     };
     update_after=1;
    };
    MemberAssign @[11] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[4]$$;
     path="wt_scale.rel";
     expr {
      expr="1";
     };
     update_after=0;
    };
    MemberAssign @[12] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[4]$;
     path="wt_scale.abs";
     expr {
      expr="1";
     };
     update_after=1;
    };
    MemberAssign @[13] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[5]$$;
     path="inhib.type";
     expr {
      expr="\"UNIT_INHIB\"";
     };
     update_after=0;
    };
    MemberAssign @[14] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[5]$;
     path="inhib.kwta_pt";
     expr {
      expr="0.25";
     };
     update_after=0;
    };
    MemberAssign @[15] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[5]$;
     path="kwta.pct";
     expr {
      expr="0.15";
     };
     update_after=1;
    };
    Comment @[16] {
     desc="BDir Excite Network";
     flags=;
    };
    MemberAssign @[17] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[6]$$;
     path="g_bar.e";
     expr {
      expr="1.0";
     };
     update_after=0;
    };
    MemberAssign @[18] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[6]$;
     path="g_bar.l";
     expr {
      expr="0.01";
     };
     update_after=0;
    };
    MemberAssign @[19] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[6]$;
     path="g_bar.i";
     expr {
      expr="5";
     };
     update_after=1;
    };
    MemberAssign @[20] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[6]$;
     path="dt.vm";
     expr {
      expr=".04";
     };
     update_after=1;
    };
    MemberAssign @[21] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[7]$$;
     path="g_bar.e";
     expr {
      expr="1";
     };
     update_after=0;
    };
    MemberAssign @[22] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[7]$;
     path="g_bar.l";
     expr {
      expr="0.01";
     };
     update_after=0;
    };
    MemberAssign @[23] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[7]$;
     path="g_bar.i";
     expr {
      expr="4";
     };
     update_after=1;
    };
    MemberAssign @[24] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[7]$;
     path="dt.vm";
     expr {
      expr=".15";
     };
     update_after=1;
    };
    MemberAssign @[25] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[8]$$;
     path="wt_scale.rel";
     expr {
      expr="0.35";
     };
     update_after=0;
    };
    MemberAssign @[26] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[8]$;
     path="wt_scale.abs";
     expr {
      expr="1";
     };
     update_after=1;
    };
    MemberAssign @[27] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[9]$$;
     path="wt_scale.rel";
     expr {
      expr="1";
     };
     update_after=0;
    };
    MemberAssign @[28] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="wt_scale.abs";
     expr {
      expr="1";
     };
     update_after=1;
    };
    MemberAssign @[29] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[10]$$;
     path="inhib.type";
     expr {
      expr="\"UNIT_INHIB\"";
     };
     update_after=0;
    };
    MemberAssign @[30] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[10]$;
     path="inhib.kwta_pt";
     expr {
      expr="0.25";
     };
     update_after=0;
    };
    MemberAssign @[31] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[10]$;
     path="kwta.pct";
     expr {
      expr="0.15";
     };
     update_after=1;
    };
    Comment @[32] {
     desc="weights";
     flags=;
    };
    MemberAssign @[33] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[11]$$;
     path="specs.ExciteCons.rnd.var";
     expr {
      expr=".2";
     };
     update_after=0;
    };
    MemberAssign @[34] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[11]$;
     path="specs.ExciteCons.rnd.type";
     expr {
      expr="Random::UNIFORM";
     };
     update_after=0;
    };
    MemberAssign @[35] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[12]$$;
     path="specs.ExciteCons.rnd.var";
     expr {
      expr=".2";
     };
     update_after=0;
    };
    MemberAssign @[36] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[12]$;
     path="specs.ExciteCons.rnd.type";
     expr {
      expr="Random::UNIFORM";
     };
     update_after=0;
    };
    MethodCall @[37] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[11]$;
     method=Network::Init_Weights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    MethodCall @[38] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[12]$;
     method=Network::Init_Weights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    Comment @[39] {
     desc="input pct";
     flags=;
    };
    OtherProgramVar @[40] {
     desc=;
     flags=;
     other_prog=$.projects[0].programs[2]$;
     set_other=1;
     var_1=.projects[0].programs[0].vars[13]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    MethodCall @[41] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[14]$$;
     method=Program::Init;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    MethodCall @[42] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[0]$$;
     method=SelectEdit::UpdateAfterEdit;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="SetWeights";
   short_nm="SWghts";
   tags=;
   desc="set weights to be either trained or untrained";
   flags=;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=DynEnumType;
    el_def=0;
    DynEnumType @[0] {
     name="WtType";
     desc=;
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="UNTRAINED";
       value=0;
       desc="weights have uniform random variance of .2";
      };
      DynEnumItem @[1] {
       name="TRAINED";
       value=1;
       desc="weights have gaussian variance of .7";
      };
     };
     bits=0;
    };
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="wt_type";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[0].programs[1].types[0]$$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="FFExcite";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="BidirExcite";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    IfElse @[0] {
     desc=;
     flags=;
     cond {
      expr="wt_type == UNTRAINED";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      MemberAssign @[0] {
       desc=;
       flags=;
       obj=.projects[0].programs[1].vars[1]$$;
       path="specs.ExciteCons.rnd.var";
       expr {
	expr=".2";
       };
       update_after=0;
      };
      MemberAssign @[1] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[1]$;
       path="specs.ExciteCons.rnd.type";
       expr {
	expr="Random::UNIFORM";
       };
       update_after=0;
      };
      MemberAssign @[2] {
       desc=;
       flags=;
       obj=.projects[0].programs[1].vars[2]$$;
       path="specs.ExciteCons.rnd.var";
       expr {
	expr=".2";
       };
       update_after=0;
      };
      MemberAssign @[3] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[2]$;
       path="specs.ExciteCons.rnd.type";
       expr {
	expr="Random::UNIFORM";
       };
       update_after=0;
      };
     };
     false_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      MemberAssign @[0] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[1]$;
       path="specs.ExciteCons.rnd.var";
       expr {
	expr=".7";
       };
       update_after=0;
      };
      MemberAssign @[1] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[1]$;
       path="specs.ExciteCons.rnd.type";
       expr {
	expr="Random::GAUSSIAN";
       };
       update_after=0;
      };
      MemberAssign @[2] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[2]$;
       path="specs.ExciteCons.rnd.var";
       expr {
	expr=".7";
       };
       update_after=0;
      };
      MemberAssign @[3] {
       desc=;
       flags=;
       obj=$.projects[0].programs[1].vars[2]$;
       path="specs.ExciteCons.rnd.type";
       expr {
	expr="Random::GAUSSIAN";
       };
       update_after=0;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[1].vars[1]$;
     method=Network::Init_Weights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    MethodCall @[2] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[1].vars[2]$;
     method=Network::Init_Weights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[2] {
   name="SetInputPct";
   short_nm="AplyIn";
   tags=;
   desc="change input pattern to given input pct";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_pct";
     var_type=T_Int;
     int_val=20;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    DataGenCall @[0] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::PermutedBinary;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="data";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_nm";
       required=1;
       def_val=;
       expr {
	expr="\"Input\"";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="n_on";
       required=1;
       def_val=;
       expr {
	expr="input_pct";
       };
      };
      ProgArg @[3] {
       arg_type=float;
       type="float";
       name="on_val";
       required=0;
       def_val="1.0f";
       expr {
	expr="1.0";
       };
      };
      ProgArg @[4] {
       arg_type=float;
       type="float";
       name="off_val";
       required=0;
       def_val="0.0f";
       expr {
	expr="0.0";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][0].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=Network::Init_Acts;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=taBase::UpdateAllViews;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][0].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][0].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[4] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][0].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[0].programs.gp[0][0].args[1]$$;
      index_var=.projects[0].programs.gp[0][0].vars[4]$$;
      order_var=.projects[0].programs.gp[0][0].vars[0]$$;
      order=PERMUTED;
      item_idx_list{ 0;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[8] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*LeabraCycleMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][1].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][1].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][1].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][5]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[5] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      update_var=.projects[0].programs.gp[0][1].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="max_cycles";
      var_type=T_Int;
      int_val=100;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="number of cycles to settle for, regardless";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
      counter=Network::cycle;
      update_after=1;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][4]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][2].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][2].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][2].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
	counter=Network::cycle;
	update_after=1;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < max_cycles";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      update_var=.projects[0].programs.gp[0][2].vars[3]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][3].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[0]$$;
     };
     ProgramCall @[2] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.projects[0].programs.gp[0][6]$;
      targ_ld_init="*LeabraCycleMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][4].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][4].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][5].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="LeabraCycleMonitor";
    short_nm="CycMnt";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="cycle_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="cycle";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cycle";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="Hidden_acts_avg";
	computed=0;
	object_type=LeabraLayer;
	object=.projects[0].networks[0].layers[1]$$;
	variable="acts.avg";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="Inhib_acts_avg";
	computed=0;
	object_type=LeabraLayer;
	object=.projects[0].networks[0].layers[2]$$;
	variable="acts.avg";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][1]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="cycle_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[2]$$;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=0.9901719689369202;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAtwAAAqsAAALeAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="FFExcite";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=0;
	  net_text_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=-0.5: z=0: }: };
	  net_text_rot=0;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[2].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=13: y=10: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;Hidden=0;Inhib=0;	  };
	 };
	 GraphTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[1][1]$;
FloatTransform @*(.m_transform) {scale={x=0.4076537: y=0.4076537: z=0.4076537: }: rotate={x=1.000067: y=0: z=0: rot=0.02233331: }: translate={x=0.06998041: y=1.124568: z=-0.002536524: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="cycle";
	    m_data=.projects[0].data.gp[1][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=100: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="Hidden_acts_avg";
	    m_data=.projects[0].data.gp[1][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="Inhib_acts_avg";
	    m_data=.projects[0].data.gp[1][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.19736: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=0.4076537: y=0.4076537: z=0.4076537: }: rotate={x=1.000067: y=0: z=0: rot=0.02233331: }: translate={x=0.06998041: y=1.124568: z=-0.002536524: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=2;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="cycle";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=100: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=100: };
	   range {min=0: max=100: };
	   n_ticks=10;
	   axis_length=2;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Hidden_acts_avg";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Inhib_acts_avg";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.4494631: y=0.7452691: z=1.868982: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.86918;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.497463: y=0.7550231: z=1.606663: };
	 orient {x=-0.9999986: y=0: z=0: rot=0.1200001: };
	 focal_dist=1.6185;
	};
	T3SavedView @[2] {
	 name="Graph";
	 view_saved=1;
	 pos {x=0.4494631: y=1.181835: z=1.173361: };
	 orient {x=1.000076: y=0: z=0: rot=0.05399592: };
	 focal_dist=1.175272;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="BidirExcite";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[1]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=0;
	  net_text_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=-0.5: z=0: }: };
	  net_text_rot=0;
	  cur_unit_vals{ 	  };
	  unit_src_path=;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=13: y=10: z=2.333333: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="gc.i";
	    auto_scale=1;
	    min=-4.225199;
	    max=4.225199;
	   };
	   ScaleRange @[3] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;Hidden=0;Inhib=0;Hidden2=0;Inhib2=0;	  };
	 };
	 GraphTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[1][1]$;
FloatTransform @*(.m_transform) {scale={x=0.4878761: y=0.4878761: z=0.4878761: }: rotate={x=0: y=-1.023158: z=0: rot=6.281002: }: translate={x=0.007189173: y=1.164547: z=0.0004577675: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="cycle";
	    m_data=$.projects[0].data.gp[1][1].data[0]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=100: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="Hidden_acts_avg";
	    m_data=$.projects[0].data.gp[1][1].data[1]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="Inhib_acts_avg";
	    m_data=$.projects[0].data.gp[1][1].data[2]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=0.4878761: y=0.4878761: z=0.4878761: }: rotate={x=0: y=-1.023158: z=0: rot=6.281002: }: translate={x=0.007189173: y=1.164547: z=0.0004577675: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=2;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="cycle";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=100: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=100: };
	   range {min=0: max=100: };
	   n_ticks=10;
	   axis_length=2;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Hidden_acts_avg";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Inhib_acts_avg";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.4617444: y=0.7870734: z=2.039875: };
	 orient {x=1.001642: y=0: z=0: rot=0.01198033: };
	 focal_dist=2.045832;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.5057445: y=0.6395233: z=1.669055: };
	 orient {x=1.001642: y=0: z=0: rot=0.01198033: };
	 focal_dist=1.674986;
	};
	T3SavedView @[2] {
	 name="Graph";
	 view_saved=1;
	 pos {x=0.4617444: y=0.9593826: z=1.393573: };
	 orient {x=0.9999982: y=0: z=0: rot=0.1879807: };
	 focal_dist=1.424477;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="InputPattern";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=10;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=1: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05958230793476105;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7285992503166199;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=1;
     val_type_fixed=1;
    };
   };
   name="FFExcite";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="ExciteUnits";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
      LeabraUnitSpec @[0] {
       name="InhibUnits";
       desc=;
       unique{ dt;g_bar;       };
       children {
	name=;
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       act_range {min=0: max=1: range=1: scale=1: };
       bias_con_type=LeabraCon;
       bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[5]$$: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
       spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
       spike_misc {
	exp_slope=0.02;
	spk_thr=1.2;
	clamp_max_p=0.11;
	clamp_type=REGULAR;
	vm_r=0.3;
	vm_dend=0.3;
	vm_dend_dt=0.16;
	vm_dend_time=6.25;
       };
       opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
       maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=1: range=1: scale=1: };
       v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
       dt {integ=1: vm=0.15: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=6.666667: net_time=1.428571: };
       act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
       g_bar {e=1: l=0.01: i=4: h=0.1: a=0.5: };
       e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
       hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       adapt {
	on=0;
	dt=0.007;
	vm_gain=0.04;
	spike_gain=0.00805;
	interval=10;
	dt_time=142.8571;
       };
       depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
       syn_delay {
	on=0;
	delay=4;
       };
       da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
       noise_type=VM_NOISE;
       noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
       noise_adapt {trial_fixed=0: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
       noise_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=1;
	cur_val=0;
       };
      };
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[5]$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.04: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=25: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.01: i=5: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=VM_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
     noise_adapt {trial_fixed=0: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="ExciteCons";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @[0] {
       name="FFInhib";
       desc=;
       unique{ rnd;wt_limits;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=GAUSSIAN: mean=0.25: var=0.2: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.35: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[1] {
       name="FBInhib";
       desc=;
       unique{ rnd;wt_limits;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.25: var=0.2: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.25: var=0.2: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LayerSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=UNIT_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_PCT: k=12: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=1;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraConSpec @[4] {
     name="InhibConSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @[0] {
       name="InhibInhibCon";
       desc=;
       unique{ rnd;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=1;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=1;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraBiasSpec @[5] {
     name="BiasSpec";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=13: y=10: z=2: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=10: y=10: n_not_xy=0: n=100: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=10: y=10: n_not_xy=0: n=100: };
     scaled_act_geom {x=10: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=10: y=10: n_not_xy=0: n=100: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.19: max=0.95: max_i=6: };
     acts_m {cmpt=1: avg=0.19: max=0.95: max_i=6: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=15: pct=0.15: pct_c=0.85: adth_k=7: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=5: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=2.634441e-43;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Hidden";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     disp_scale=1;
     un_geom {x=10: y=10: n_not_xy=0: n=100: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=10: y=10: n_not_xy=0: n=100: };
     scaled_act_geom {x=10: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1]$$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Inhib";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[4]$$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=10: y=10: n_not_xy=0: n=100: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.09780054: max=0.7947025: max_i=98: };
     acts_m {cmpt=1: avg=0.09780054: max=0.7947025: max_i=98: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=15: pct=0.15: pct_c=0.85: adth_k=7: k_ithr=1.31274: k1_ithr=1.30626: ithr_r=0.00494745: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=5: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=0.9971429;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Inhib";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=11: y=0: z=1: };
     disp_scale=1;
     un_geom {x=2: y=10: n_not_xy=0: n=20: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=10: n_not_xy=0: n=20: };
     scaled_act_geom {x=2: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[1]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[0]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Inhib";
       from_type=SELF;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[4].children[0]$$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=10: n_not_xy=0: n=20: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0].children[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.1584185: max=0.7863103: max_i=17: };
     acts_m {cmpt=1: avg=0.1584185: max=0.7863103: max_i=17: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=3: pct=0.15: pct_c=0.85: adth_k=1: k_ithr=0.897893: k1_ithr=0.888439: ithr_r=0.0105847: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=4: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=0.14;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name="Input0";
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="": start={usr=12191: sys=1569: tot=4220839137: }: end={usr=12320: sys=1575: tot=4220839271: }: used={usr=129: sys=6: tot=134: }: s_used=1.34: n_used=1: };
   trial_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=0;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=220;
   n_cons=16400;
   max_size {x=13: y=10: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=PLUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=-658710;
   time_inc=1;
   cycle_max=100;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=1;
    m_sum=0;
    m_nrm=1;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0.001;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=100;
   avg_cycles=100;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0.2666667;
   send_pct_n=32;
   send_pct_tot=120;
   avg_send_pct=0.2160832;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=-1;
   maxda=0.008671582;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
  LeabraNetwork @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=1;
     val_type_fixed=1;
    };
   };
   name="BidirExcite";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="ExciteUnits";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
      LeabraUnitSpec @[0] {
       name="InhibUnits";
       desc=;
       unique{ dt;g_bar;       };
       children {
	name=;
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       act_range {min=0: max=1: range=1: scale=1: };
       bias_con_type=LeabraCon;
       bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[5]$: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
       spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
       spike_misc {
	exp_slope=0.02;
	spk_thr=1.2;
	clamp_max_p=0.11;
	clamp_type=REGULAR;
	vm_r=0.3;
	vm_dend=0.3;
	vm_dend_dt=0.16;
	vm_dend_time=6.25;
       };
       opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
       maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=1: range=1: scale=1: };
       v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
       dt {integ=1: vm=0.15: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=6.666667: net_time=1.428571: };
       act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
       g_bar {e=1: l=0.01: i=4: h=0.1: a=0.5: };
       e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
       hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       adapt {
	on=0;
	dt=0.007;
	vm_gain=0.04;
	spike_gain=0.00805;
	interval=10;
	dt_time=142.8571;
       };
       depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
       syn_delay {
	on=0;
	delay=4;
       };
       da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
       noise_type=VM_NOISE;
       noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
       noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
       noise_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=1;
	cur_val=0;
       };
      };
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[5]$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.04: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=25: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.01: i=5: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=VM_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="ExciteCons";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @[0] {
       name="FFInhib";
       desc=;
       unique{ rnd;wt_limits;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=GAUSSIAN: mean=0.25: var=0.2: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.35: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[1] {
       name="FBInhib";
       desc=;
       unique{ rnd;wt_limits;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.25: var=0.2: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.25: var=0.2: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LayerSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=UNIT_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_PCT: k=12: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=1;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraConSpec @[4] {
     name="InhibConSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @[0] {
       name="InhibInhibCon";
       desc=;
       unique{ rnd;wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=1;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=1;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraBiasSpec @[5] {
     name="BiasSpec";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=13: y=10: z=3: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=10: y=10: n_not_xy=0: n=100: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=10: y=10: n_not_xy=0: n=100: };
     scaled_act_geom {x=10: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[1].layers[1].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[1].layers[2].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=10: y=10: n_not_xy=0: n=100: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[1].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=0: max_i=-1: };
     acts {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_p {cmpt=1: avg=0.19: max=0.95: max_i=1: };
     acts_m {cmpt=1: avg=0.19: max=0.95: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=15: pct=0.15: pct_c=0.85: adth_k=7: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=5: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[1].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Hidden";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     disp_scale=1;
     un_geom {x=10: y=10: n_not_xy=0: n=100: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=10: y=10: n_not_xy=0: n=100: };
     scaled_act_geom {x=10: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[1].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[1].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[1].specs[1]$$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Inhib";
       from_type=CUSTOM;
       from=.projects[0].networks[1].layers[2]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[1].specs[4]$$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Hidden2";
       from_type=CUSTOM;
       from=.projects[0].networks[1].layers[3]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1]$: };
       recv_idx=2;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[1].layers[2].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[1].layers[3].projections[0];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[1].layers[4].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=10: y=10: n_not_xy=0: n=100: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[1].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=0: max_i=-1: };
     acts {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_p {cmpt=1: avg=0.1012872: max=0.8862728: max_i=77: };
     acts_m {cmpt=1: avg=0.1012872: max=0.8862728: max_i=77: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=15: pct=0.15: pct_c=0.85: adth_k=7: k_ithr=0.8986388: k1_ithr=0.764641: ithr_r=0.1614747: ithr_diff=0.149112: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=5: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[1].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=1.401298e-45;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Inhib";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=11: y=0: z=1: };
     disp_scale=1;
     un_geom {x=2: y=10: n_not_xy=0: n=20: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=10: n_not_xy=0: n=20: };
     scaled_act_geom {x=2: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=.projects[0].networks[1].layers[1]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=$.projects[0].networks[1].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1].children[0]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Inhib";
       from_type=SELF;
       from=$.projects[0].networks[1].layers[2]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[1].specs[4].children[0]$$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[3] {
       name="Fm_Hidden2";
       from_type=CUSTOM;
       from=$.projects[0].networks[1].layers[3]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1].children[0]$: };
       recv_idx=3;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[1].layers[1].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[1].layers[2].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=10: n_not_xy=0: n=20: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[1].specs[0].children[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=0: max_i=-1: };
     acts {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_p {cmpt=1: avg=0: max=0: max_i=0: };
     acts_m {cmpt=1: avg=0: max=0: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=3: pct=0.15: pct_c=0.85: adth_k=1: k_ithr=0.83342: k1_ithr=0.7065829: ithr_r=0.1650972: ithr_diff=0.1521887: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=4: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[1].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[3] {
     name="Hidden2";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=2: };
     disp_scale=1;
     un_geom {x=10: y=10: n_not_xy=0: n=100: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=10: y=10: n_not_xy=0: n=100: };
     scaled_act_geom {x=10: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=$.projects[0].networks[1].layers[1]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Inhib2";
       from_type=CUSTOM;
       from=.projects[0].networks[1].layers[4]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[4]$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[1].layers[1].projections[2];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[1].layers[2].projections[3];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[1].layers[4].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=10: y=10: n_not_xy=0: n=100: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[1].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=0: max_i=-1: };
     acts {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_p {cmpt=1: avg=0: max=0: max_i=0: };
     acts_m {cmpt=1: avg=0: max=0: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=15: pct=0.15: pct_c=0.85: adth_k=7: k_ithr=0.6452407: k1_ithr=0.5429606: ithr_r=0.1725865: ithr_diff=0.1585145: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=5: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[1].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[4] {
     name="Inhib2";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=11: y=0: z=2: };
     disp_scale=1;
     un_geom {x=2: y=10: n_not_xy=0: n=20: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=10: n_not_xy=0: n=20: };
     scaled_act_geom {x=2: y=10: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden2";
       from_type=CUSTOM;
       from=$.projects[0].networks[1].layers[3]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Inhib2";
       from_type=SELF;
       from=$.projects[0].networks[1].layers[4]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[4].children[0]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=$.projects[0].networks[1].layers[1]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[1].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[1].specs[1].children[0]$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[1].layers[3].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[1].layers[4].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=10: n_not_xy=0: n=20: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[1].specs[0].children[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=0: max_i=-1: };
     acts {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_p {cmpt=1: avg=0: max=0: max_i=0: };
     acts_m {cmpt=1: avg=0: max=0: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=3: pct=0.15: pct_c=0.85: adth_k=1: k_ithr=0.1956788: k1_ithr=0.1591218: ithr_r=0.2068047: ithr_diff=0.1868216: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.15: i_kwta_pt=0.25: g_bar_i=4: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[1].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name="Input0";
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="": start={usr=8112: sys=971: tot=4220779154: }: end={usr=8311: sys=982: tot=4220779363: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=1.112615698742426e-306;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=340;
   n_cons=44800;
   max_size {x=13: y=10: z=3: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=0;
   time_inc=1;
   cycle_max=100;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=1;
    m_sum=0;
    m_nrm=1;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0.001;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=0;
   avg_cycles=0;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=0;
   avg_send_pct=0;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=-1;
   maxda=0;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
