// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [2] {
    taDoc @[0] { };
    taDoc @[1] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [4] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem_Group @.gp[0] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
      };

      EditMthItem_Group @.mths = [5] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [3] { 
      DataTable @[0] { 
	DataTableCols @.data = [2] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [2] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [2] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	};
      };
    };
    DataTable_Group @.gp[1] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [5] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	};
      };
    };
    DataTable_Group @.gp[2] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [3] {
	  float_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
	      UserDataItem @[2] { };
      };
};
	  String_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [2] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [4] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [2] {
	AssignExpr @[0] { };
	IfElse @[1] { 
	  ProgEl_List @.true_code = [1] {
	    ForLoop @[0] { 
	      ProgEl_List @.loop_code = [1] {
		IfElse @[0] { 
		  ProgEl_List @.true_code = [2] {
		    MemberAssign @[0] { };
		    If @[1] { 
		      ProgEl_List @.true_code = [1] {
			MemberAssign @[0] { };
		      };
		    };
		  };

		  ProgEl_List @.false_code = [1] {
		    MemberAssign @[0] { };
		  };
		};
	      };
	    };
	  };

	  ProgEl_List @.false_code = [1] {
	    ForLoop @[0] { 
	      ProgEl_List @.loop_code = [1] {
		MemberAssign @[0] { };
	      };
	    };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [2] {
	DataTable @[0] { 
	  DataTableCols @.data = [5] {
	    int_Data @[0] { 
       UserDataItem_List @*(.user_data_) {
		UserDataItem @[0] { };
       };
};
	    String_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	SimpleMathSpec @[1] { };
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [1] {
	IfElse @[0] { 
	  ProgEl_List @.true_code = [3] {
	    DataProcCall @[0] { 
	      ProgArg_List @.meth_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    DataGenCall @[1] { 
	      ProgArg_List @.meth_args = [3] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
	      };
	    };
	    DataAnalCall @[2] { 
	      ProgArg_List @.meth_args = [8] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
		ProgArg @[3] { };
		ProgArg @[4] { };
		ProgArg @[5] { };
		ProgArg @[6] { };
		ProgArg @[7] { };
	      };
	    };
	  };

	  ProgEl_List @.false_code = [1] {
	    DataAnalCall @[0] { 
	      ProgArg_List @.meth_args = [8] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
		ProgArg @[3] { };
		ProgArg @[4] { };
		ProgArg @[5] { };
		ProgArg @[6] { };
		ProgArg @[7] { };
	      };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [6] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  NetCounterInit @[1] { };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[5] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [6] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[5] { };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [2] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [4] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [3] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [2] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [4] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [5] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [3] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [2] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [2] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		  };
		};
		GridTableView @[2] { 
		  T3DataView_List @.children = [2] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [5] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraBiasSpec @[4] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
      };

      Layer_Group @.layers = [2] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [35] {
	    LeabraUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[2] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[3] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[4] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[5] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[6] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[7] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[8] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[9] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[10] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[11] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[12] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[13] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[14] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[15] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[16] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[17] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[18] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[19] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[20] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[21] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[22] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[23] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[24] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[25] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[26] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[27] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[28] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[29] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[30] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[31] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[32] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[33] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	    LeabraUnit @[34] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [10]		};
	      };
	    };
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [10] {
	    LeabraUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[2] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[3] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[4] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[5] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[6] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[7] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[8] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	    LeabraUnit @[9] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [35]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
= Transformations =

This project explores how the feedforward flow of information through a network can transform information into different forms.  Generally, such transformations involve collapsing across irrelevant distinctions, and emphasizing relevant ones (i.e., forming ''categories'').

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

We use a network that can recognize images of the 10 arabic numerals (0-9), which you can see in the network view panel on the right (labeled with the [[.T3Tab.Digit_Network]] tab).

== The Digits Network ==

Let's first examine the network.  It has a 5x7 <code>Input</code> layer for the digit images, and a 2x5 <code>Hidden</code> layer, with each of the 10 hidden units representing a digit.  

* In the network view select the <code>r.wt</code> variable to view in the network view, and click on each of the different hidden units in the network.  This will display their weight values going into each unit.

You will see that the weights exactly match the images of the digits the units represent, just as our single 8 detector from the previous chapter did.

Although it should be pretty obvious from these weights how each unit will respond to the set of digit input patterns that exactly match the weight patterns, let's explore this nonetheless.  

* Select the <code>act</code> value to view the unit activities in the network, and then select the [[.PanelTab.ControlPanel]] tab and do [[.programs.gp.LeabraAll_Std.LeabraEpoch.Init()|Init]] and then <code>Step Trial</code> to single-step through each of the input patterns.

As before, this presents the first input pattern (0) to the network, and updates the activations in the network over a series of cycles until equilibrium activations have effectively been reached for all
units.  Note that we are using the noisy XX1 rate coded activation function, as with most of our simulations.

* Proceed to <code>Step Trial</code> through the entire sequence of digits.

You should have observed that each unit was activated when its matching digit was presented, and not when any of the other digits were presented.

You have probably noticed that the pattern of hidden unit activations over the different inputs is also displayed in the '''Grid View''' display next to the network in the right-most display panel. This window displays the activity states of the network, plus the raw excitatory netinput to the hidden units, over time as rows of colored squares.  Thus, you can see the whole picture in one glance.

== Bias Weights ==

Before we continue, it is important to understand the role of the ''bias weights'' in this simulation.  Recall that bias weights provide an additional constant source of net input to the units, independent of any other activity in the network, and reflect differences in intrinsic neural excitability, which have been shown to be adaptively updatable.  The digit images used as input patterns have somewhat different numbers of active units (as you might have observed in the detector exercise in the previous chapter).  Thus, the bias weights help compensate for these differences.

* Press the [[.T3Tab.Digits]] view tab (above right panel) to see images of all the digit input patterns.  These are displayed using the same Grid View display as the network patterns.  Note that there is a (thin!) purple scroll bar on the right of each of these grid view displays, which you can use (with the red arrow tool clicked) to scroll through the full set of items for the Noisy Digits and Letters, which exceed the 10 rows visible at a time.

You might have expected these differences in the number of active input units in the Digits images to result in different net input and activation levels for the corresponding hidden units.  Instead, all the activations shown in the Grid View appear roughly similar.  The discrepancy here is attributable to the use of bias weights, which compensate for these differences in overall activity level coming from the inputs.  

* Go back to the [[.T3Tab.Digit_Network]] view, and select <code>bias.wt</code> in the NetView window.

You should see a pattern of different valued bias weights on the hidden units.  Let's evaluate the contributions of these bias weights by running the network without them.

* In the [[.PanelTab.ControlPanel]], click the <code>biases_on</code> check box to ''off' (not checked), and then do [[.programs.gp.LeabraAll_Std.LeabraEpoch.Run()|Run]] (or single-step) to see how the network runs without these bias weights on.

This will run through all of the digits, and you can view the Grid View to see the resulting activities and net inputs.

<hr>

'''Question 3.1:''' ''How did the lack of bias weights affect the hidden unit activities, and their relation to the number of active units in the input patterns?''

<hr>

* Turn the bias weights back on and select <code>bias.wt</code> to view in the Network window if it isn't already selected.

<hr>

'''Question 3.2:''' ''Explain in specific terms how these bias weights contribute to producing the originally observed hidden unit activities.  Make reference to specific input digit images, unit weights, and the network net input values with the biases on and off.''

<hr>

== Cluster Plots ==

Next we will produce some cluster plots like those shown in the text.

*  [[.programs.gp.LeabraAll_Std.LeabraEpoch.Run()|Run]] the network with the biases on again.  Then select Digits for the <code>cluster data src</code> field in the [[.PanelTab.ControlPanel]] and then do [[.programs.ClusterPlot.Run()|Cluster Run]] to generate a cluster plot.

You should get a window containing the cluster plot for the similarity relationships among the digit images.  
Compare the amount of overlap between activated pixels in the digit images with the cluster plot results.

Next let's look at the similarity relationships among the hidden unit representations of the digits.

* Select <code>TrialOutputData</code> for the cluster data src this time (hit Apply), and then do [[.programs.ClusterPlot.Run()|Cluster Run]] again.

You should get a cluster plot that looks much like that shown in Figure 3.8b in the textbook, except there is just one label for each digit category.  This shows that the network has transformed the complex patterns of input similarity into equally distinct hidden representations of the digit categories.

Note that we have ''binarized'' the hidden unit activation values (i.e., changed values greater than .5 to 1, and those less than .5 to 0) for the purposes of clustering.  Otherwise, small differences in the activation values of the units would distract from the main structure of the cluster plot (which is actually the same regardless of whether the activations are binarized or not).  For the present purposes, we are more interested in whether a detector has fired or not, and not in the specific activation value of that detector, though in general the graded values can play a useful role in representations, as we will discuss later.

The next step is to run the case where there are multiple instances of each digit (the <code>NOISY_DIGITS</code> case).  

* In the [[.PanelTab.ControlPanel]], set the <code>input data</code> to <code>NOISY_DIGITS</code>, Apply, and <code>Step Trial</code> through these new patterns.  You can also click on the [[.T3Tab.Digits]] tab and scroll through the noisy digits inputs there to see what they look like.
  
You should see that the appropriate hidden unit is active for each version of the digits (although small levels of activity in other units should also be observed in some cases).

* Now do [[.programs.ClusterPlot.Run()|Cluster Run]] again (make sure that cluster data src is still set to <code>TrialOutputData</code>, so it will process the hidden layer activations).

You should see the same plot as shown in Figure 3.8b in the textbook.  You can compare this with the cluster plot you get when you change cluster data src to <code>NoisyDigits</code> and run the cluster plot (same as Figure 3.8a).  This clearly shows that the network has collapsed across distinctions between different noisy versions of the same digits, while emphasizing the distinctions between different digit categories.

== Selectivity and Leak ==

In the detector exploration from the previous chapter, we saw that manipulating the amount of leak conductance altered the selectivity of the unit's response.  By lowering the leak, the unit responded in a graded fashion to the similarity of the different digit images to the detector's weight pattern.  Let's see what kinds of effects this parameter has on the behavior of the present network.  The control panel shows that the leak conductance (<code>g_bar.l</code> in the [[.PanelTab.ControlPanel]]) for the hidden units has been set to a value of 6.

* Reduce the <code>g_bar.l</code> for the hidden units from 6 to 5 and [[.programs.gp.LeabraAll_Std.LeabraEpoch.Run()|Run]] (still using input data of <code>Noisy Digits</code>).

<hr>

'''Question 3.3'''  '''(a)''' ''What happens generally to the hidden activations with this reduction in leak value?'' '''(b)''' ''How does this affect the cluster plot of hidden unit activities?'' '''(c)''' ''How about for a g_bar.l of 4?'' '''(d)''' ''If the goal of this network was to have the same hidden representation for each version of the same digit, and different representations for different digits, how does changing the units' excitability (via the leak current) affect the success of the network, and why?''

<hr>

== Letter Inputs ==

Now, we will see how the network responds to letter inputs instead of digits.  

* First, set the <code>g_bar.l</code> leak conductance back to 6 and make sure <code>act</code> is selected in the Net View window.  Then set <code>input data</code> to <code>Letters</code> (Apply)
and press [[.programs.gp.LeabraAll_Std.LeabraEpoch.Run()|Run]].

Notice the letters being presented over the input layer on the network.  

* Use the scrollbar on the right of the Grid Log view next to the network to scroll the display back to the start of the letter presentations, because these have scrolled off the ``top'' of the display.

The only significant response came to the \"S\" letter input from the \"8\"  hidden unit -- note that \"S\" is very similar to the \"8\".

* Make a cluster plot of the letter input patterns by selecting cluster data src as Letters and doing [[.programs.ClusterPlot.Run()|Cluster Run]].  This should look like Figure 3.10a in the textbook.  Then, make a cluster plot of the hidden unit activations (cluster data src to TrialOutputData and Cluster Run again).  This should look like Figure 3.10b.

You should be able to see in these cluster plots that these digit units do not respond very informatively
to the letter stimuli.

<hr>

'''Question 3.4 (a)''' ''Based on your experiences in the previous question, what would you expect to happen to the cluster plot of hidden responses to letter inputs as you lowered the g_bar.l leak current to a value of 4?  Do this -- were you right?'' '''(b)''' ''Would you say that this hidden representation is a good one for conveying letter identity information?  Why or why not? (Hint: Pay particular attention to whether any letters are collapsed in the cluster plot -- i.e., having no distance at all between them.)'' '''(c)''' ''Can you find any setting of g_bar.l that gives you a satisfactory hidden representation of letter information?  Explain.''

<hr>

</body>
</html>
";
   html_text="<html><head></head><body>
<h1> Transformations </h1>
<p>
This project explores how the feedforward flow of information through a network can transform information into different forms.  Generally, such transformations involve collapsing across irrelevant distinctions, and emphasizing relevant ones (i.e., forming  <i>categories</i> ).
</p><p>
</p><ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
We use a network that can recognize images of the 10 arabic numerals (0-9), which you can see in the network view panel on the right (labeled with the <a href=\"ta:.T3Tab.Digit_Network\">Digit_Network</a> tab).
<p>
</p><h2> The Digits Network </h2>
<p>
Let's first examine the network.  It has a 5x7 <code>Input</code> layer for the digit images, and a 2x5 <code>Hidden</code> layer, with each of the 10 hidden units representing a digit.  
</p><p>
</p><ul><li> In the network view select the <code>r.wt</code> variable to view in the network view, and click on each of the different hidden units in the network.  This will display their weight values going into each unit.
</li></ul>
You will see that the weights exactly match the images of the digits the units represent, just as our single 8 detector from the previous chapter did.
<p>
Although it should be pretty obvious from these weights how each unit will respond to the set of digit input patterns that exactly match the weight patterns, let's explore this nonetheless.  
</p><p>
</p><ul><li> Select the <code>act</code> value to view the unit activities in the network, and then select the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> tab and do <a href=\"ta:.programs.gp.LeabraAll_Std.LeabraEpoch.Init()\">Init</a> and then <code>Step Trial</code> to single-step through each of the input patterns.
</li></ul>
As before, this presents the first input pattern (0) to the network, and updates the activations in the network over a series of cycles until equilibrium activations have effectively been reached for all
units.  Note that we are using the noisy XX1 rate coded activation function, as with most of our simulations.
<p>
</p><ul><li> Proceed to <code>Step Trial</code> through the entire sequence of digits.
</li></ul>
You should have observed that each unit was activated when its matching digit was presented, and not when any of the other digits were presented.
<p>
You have probably noticed that the pattern of hidden unit activations over the different inputs is also displayed in the  <b>Grid View</b>  display next to the network in the right-most display panel. This window displays the activity states of the network, plus the raw excitatory netinput to the hidden units, over time as rows of colored squares.  Thus, you can see the whole picture in one glance.
</p><p>
</p><h2> Bias Weights </h2>
<p>
Before we continue, it is important to understand the role of the  <i>bias weights</i>  in this simulation.  Recall that bias weights provide an additional constant source of net input to the units, independent of any other activity in the network, and reflect differences in intrinsic neural excitability, which have been shown to be adaptively updatable.  The digit images used as input patterns have somewhat different numbers of active units (as you might have observed in the detector exercise in the previous chapter).  Thus, the bias weights help compensate for these differences.
</p><p>
</p><ul><li> Press the <a href=\"ta:.T3Tab.Digits\">Digits</a> view tab (above right panel) to see images of all the digit input patterns.  These are displayed using the same Grid View display as the network patterns.  Note that there is a (thin!) purple scroll bar on the right of each of these grid view displays, which you can use (with the red arrow tool clicked) to scroll through the full set of items for the Noisy Digits and Letters, which exceed the 10 rows visible at a time.
</li></ul>
You might have expected these differences in the number of active input units in the Digits images to result in different net input and activation levels for the corresponding hidden units.  Instead, all the activations shown in the Grid View appear roughly similar.  The discrepancy here is attributable to the use of bias weights, which compensate for these differences in overall activity level coming from the inputs.  
<p>
</p><ul><li> Go back to the <a href=\"ta:.T3Tab.Digit_Network\">Digit_Network</a> view, and select <code>bias.wt</code> in the NetView window.
</li></ul>
You should see a pattern of different valued bias weights on the hidden units.  Let's evaluate the contributions of these bias weights by running the network without them.
<p>
</p><ul><li> In the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>, click the <code>biases_on</code> check box to ''off' (not checked), and then do <a href=\"ta:.programs.gp.LeabraAll_Std.LeabraEpoch.Run()\">Run</a> (or single-step) to see how the network runs without these bias weights on.
</li></ul>
This will run through all of the digits, and you can view the Grid View to see the resulting activities and net inputs.
<p>
</p><hr>
<p>
 <b>Question 3.1:</b>   <i>How did the lack of bias weights affect the hidden unit activities, and their relation to the number of active units in the input patterns?</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Turn the bias weights back on and select <code>bias.wt</code> to view in the Network window if it isn't already selected.
</li></ul>
<hr>
<p>
 <b>Question 3.2:</b>   <i>Explain in specific terms how these bias weights contribute to producing the originally observed hidden unit activities.  Make reference to specific input digit images, unit weights, and the network net input values with the biases on and off.</i> 
</p><p>
</p><hr>
<p>
</p><h2> Cluster Plots </h2>
<p>
Next we will produce some cluster plots like those shown in the text.
</p><p>
</p><ul><li>  <a href=\"ta:.programs.gp.LeabraAll_Std.LeabraEpoch.Run()\">Run</a> the network with the biases on again.  Then select Digits for the <code>cluster data src</code> field in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> and then do <a href=\"ta:.programs.ClusterPlot.Run()\">Cluster Run</a> to generate a cluster plot.
</li></ul>
You should get a window containing the cluster plot for the similarity relationships among the digit images.  
Compare the amount of overlap between activated pixels in the digit images with the cluster plot results.
<p>
Next let's look at the similarity relationships among the hidden unit representations of the digits.
</p><p>
</p><ul><li> Select <code>TrialOutputData</code> for the cluster data src this time (hit Apply), and then do <a href=\"ta:.programs.ClusterPlot.Run()\">Cluster Run</a> again.
</li></ul>
You should get a cluster plot that looks much like that shown in Figure 3.8b in the textbook, except there is just one label for each digit category.  This shows that the network has transformed the complex patterns of input similarity into equally distinct hidden representations of the digit categories.
<p>
Note that we have  <i>binarized</i>  the hidden unit activation values (i.e., changed values greater than .5 to 1, and those less than .5 to 0) for the purposes of clustering.  Otherwise, small differences in the activation values of the units would distract from the main structure of the cluster plot (which is actually the same regardless of whether the activations are binarized or not).  For the present purposes, we are more interested in whether a detector has fired or not, and not in the specific activation value of that detector, though in general the graded values can play a useful role in representations, as we will discuss later.
</p><p>
The next step is to run the case where there are multiple instances of each digit (the <code>NOISY_DIGITS</code> case).  
</p><p>
</p><ul><li> In the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>, set the <code>input data</code> to <code>NOISY_DIGITS</code>, Apply, and <code>Step Trial</code> through these new patterns.  You can also click on the <a href=\"ta:.T3Tab.Digits\">Digits</a> tab and scroll through the noisy digits inputs there to see what they look like.
  </li></ul>
You should see that the appropriate hidden unit is active for each version of the digits (although small levels of activity in other units should also be observed in some cases).
<p>
</p><ul><li> Now do <a href=\"ta:.programs.ClusterPlot.Run()\">Cluster Run</a> again (make sure that cluster data src is still set to <code>TrialOutputData</code>, so it will process the hidden layer activations).
</li></ul>
You should see the same plot as shown in Figure 3.8b in the textbook.  You can compare this with the cluster plot you get when you change cluster data src to <code>NoisyDigits</code> and run the cluster plot (same as Figure 3.8a).  This clearly shows that the network has collapsed across distinctions between different noisy versions of the same digits, while emphasizing the distinctions between different digit categories.
<p>
</p><h2> Selectivity and Leak </h2>
<p>
In the detector exploration from the previous chapter, we saw that manipulating the amount of leak conductance altered the selectivity of the unit's response.  By lowering the leak, the unit responded in a graded fashion to the similarity of the different digit images to the detector's weight pattern.  Let's see what kinds of effects this parameter has on the behavior of the present network.  The control panel shows that the leak conductance (<code>g_bar.l</code> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>) for the hidden units has been set to a value of 6.
</p><p>
</p><ul><li> Reduce the <code>g_bar.l</code> for the hidden units from 6 to 5 and <a href=\"ta:.programs.gp.LeabraAll_Std.LeabraEpoch.Run()\">Run</a> (still using input data of <code>Noisy Digits</code>).
</li></ul>
<hr>
<p>
 <b>Question 3.3</b>    <b>(a)</b>   <i>What happens generally to the hidden activations with this reduction in leak value?</i>   <b>(b)</b>   <i>How does this affect the cluster plot of hidden unit activities?</i>   <b>(c)</b>   <i>How about for a g_bar.l of 4?</i>   <b>(d)</b>   <i>If the goal of this network was to have the same hidden representation for each version of the same digit, and different representations for different digits, how does changing the units' excitability (via the leak current) affect the success of the network, and why?</i> 
</p><p>
</p><hr>
<p>
</p><h2> Letter Inputs </h2>
<p>
Now, we will see how the network responds to letter inputs instead of digits.  
</p><p>
</p><ul><li> First, set the <code>g_bar.l</code> leak conductance back to 6 and make sure <code>act</code> is selected in the Net View window.  Then set <code>input data</code> to <code>Letters</code> (Apply)
and press <a href=\"ta:.programs.gp.LeabraAll_Std.LeabraEpoch.Run()\">Run</a>.</li></ul>
<p>
Notice the letters being presented over the input layer on the network.  
</p><p>
</p><ul><li> Use the scrollbar on the right of the Grid Log view next to the network to scroll the display back to the start of the letter presentations, because these have scrolled off the ``top'' of the display.
</li></ul>
The only significant response came to the \"S\" letter input from the \"8\"  hidden unit -- note that \"S\" is very similar to the \"8\".
<p>
</p><ul><li> Make a cluster plot of the letter input patterns by selecting cluster data src as Letters and doing <a href=\"ta:.programs.ClusterPlot.Run()\">Cluster Run</a>.  This should look like Figure 3.10a in the textbook.  Then, make a cluster plot of the hidden unit activations (cluster data src to TrialOutputData and Cluster Run again).  This should look like Figure 3.10b.
</li></ul>
You should be able to see in these cluster plots that these digit units do not respond very informatively
to the letter stimuli.
<p>
</p><hr>
<p>
 <b>Question 3.4 (a)</b>   <i>Based on your experiences in the previous question, what would you expect to happen to the cluster plot of hidden responses to letter inputs as you lowered the g_bar.l leak current to a value of 4?  Do this -- were you right?</i>   <b>(b)</b>   <i>Would you say that this hidden representation is a good one for conveying letter identity information?  Why or why not? (Hint: Pay particular attention to whether any letters are collapsed in the cluster plot -- i.e., having no distance at all between them.)</i>   <b>(c)</b>   <i>Can you find any setting of g_bar.l that gives you a satisfactory hidden representation of letter information?  Explain.</i> 
</p><p>
</p><hr>
<p>


</p></body></html>";
  };
  taDoc @[1] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Transform";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Transform";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\"><head>
<title>CECN1 Projects - Computational Cognitive Neuroscience Wiki</title>
<meta name=\"generator\" content=\"MediaWiki 1.16wmf3\">
<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
<link rel=\"alternate\" type=\"application/x-wiki\" title=\"Edit\" href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit\">
<link rel=\"edit\" title=\"Edit\" href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/extensions/Drafts/Drafts.css?3\">
<link rel=\"stylesheet\" media=\"screen, projection\" href=\"/CompCogNeuro/extensions/HeaderTabs/skins/combined-min.css\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/lab/main-ltr.css?257\" media=\"screen\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?257\" media=\"screen\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?257\" media=\"print\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" media=\"print\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:lab.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;smaxage=0&amp;ts=20100814090239&amp;gen=css\">
<script>
var skin=\"lab\",
stylepath=\"/CompCogNeuro/skins\",
wgUrlProtocols=\"http\\\\:\\\\/\\\\/|https\\\\:\\\\/\\\\/|ftp\\\\:\\\\/\\\\/|irc\\\\:\\\\/\\\\/|gopher\\\\:\\\\/\\\\/|telnet\\\\:\\\\/\\\\/|nntp\\\\:\\\\/\\\\/|worldwind\\\\:\\\\/\\\\/|mailto\\\\:|news\\\\:|svn\\\\:\\\\/\\\\/\",
wgArticlePath=\"/CompCogNeuro/index.php/$1\",
wgScriptPath=\"/CompCogNeuro\",
wgScriptExtension=\".php\",
wgScript=\"/CompCogNeuro/index.php\",
wgVariantArticlePath=false,
wgActionPaths={},
wgServer=\"http://grey.colorado.edu\",
wgCanonicalNamespace=\"\",
wgCanonicalSpecialPageName=false,
wgNamespaceNumber=0,
wgPageName=\"CECN1_Projects\",
wgTitle=\"CECN1 Projects\",
wgAction=\"view\",
wgArticleId=7,
wgIsArticle=true,
wgUserName=\"Oreilly\",
wgUserGroups=[\"*\", \"user\", \"autoconfirmed\"],
wgUserLanguage=\"en\",
wgContentLanguage=\"en\",
wgBreakFrames=false,
wgCurRevisionId=686,
wgVersion=\"1.16wmf3\",
wgEnableAPI=true,
wgEnableWriteAPI=true,
wgSeparatorTransformTable=[\"\", \"\"],
wgDigitTransformTable=[\"\", \"\"],
wgMainPageTitle=\"Main Page\",
wgFormattedNamespaces={\"-2\": \"Media\", \"-1\": \"Special\", \"0\": \"\", \"1\": \"Talk\", \"2\": \"User\", \"3\": \"User talk\", \"4\": \"Computational Cognitive Neuroscience Wiki\", \"5\": \"Computational Cognitive Neuroscience Wiki talk\", \"6\": \"File\", \"7\": \"File talk\", \"8\": \"MediaWiki\", \"9\": \"MediaWiki talk\", \"10\": \"Template\", \"11\": \"Template talk\", \"12\": \"Help\", \"13\": \"Help talk\", \"14\": \"Category\", \"15\": \"Category talk\", \"100\": \"Project\"},
wgNamespaceIds={\"media\": -2, \"special\": -1, \"\": 0, \"talk\": 1, \"user\": 2, \"user_talk\": 3, \"computational_cognitive_neuroscience_wiki\": 4, \"computational_cognitive_neuroscience_wiki_talk\": 5, \"file\": 6, \"file_talk\": 7, \"mediawiki\": 8, \"mediawiki_talk\": 9, \"template\": 10, \"template_talk\": 11, \"help\": 12, \"help_talk\": 13, \"category\": 14, \"category_talk\": 15, \"project\": 100, \"image\": 6, \"image_talk\": 7},
wgMWSuggestTemplate=\"http://grey.colorado.edu/CompCogNeuro/api.php?action=opensearch\\x26search={searchTerms}\\x26namespace={namespaces}\\x26suggest\",
wgDBname=\"compcogneuro\",
wgSearchNamespaces=[0, 1, 2, 3, 4, 5, 10],
wgMWSuggestMessages=[\"with suggestions\", \"no suggestions\"],
wgRestrictionEdit=[],
wgRestrictionMove=[],
wgAjaxWatch={\"watchMsg\": \"Watch\", \"unwatchMsg\": \"Unwatch\", \"watchingMsg\": \"Watching...\", \"unwatchingMsg\": \"Unwatching...\", \"tooltip-ca-watchMsg\": \"Add this page to your watchlist\", \"tooltip-ca-unwatchMsg\": \"Remove this page from your watchlist\"};
</script>
<script src=\"/CompCogNeuro/skins/common/wikibits.js?urid=257_1267416510\"></script>
<script src=\"/CompCogNeuro/skins/common/ajax.js?urid=257_1247772050\"></script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Drafts/Drafts.js?3\"></script>
<script src=\"/CompCogNeuro/skins/common/ajaxwatch.js?urid=257_1263080834\"></script>
<script src=\"/CompCogNeuro/skins/common/mwsuggest.js?urid=257_1254854293\"></script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/HeaderTabs/skins/combined-history-min.js\"></script>
<!--[if lt IE 7]><style type=\"text/css\">body{behavior:url(\"/CompCogNeuro/skins/lab/csshover.htc\")}</style><![endif]-->
<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?257\"></script><meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->
<script src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;smaxage=0&amp;gen=js&amp;useskin=lab&amp;urid=257\"></script>

</head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Projects skin-lab\" dir=\"ltr\">
                <div style=\"position:absolute; top:5px; left: 5px;z-index:99999;\">
		     <a href=\"/CompCogNeuro/index.php/Main_Page\">
		     	<img height=\"30px\" src=\"/mediawiki/sites//CompCogNeuro/logo.png\">
		     </a>
		</div>
		<div id=\"page-base\" class=\"noprint\"></div>
		<div id=\"head-base\" class=\"noprint\"></div>
		<!-- content -->
		<div id=\"content\">
			<a id=\"top\"></a>
			<div id=\"mw-js-message\" style=\"display:none;\"></div>
						<!-- firstHeading -->
			<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Projects</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id=\"bodyContent\">

				<!-- tagline -->
				<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
				<!-- /tagline -->
				<!-- subtitle -->
				<div id=\"contentSub\"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id=\"jump-to-nav\">
					Jump to:<a href=\"#head\">navigation</a>,
					<a href=\"#p-search\">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodytext -->
				<p>These simulation projects for the <a href=\"/CompCogNeuro/index.php/CECN\" title=\"CECN\">CECN</a> textbook, implemented in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a> serve as replacements for the original projects that were done in PDP++.  They have completely self-contained documentation that opens up when the project is opened -- follow those instructions instead of the ones written in the textbook.
</p>
<table id=\"toc\" class=\"toc\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1 tocsection-1\"><a href=\"#General_Usage_Tips\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">General Usage Tips</span></a></li>
<li class=\"toclevel-1 tocsection-2\"><a href=\"#One_.zip_File_of_All_Projects\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">One .zip File of All Projects</span></a></li>
<li class=\"toclevel-1 tocsection-3\"><a href=\"#Chapter_2:_Individual_Neurons\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">Chapter 2: Individual Neurons</span></a></li>
<li class=\"toclevel-1 tocsection-4\"><a href=\"#Chapter_3:_Networks_of_Neurons\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">Chapter 3: Networks of Neurons</span></a></li>
<li class=\"toclevel-1 tocsection-5\"><a href=\"#Chapter_4:_Hebbian_Model_Learning\"><span class=\"tocnumber\">5</span> <span class=\"toctext\">Chapter 4: Hebbian Model Learning</span></a></li>
<li class=\"toclevel-1 tocsection-6\"><a href=\"#Chapter_5:_Error-Driven_Task_Learning\"><span class=\"tocnumber\">6</span> <span class=\"toctext\">Chapter 5: Error-Driven Task Learning</span></a></li>
<li class=\"toclevel-1 tocsection-7\"><a href=\"#Chapter_6:_Combined_Model_and_Task_Learning.2C_and_Other_Mechanisms\"><span class=\"tocnumber\">7</span> <span class=\"toctext\">Chapter 6: Combined Model and Task Learning, and Other Mechanisms</span></a></li>
<li class=\"toclevel-1 tocsection-8\"><a href=\"#Chapter_8:_Perception_and_Attention\"><span class=\"tocnumber\">8</span> <span class=\"toctext\">Chapter 8: Perception and Attention</span></a></li>
<li class=\"toclevel-1 tocsection-9\"><a href=\"#Chapter_9:_Memory\"><span class=\"tocnumber\">9</span> <span class=\"toctext\">Chapter 9: Memory</span></a></li>
<li class=\"toclevel-1 tocsection-10\"><a href=\"#Chapter_10:_Language\"><span class=\"tocnumber\">10</span> <span class=\"toctext\">Chapter 10: Language</span></a></li>
<li class=\"toclevel-1 tocsection-11\"><a href=\"#Chapter_11:_Higher_Level_Cognition\"><span class=\"tocnumber\">11</span> <span class=\"toctext\">Chapter 11: Higher Level Cognition</span></a></li>
<li class=\"toclevel-1 tocsection-12\"><a href=\"#Student_Projects\"><span class=\"tocnumber\">12</span> <span class=\"toctext\">Student Projects</span></a></li>
</ul>
</td></tr></tbody></table><script>if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=1\" title=\"Edit section: General Usage Tips\">edit</a>]</span> <span class=\"mw-headline\" id=\"General_Usage_Tips\"> General Usage Tips </span></h2>
<p>In addition to all the tips available at the <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a> website, the following are particularly relevant to these projects:
</p>
<ul><li> To make the documentation instructions always available in a separate window: do <code>Object/Edit Dialog</code> in the menu just above the document text that shows up when you open the project.  Alternatively, you can just always return to the document by clicking on the <code>ProjectDocs</code> tab at the top of the middle panel.
</li></ul>
<ul><li> If your screen is small, you may also want to make the document  window \"Always on Top\": (e.g., in Linux, <code>Emergent-logo-at-top-left/Advanced-&gt; Keep Above Others</code>) and also use the \"Shade\" feature: double-click the top control bar to toggle the window between \"rolled up\" and \"rolled down\" (also: <code>Emergent-logo-&gt;Shade</code>).  (Caution: you cannot double click on the Emergent-logo itself!).  Keeping the <code>ProjectDocs</code> window on the left over the tree browser panel frame seems to work best since you will generally be watching and working with the right two frames the most.
</li></ul>
<ul><li> <b>Important:</b> Projects are in the process of being converted to <b>version 5.1.0</b> of <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>, released 8/15/10.  The program stepping logic in 5.1.0 was significantly simplified so you can instantly access multiple levels of stepping, but the documentation may not have all been updated perfectly to match this new logic.
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=2\" title=\"Edit section: One .zip File of All Projects\">edit</a>]</span> <span class=\"mw-headline\" id=\"One_.zip_File_of_All_Projects\"> One .zip File of All Projects </span></h2>
<p>This file: <a href=\"ftp://grey.colorado.edu/pub/emergent/cecn.zip\" class=\"external text\" rel=\"nofollow\">cecn.zip</a> contains the entire set of projects and supporting files.  Last updated 9/7/09.
</p>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=3\" title=\"Edit section: Chapter 2: Individual Neurons\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_2:_Individual_Neurons\"> Chapter 2: Individual Neurons </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Units\" title=\"CECN1 Units\">CECN1 Units</a> (units.proj) -- Individual Neuron (Unit)
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Detector\" title=\"CECN1 Detector\">CECN1 Detector</a> (detector.proj) -- The Unit as a Detector
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Self_Reg\" title=\"CECN1 Self Reg\">CECN1 Self Reg</a> (self_reg.proj) -- Self regulation through accommodation and hysteresis (optional)
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=4\" title=\"Edit section: Chapter 3: Networks of Neurons\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_3:_Networks_of_Neurons\"> Chapter 3: Networks of Neurons </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Transform\" title=\"CECN1 Transform\">CECN1 Transform</a> (transform.proj) -- Transformations produced by feedforward neural processing
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Localist_vs_Distributed\" title=\"CECN1 Localist vs Distributed\">CECN1 Localist vs Distributed</a> (loc_dist.proj) -- Localist vs Distributed representations
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Bidirectional_Transformations\" title=\"CECN1 Bidirectional Transformations\">CECN1 Bidirectional Transformations</a> (bidir_xform.proj) -- Bidirectional (top-down and bottom-up) processing and transformations
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Pattern_Completion\" title=\"CECN1 Pattern Completion\">CECN1 Pattern Completion</a> (pat_complete.proj) -- Pattern completion
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Top-down_Amplification\" title=\"CECN1 Top-down Amplification\">CECN1 Top-down Amplification</a> (amp_top_down.proj) -- Top-down amplification of bottom-up signals
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Distributed_Top-down_Amplification\" title=\"CECN1 Distributed Top-down Amplification\">CECN1 Distributed Top-down Amplification</a> (amp_top_down_dist.proj) -- Top-down amplification in distributed network
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Inhibition\" title=\"CECN1 Inhibition\">CECN1 Inhibition</a> (inhib.proj) -- Inhibitory interactions
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Inhibition_Digits\" title=\"CECN1 Inhibition Digits\">CECN1 Inhibition Digits</a> (inhib_digits.proj) -- Digits model revisited with inhibition
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Cats_and_Dogs\" title=\"CECN1 Cats and Dogs\">CECN1 Cats and Dogs</a> (cats_and_dogs.proj) -- Constraint satisfaction in the Cats and Dogs model
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Necker_Cube\" title=\"CECN1 Necker Cube\">CECN1 Necker Cube</a> (necker_cube.proj) -- Constraint satisfaction and the role of noise and accommodation in the Necker Cube model
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=5\" title=\"Edit section: Chapter 4: Hebbian Model Learning\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_4:_Hebbian_Model_Learning\"> Chapter 4: Hebbian Model Learning </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Hebbian_Correlation\" title=\"CECN1 Hebbian Correlation\">CECN1 Hebbian Correlation</a> (hebb_correl.proj) -- Hebbian correlational learning
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Self_Organizing\" title=\"CECN1 Self Organizing\">CECN1 Self Organizing</a> (self_org.proj) -- Self organizing learning using Hebbian learning and inhibitory competition
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=6\" title=\"Edit section: Chapter 5: Error-Driven Task Learning\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_5:_Error-Driven_Task_Learning\"> Chapter 5: Error-Driven Task Learning </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Pattern_Associator\" title=\"CECN1 Pattern Associator\">CECN1 Pattern Associator</a> (pat_assoc.proj) -- Simple input/output pattern association task learning 
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Generec\" title=\"CECN1 Generec\">CECN1 Generec</a> (generec.proj) -- Full error-driven learning using the Generalized Recirculation algorithm
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=7\" title=\"Edit section: Chapter 6: Combined Model and Task Learning, and Other Mechanisms\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_6:_Combined_Model_and_Task_Learning.2C_and_Other_Mechanisms\"> Chapter 6: Combined Model and Task Learning, and Other Mechanisms </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Model_And_Task\" title=\"CECN1 Model And Task\">CECN1 Model And Task</a> (model_and_task.proj) -- Combined model and task learning
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Family_Trees\" title=\"CECN1 Family Trees\">CECN1 Family Trees</a> (family_trees.proj) -- Learning in a deep (multi-hidden-layer) network
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_FSA\" title=\"CECN1 FSA\">CECN1 FSA</a> (fsa.proj) -- Finite State Automaton test of Simple Recurrent Networks
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Reinforcement_Learning\" title=\"CECN1 Reinforcement Learning\">CECN1 Reinforcement Learning</a> (rl_cond.proj) -- Simple Pavlovian Conditioning using Temporal Differences Learning
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=8\" title=\"Edit section: Chapter 8: Perception and Attention\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_8:_Perception_and_Attention\"> Chapter 8: Perception and Attention </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_V1Rf\" title=\"CECN1 V1Rf\">CECN1 V1Rf</a> (v1rf.proj) -- V1 receptive fields from Hebbian learning
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Objrec\" title=\"CECN1 Objrec\">CECN1 Objrec</a> (objrec.proj) -- invariant object recognition
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_AttnSimple\" title=\"CECN1 AttnSimple\">CECN1 AttnSimple</a> (attn_simple.proj) -- simple attention model
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Objrec_Multiobj\" title=\"CECN1 Objrec Multiobj\">CECN1 Objrec Multiobj</a> (objrec_multiobj.proj) -- Object recognition with multiple objects: NOTE Not converting from PDP++ until later (click for more info)
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=9\" title=\"Edit section: Chapter 9: Memory\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_9:_Memory\"> Chapter 9: Memory </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Wt_Priming\" title=\"CECN1 Wt Priming\">CECN1 Wt Priming</a> (wt_priming.proj) -- Weight-based (long-term) priming
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_AB-AC_List_Learning\" title=\"CECN1 AB-AC List Learning\">CECN1 AB-AC List Learning</a> (ab_ac_interference.proj) -- Paired associate learning and catastrophic interference
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Hippocampus\" title=\"CECN1 Hippocampus\">CECN1 Hippocampus</a> (hip.proj) -- Hippocampus model and overcoming interference
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Act_Priming\" title=\"CECN1 Act Priming\">CECN1 Act Priming</a> (act_priming.proj) -- Activation-based (short-term) priming
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Active_Maintenance\" title=\"CECN1 Active Maintenance\">CECN1 Active Maintenance</a> (act_maint.proj) -- Active maintenance in simple prefrontal cortex (PFC)
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_PFC_Maint_Updt\" title=\"CECN1 PFC Maint Updt\">CECN1 PFC Maint Updt</a> (pfc_maint_updt.proj) -- Updating and Maintenance in more complex PFC model
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_A_Not_B\" title=\"CECN1 A Not B\">CECN1 A Not B</a> (a_not_b.proj) -- Development of interacting memory systems and the A-not-B task
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=10\" title=\"Edit section: Chapter 10: Language\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_10:_Language\"> Chapter 10: Language </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Dyslexia\" title=\"CECN1 Dyslexia\">CECN1 Dyslexia</a> (dyslex.proj) -- Normal and disordered reading and the distributed lexicon
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Spelling_to_Sound\" title=\"CECN1 Spelling to Sound\">CECN1 Spelling to Sound</a> (ss.proj) -- Orthography to Phonology mapping and regularity, frequency effects
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Past_Tense\" title=\"CECN1 Past Tense\">CECN1 Past Tense</a> (pt.proj) -- Overregularization of the English past tense inflection
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Semantics\" title=\"CECN1 Semantics\">CECN1 Semantics</a> (sem.proj) -- Semantic Representations from World Co-occurrences and Hebbian Learning
</li><li> <a href=\"/CompCogNeuro/index.php/CECN1_Sentence_Gestalt\" title=\"CECN1 Sentence Gestalt\">CECN1 Sentence Gestalt</a> (sg.proj) -- The Sentence Gestalt model
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=11\" title=\"Edit section: Chapter 11: Higher Level Cognition\">edit</a>]</span> <span class=\"mw-headline\" id=\"Chapter_11:_Higher_Level_Cognition\"> Chapter 11: Higher Level Cognition </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN1_Stroop\" title=\"CECN1 Stroop\">CECN1 Stroop</a> (stroop.proj) -- The Stroop effect and PFC top-down biasing
</li><li> <a href=\"/CompCogNeuro/index.php?title=CECN1_ID_ED&amp;action=edit&amp;redlink=1\" class=\"new\" title=\"CECN1 ID ED (page does not exist)\">CECN1 ID_ED</a> (id_ed.proj) -- The intradimensional/extradimensional task
</li></ul>
<h2><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit&amp;section=12\" title=\"Edit section: Student Projects\">edit</a>]</span> <span class=\"mw-headline\" id=\"Student_Projects\"> Student Projects </span></h2>
<ul><li> <a href=\"/CompCogNeuro/index.php/CECN_Student_Projects\" title=\"CECN Student Projects\">CECN Student Projects</a> -- Projects developed by students in various classes.
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 47/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:7-0!1!0!!en!2 and timestamp 20100814090234 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Projects\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Projects</a>\"</div>
				<!-- /bodytext -->
								<!-- catlinks -->
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<!-- /catlinks -->
												<div class=\"visualClear\"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id=\"head\" class=\"noprint\">
			
<!-- 0 -->
<div id=\"p-personal\" class=\"\">
	<h5>Personal tools</h5>
	<ul lang=\"en\" xml:lang=\"en\">
					<li id=\"pt-userpage\"><a href=\"/CompCogNeuro/index.php/User:Oreilly\" title=\"Your user page [ctrl-alt-.]\" accesskey=\".\" class=\"new\">Oreilly</a></li>
					<li id=\"pt-mytalk\"><a href=\"/CompCogNeuro/index.php/User_talk:Oreilly\" title=\"Your talk page [ctrl-alt-n]\" accesskey=\"n\" class=\"new\">My talk</a></li>
					<li id=\"pt-preferences\"><a href=\"/CompCogNeuro/index.php/Special:Preferences\" title=\"Your preferences\">My preferences</a></li>
					<li id=\"pt-watchlist\"><a href=\"/CompCogNeuro/index.php/Special:Watchlist\" title=\"The list of pages you are monitoring for changes [ctrl-alt-l]\" accesskey=\"l\">My watchlist</a></li>
					<li id=\"pt-mycontris\"><a href=\"/CompCogNeuro/index.php/Special:Contributions/Oreilly\" title=\"List of your contributions [ctrl-alt-y]\" accesskey=\"y\">My contributions</a></li>
					<li id=\"pt-logout\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogout&amp;returnto=CECN1_Projects\" title=\"Log out\">Log out</a></li>
			</ul>
</div>

<!-- /0 -->
			<div id=\"left-navigation\">
				
<!-- 0 -->
<div id=\"p-namespaces\" class=\"labTabs\">
	<h5>Namespaces</h5>
	<ul lang=\"en\" xml:lang=\"en\">
					<li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\"><span>Page</span></a></li>
					<li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Projects&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\"><span>Discussion</span></a></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id=\"p-variants\" class=\"labMenu emptyPortlet\">
	<h5><span>Variants</span><a href=\"#\"></a></h5>
	<div class=\"menu\">
		<ul lang=\"en\" xml:lang=\"en\">
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id=\"right-navigation\">
				
<!-- 0 -->
<div id=\"p-views\" class=\"labTabs\">

	<h5>Views</h5>
	<ul lang=\"en\" xml:lang=\"en\">
					<li id=\"ca-view\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Projects\"><span>Read</span></a></li>
					<li id=\"ca-edit\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=edit\" title=\"You can edit this page.
Please use the preview button before saving [ctrl-alt-e]\" accesskey=\"e\"><span>Edit</span></a></li>
					<li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\"><span>View history</span></a></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id=\"p-cactions\" class=\"labMenu\">
	<h5><span>Actions</span><a href=\"#\"></a></h5>
	<div class=\"menu\">
	     <ul>

							<li id=\"ca-delete\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=delete\" title=\"Delete this page [ctrl-alt-d]\" accesskey=\"d\">Delete</a></li>
							<li id=\"ca-move\"><a href=\"/CompCogNeuro/index.php/Special:MovePage/CECN1_Projects\" title=\"Move this page [ctrl-alt-m]\" accesskey=\"m\">Move</a></li>
							<li id=\"ca-unwatch\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;action=unwatch\" title=\"Remove this page from your watchlist [ctrl-alt-w]\" accesskey=\"w\">Unwatch</a></li>
						
<!-- navigation -->
					<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\">Main Page</a></li>
					<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
					<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
					<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
					<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
					<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
		
<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
					<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Projects\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
						<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Projects\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
																																					<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
											<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
											<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Projects&amp;oldid=686\" title=\"Permanent link to this revision of the page\">Permanent link</a></li>
		
<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
	     </ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id=\"p-search\">
	<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
	<form action=\"/CompCogNeuro/index.php\" id=\"searchform\">
		<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\" autocomplete=\"off\">
		<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">
		<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- footer -->
		<div id=\"footer\">
											<ul id=\"footer-info\">
																	<li id=\"footer-info-lastmod\"> This page was last modified on 14 August 2010, at 09:02.</li>
																							<li id=\"footer-info-viewcount\">This page has been accessed 19,869 times.</li>
															</ul>
															<ul id=\"footer-places\">
																	<li id=\"footer-places-privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
																							<li id=\"footer-places-about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
																							<li id=\"footer-places-disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
															</ul>
										<ul id=\"footer-icons\" class=\"noprint\">
								<li id=\"footer-icon-poweredby\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" height=\"31\" width=\"88\" alt=\"Powered by MediaWiki\"></a></li>
											</ul>
			<div style=\"clear:both\"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type=\"text/javascript\"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		
<script>if (window.runOnloadHook) runOnloadHook();</script>
		<!-- Served in 0.173 secs. -->			

</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="master control for the Transform project";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="input_data";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0].args[1]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="g_bar";
     desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0]$$;
     mbr=LeabraUnitSpec::g_bar;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="biases_on";
     desc=" boolean value";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0].vars[5]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="cluster_data_src";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set";
     cust_desc=0;
     base=.projects[0].programs[1].args[0]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="Localist_Network trial";
      desc=" trial counter: number of external input patterns that have been presented in the current epoch (updated by program)";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=Network::trial;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="Localist_Network trial name";
      desc=" name associated with the current trial (e.g., name of input pattern, typically set by a LayerWriter)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="Localist_Network cycle";
      desc=" cycle counter: number of iterations of activation updating (settling) on the current external input pattern (updated by program)	";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::cycle;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Cluster Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[1]$$;
     mth=Program::Run_Gui;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="Digits";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [10] "0";"1";"2";"3";"4";"5";"6";"7";"8";"9";
      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;7;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 7 10] 0;0;1;0;0;0;1;0;1;0;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;0;1;0;1;0;
0;0;1;0;0;1;1;1;1;1;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;1;0;1;0;0;
0;1;1;0;0;0;0;1;0;0;
1;1;1;1;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;1;0;
0;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;1;0;
1;0;0;0;1;0;0;0;0;1;
0;0;1;1;0;0;0;0;1;0;
1;0;0;0;1;0;1;1;1;1;
0;0;0;1;0;0;0;0;1;0;
1;1;1;1;1;1;0;0;1;0;
0;1;0;1;0;0;0;1;1;0;
0;0;0;1;0;1;1;1;1;0;
0;0;0;0;1;0;0;0;0;1;
0;1;1;1;0;1;0;0;0;0;
1;0;0;0;0;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;1;0;0;1;1;0;1;1;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;1;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;1;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;0;1;1;1;0;
1;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;1;1;0;1;1;0;0;1;1;
1;0;0;0;1;0;1;1;1;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="NoisyDigits";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [30] "0";"1";"2";"3";"4";"5";"6";"7";"8";"9";
"0";"1";"2";"3";"4";"5";"6";"7";"8";"9";
"0";"1";"2";"3";"4";"5";"6";"7";"8";"9";
      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;7;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 7 30] 0;0;1;0;0;0;1;0;1;0;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;0;1;0;1;0;
0;0;1;0;0;1;1;1;1;1;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;1;0;1;0;0;
0;1;1;0;0;0;0;1;0;0;
1;1;1;1;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;1;0;
0;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;1;0;
1;0;0;0;1;0;0;0;0;1;
0;0;1;1;0;0;0;0;1;0;
1;0;0;0;1;0;1;1;1;1;
0;0;0;1;0;0;0;0;1;0;
1;1;1;1;1;1;0;0;1;0;
0;1;0;1;0;0;0;1;1;0;
0;0;0;1;0;1;1;1;1;0;
0;0;0;0;1;0;0;0;0;1;
0;1;1;1;0;1;0;0;0;0;
1;0;0;0;0;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;1;0;0;1;1;0;1;1;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;1;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;1;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;0;1;1;1;0;
1;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;1;1;0;1;1;0;0;1;1;
1;0;0;0;1;0;1;1;1;0;
0;0;1;0;0;0;1;1;1;0;
1;0;0;0;1;1;0;0;0;1;
1;1;0;0;1;0;1;0;1;0;
0;0;1;0;0;1;1;1;1;1;
0;1;1;0;0;0;0;1;0;0;
0;0;1;0;0;1;0;1;0;0;
0;1;1;1;0;0;0;1;0;0;
1;1;1;1;1;1;0;0;1;0;
0;1;0;0;0;0;1;1;1;0;
0;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;1;0;
1;1;0;0;1;0;0;0;0;1;
0;0;1;1;0;0;0;0;1;0;
1;0;0;1;1;0;1;1;1;1;
0;0;0;1;0;0;0;0;1;1;
1;1;1;1;1;1;0;0;1;0;
0;1;0;1;0;0;0;1;1;0;
0;0;1;1;0;1;1;1;1;0;
0;0;0;0;1;0;0;0;1;1;
0;1;1;1;0;1;1;0;0;0;
1;0;0;0;0;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;1;0;0;1;1;1;1;1;0;
1;0;0;0;0;0;1;0;1;0;
0;0;1;1;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;1;1;0;0;0;0;1;0;
0;0;0;1;1;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;1;0;0;1;0;1;1;1;0;
1;0;0;1;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;0;0;
0;1;0;1;0;0;0;0;0;1;
0;1;1;1;1;1;0;0;1;1;
1;0;0;0;1;0;1;1;1;0;
0;0;1;0;0;0;1;0;1;0;
1;0;0;1;1;1;0;0;0;1;
1;0;0;0;1;0;1;1;1;0;
0;0;1;0;0;1;1;1;1;1;
0;0;1;1;0;0;0;1;0;0;
0;0;1;0;0;1;1;1;0;0;
0;1;1;0;0;0;0;1;0;0;
1;1;1;1;1;1;1;0;0;0;
0;1;0;0;0;0;0;1;1;0;
0;0;0;0;1;1;0;0;1;1;
0;1;1;1;0;0;1;1;1;0;
1;0;0;0;1;0;0;0;0;1;
0;0;1;1;0;0;0;1;1;0;
1;1;0;0;1;0;1;1;1;1;
0;0;0;1;0;0;0;1;1;0;
1;1;1;1;1;1;0;0;1;0;
1;1;0;1;0;0;0;1;1;0;
0;0;0;1;0;1;1;1;1;0;
1;0;0;0;1;0;0;0;0;1;
0;1;1;1;1;1;0;0;0;0;
1;0;0;0;0;1;1;1;1;1;
0;1;1;1;0;1;1;0;0;1;
1;1;0;0;1;1;0;1;1;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;1;0;0;1;0;0;0;
0;1;1;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;1;
0;0;0;0;1;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;1;1;0;1;1;1;0;
1;1;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;1;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;1;1;0;1;1;1;0;1;1;
1;0;0;1;1;0;1;1;1;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="Letters";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [26] "A";"B";"C";"D";"E";"F";"G";"H";"I";"J";
"K";"L";"M";"N";"O";"P";"Q";"R";"S";"T";
"U";"V";"W";"X";"Y";"Z";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;7;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 7 26] 1;0;0;0;1;1;0;0;0;1;
1;1;1;1;1;1;0;0;0;1;
1;0;0;0;1;0;1;0;1;0;
0;0;1;0;0;1;1;1;1;0;
0;1;0;0;1;0;1;0;0;1;
0;1;1;1;0;0;1;0;0;1;
0;1;0;0;1;1;1;1;1;0;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;1;
0;1;1;1;0;1;1;1;1;0;
0;1;0;0;1;0;1;0;0;1;
0;1;0;0;1;0;1;0;0;1;
0;1;0;0;1;1;1;1;1;0;
1;1;1;1;1;1;0;0;0;0;
1;0;0;0;0;1;1;1;1;0;
1;0;0;0;0;1;0;0;0;0;
1;1;1;1;1;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
1;1;1;1;0;1;0;0;0;0;
1;0;0;0;0;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;0;1;1;1;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;1;1;1;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;1;1;1;0;0;1;1;1;0;
1;0;0;0;1;0;0;0;0;1;
0;0;0;0;1;0;0;0;0;1;
0;0;0;0;1;0;0;1;1;1;
1;0;0;0;1;1;0;0;1;0;
1;0;1;0;0;1;1;0;0;0;
1;0;1;0;0;1;0;0;1;0;
1;0;0;0;1;1;1;1;1;1;
1;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;1;0;1;0;1;
1;1;0;1;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;1;0;
1;0;0;1;0;1;0;0;1;0;
1;0;1;1;0;1;1;0;1;0;
1;0;0;1;0;1;0;0;1;0;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
1;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;1;1;1;1;0;
0;0;0;0;1;0;1;1;1;0;
1;0;1;0;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;1;0;1;0;1;0;0;
1;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;1;1;1;1;0;
0;1;1;1;0;1;0;0;0;1;
0;0;0;0;1;0;1;1;1;0;
1;0;0;0;0;1;0;0;0;1;
0;1;1;1;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;1;1;1;1;1;
0;1;1;1;0;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;0;0;1;0;0;
0;1;0;1;0;0;1;0;1;0;
0;1;0;1;0;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;1;1;0;1;1;
1;0;1;0;1;1;0;1;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;1;0;0;0;1;
1;0;0;0;1;0;1;0;1;0;
0;0;1;0;0;0;1;0;1;0;
1;0;0;0;1;1;0;0;0;1;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;1;0;1;0;1;0;0;0;1;
1;0;0;0;1;1;1;1;1;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;1;1;1;1;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[1] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="Input_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;7;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 7 0]       };
     };
     float_Data @[3] {
      name="Hidden_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 2 0]       };
     };
     float_Data @[4] {
      name="hid_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 2 0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="ClusterPlotData";
    desc=;
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     float_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="X_AXIS";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=1.62634551525116;
	val_type_fixed=0;
       };
      };
      name="X";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [57] 0;0;0;0;0;1.4142135;0;0;0;0;
1.4142135;0;0;0;0;1.4142135;0;0;0;0;
1.4142135;0;0;0;0;1.4142135;0;0;0;0;
1.4142135;0;0;0;0;1.4142135;0;0;0;0;
1.4142135;0;0;0;0;1.4142135;0;0;0;0;
1.4142135;0;0;0;0;0;0;      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_1";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=9.800000190734863;
	val_type_fixed=0;
       };
       UserDataItem @[2] {
	name="MIN";
	value 6 0=0.2000000029802322;
	val_type_fixed=0;
       };
      };
      name="Y";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [57] 5;5;5;5;0.5;0.5;0.5;0.5;5;1.5;
1.5;1.5;1.5;5;2.5;2.5;2.5;2.5;5;3.5;
3.5;3.5;3.5;5;4.5;4.5;4.5;4.5;5;5.5;
5.5;5.5;5.5;5;6.5;6.5;6.5;6.5;5;7.5;
7.5;7.5;7.5;5;8.5;8.5;8.5;8.5;5;9.5;
9.5;9.5;9.5;5;5;5;5;      };
     };
     String_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_2";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="Label";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [57] ;;;;;"0";;;;;
"1";;;;;"2";;;;;
"3";;;;;"4";;;;;
"5";;;;;"6";;;;;
"7";;;;;"8";;;;;
"9";;;;;;;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="SetBiasWeights";
   short_nm="SBWght";
   tags=;
   desc="sets bias weights for network depending on arg (on or off)";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="biases_on";
     var_type=T_Bool;
     bool_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="big_wt_val";
     var_type=T_Real;
     real_val=7;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="large bias weight value (7.0 by default)";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="sm_wt_val";
     var_type=T_Real;
     real_val=2;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="small bias weight value (2.0 by default)";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="Hidden";
     var_type=T_Object;
     object_type=LeabraLayer;
     object_val=.projects[0].networks[0].layers[1]$$;
     objs_ptr=0;
     flags=USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="i";
     var_type=T_Int;
     int_val=10;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    AssignExpr @[0] {
     desc=;
     flags=;
     result_var=.projects[0].programs[0].vars[2]$$;
     expr {
      expr="network.layers.Hidden";
     };
    };
    IfElse @[1] {
     desc=;
     flags=;
     cond {
      expr="biases_on";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ForLoop @[0] {
       desc=;
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	IfElse @[0] {
	 desc=;
	 flags=;
	 cond {
	  expr="i <= 1 || i == 4 || i==7";
	 };
	 true_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  MemberAssign @[0] {
	   desc=;
	   flags=;
	   obj=$.projects[0].programs[0].vars[2]$;
	   path="units[i].bias.Cn(0).wt";
	   expr {
	    expr="big_wt_val";
	   };
	   update_after=0;
	  };
	  If @[1] {
	   desc=;
	   flags=;
	   cond {
	    expr="i == 7";
	   };
	   true_code {
	    name=;
	    el_typ=ProgEl;
	    el_def=0;
	    MemberAssign @[0] {
	     desc=;
	     flags=;
	     obj=$.projects[0].programs[0].vars[2]$;
	     path="units[i].bias.Cn(0).wt";
	     expr {
	      expr="big_wt_val + sm_wt_val";
	     };
	     update_after=0;
	    };
	   };
	  };
	 };
	 false_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  MemberAssign @[0] {
	   desc=;
	   flags=;
	   obj=$.projects[0].programs[0].vars[2]$;
	   path="units[i].bias.Cn(0).wt";
	   expr {
	    expr="sm_wt_val";
	   };
	   update_after=0;
	  };
	 };
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 10";
       };
       iter {
	expr="i++";
       };
      };
     };
     false_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ForLoop @[0] {
       desc=;
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MemberAssign @[0] {
	 desc=;
	 flags=;
	 obj=$.projects[0].programs[0].vars[2]$;
	 path="units[i].bias.Cn(0).wt";
	 expr {
	  expr="0";
	 };
	 update_after=0;
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < 10";
       };
       iter {
	expr="i++";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="ClusterPlot";
   short_nm="ClsPlt";
   tags=;
   desc=;
   flags=;
   objs {
    name=;
    el_typ=DataTable;
    el_def=0;
    DataTable @[0] {
     name="Binarized_Data";
     desc=;
     data {
      name="data";
      el_typ=DataColTp;
      el_def=0;
      int_Data @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItemBase;
	el_def=0;
	UserDataItem @[0] {
	 name="NARROW";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="trial";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [10] 0;1;2;3;4;5;6;7;8;9;
       };
      };
      String_Data @[1] {
       name="trial_name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [10] "0";"1";"2";"3";"4";"5";"6";"7";"8";"9";
       };
      };
      float_Data @[2] {
       name="Input_act";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 5;7;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [5 7 10] 0;0;0.94999999;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0;0;0.94999999;0.94999999;0;0;0;0.94999999;
0.94999999;0;0;0;0.94999999;0;0.94999999;0;0.94999999;0;
0;0;0.94999999;0;0;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;
0;0;0.94999999;0;0;0;0;0.94999999;0;0;
0;0;0.94999999;0;0;0.94999999;0;0.94999999;0;0;
0;0.94999999;0.94999999;0;0;0;0;0.94999999;0;0;
0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;0;0;0;0;
0;0.94999999;0;0;0;0;0;0.94999999;0.94999999;0;
0;0;0;0;0.94999999;0.94999999;0;0;0;0.94999999;
0;0.94999999;0.94999999;0.94999999;0;0;0.94999999;0.94999999;0.94999999;0;
0.94999999;0;0;0;0.94999999;0;0;0;0;0.94999999;
0;0;0.94999999;0.94999999;0;0;0;0;0.94999999;0;
0.94999999;0;0;0;0.94999999;0;0.94999999;0.94999999;0.94999999;0.94999999;
0;0;0;0.94999999;0;0;0;0;0.94999999;0;
0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;0;0;0.94999999;0;
0;0.94999999;0;0.94999999;0;0;0;0.94999999;0.94999999;0;
0;0;0;0.94999999;0;0.94999999;0.94999999;0.94999999;0.94999999;0;
0;0;0;0;0.94999999;0;0;0;0;0.94999999;
0;0.94999999;0.94999999;0.94999999;0;0.94999999;0;0;0;0;
0.94999999;0;0;0;0;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;
0;0.94999999;0.94999999;0.94999999;0;0.94999999;0;0;0;0.94999999;
0.94999999;0.94999999;0;0;0.94999999;0.94999999;0;0.94999999;0.94999999;0;
0.94999999;0;0;0;0;0;0.94999999;0;0;0;
0;0;0.94999999;0.94999999;0;0;0.94999999;0;0;0;
0;0.94999999;0;0;0;0;0;0.94999999;0;0;
0;0;0;0.94999999;0;0;0;0;0.94999999;0;
0;0;0;0;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;0.94999999;
0;0.94999999;0.94999999;0.94999999;0;0.94999999;0;0;0;0.94999999;
0.94999999;0;0;0;0.94999999;0;0.94999999;0.94999999;0.94999999;0;
0.94999999;0;0;0;0.94999999;0.94999999;0;0;0;0.94999999;
0;0.94999999;0.94999999;0.94999999;0;0;0.94999999;0.94999999;0;0;
0;0;0;0.94999999;0;0;0;0;0;0.94999999;
0;0.94999999;0.94999999;0;0.94999999;0.94999999;0;0;0.94999999;0.94999999;
0.94999999;0;0;0;0.94999999;0;0.94999999;0.94999999;0.94999999;0;
       };
      };
      float_Data @[3] {
       name="Hidden_act";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 5;2;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [5 2 10] 1;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
       };
      };
      float_Data @[4] {
       name="hid_net";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 5;2;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [5 2 10] 0.87058818;0.42352942;0.22478992;0.22478992;0.47941178;0.28067228;0.44831935;0.36890757;0.39243698;0.44831935;
0.42352942;0.92647052;0.44831935;0.33655462;0.36764705;0.39243698;0.44831935;0.42478994;0.39243698;0.33655462;
0.36764705;0.59117651;0.89537805;0.67184871;0.42352942;0.61596638;0.56008404;0.59243703;0.72773105;0.56008404;
0.36764705;0.47941178;0.67184871;0.89537805;0.47941178;0.78361338;0.61596638;0.7042017;0.78361338;0.61596638;
0.47941178;0.36764705;0.28067228;0.33655462;0.98235285;0.28067228;0.44831935;0.4806723;0.33655462;0.28067228;
0.42352942;0.59117651;0.61596638;0.72773105;0.42352942;0.89537805;0.61596638;0.64831936;0.78361338;0.61596638;
0.59117651;0.59117651;0.56008404;0.61596638;0.59117651;0.67184871;0.89537805;0.4806723;0.72773105;0.44831935;
0.31176472;0.36764705;0.39243698;0.50420171;0.42352942;0.44831935;0.28067228;0.8718487;0.39243698;0.39243698;
0.53529412;0.53529412;0.72773105;0.78361338;0.47941178;0.83949572;0.72773105;0.59243703;1.0071428;0.72773105;
0.59117651;0.47941178;0.56008404;0.61596638;0.42352942;0.61596638;0.44831935;0.59243703;0.72773105;0.89537805;
       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    SimpleMathSpec @[1] {name="thresh_smspec": opr=THRESH: arg=0.7: lw=0: hi=1: };
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="cluster_data_src";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="datatable to cluster plot";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="ClusterPlotData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[2][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="Binarized_Data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].programs[1].objs[0]$$;
     objs_ptr=1;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="thresh_smspec";
     var_type=T_Object;
     object_type=SimpleMathSpec;
     object_val=.projects[0].programs[1].objs[1]$$;
     objs_ptr=1;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    IfElse @[0] {
     desc=;
     flags=;
     cond {
      expr="cluster_data_src.data.FindName(\"Hidden_act\")";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      DataProcCall @[0] {
       desc=;
       flags=;
       result_var=NULL;
       object_type=taDataProc;
       method=taDataProc::CopyData;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dest";
	 required=1;
	 def_val=;
	 expr {
	  expr="Binarized_Data";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="src";
	 required=1;
	 def_val=;
	 expr {
	  expr="cluster_data_src";
	 };
	};
       };
      };
      DataGenCall @[1] {
       desc=;
       flags=;
       result_var=NULL;
       object_type=taDataGen;
       method=taDataGen::SimpleMath;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="data";
	 required=1;
	 def_val=;
	 expr {
	  expr="Binarized_Data";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="const taString&";
	 name="col_nm";
	 required=1;
	 def_val="\"\"";
	 expr {
	  expr="\"Hidden_act\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_SimpleMathSpec_ref;
	 type="const SimpleMathSpec&";
	 name="math";
	 required=1;
	 def_val=;
	 expr {
	  expr="thresh_smspec";
	 };
	};
       };
      };
      DataAnalCall @[2] {
       desc=;
       flags=;
       result_var=NULL;
       object_type=taDataAnal;
       method=taDataAnal::Cluster;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="clust_data";
	 required=1;
	 def_val=;
	 expr {
	  expr="ClusterPlotData";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="view";
	 required=1;
	 def_val=;
	 expr {
	  expr="true";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="src_data";
	 required=1;
	 def_val=;
	 expr {
	  expr="Binarized_Data";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="const taString&";
	 name="data_col_nm";
	 required=1;
	 def_val=;
	 expr {
	  expr="\"Hidden_act\"";
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="const taString&";
	 name="name_col_nm";
	 required=1;
	 def_val=;
	 expr {
	  expr="\"trial_name\"";
	 };
	};
	ProgArg @[5] {
	 arg_type=taMath::DistMetric;
	 type="taMath::DistMetric";
	 name="metric";
	 required=0;
	 def_val="taMath::EUCLIDIAN";
	 expr {
	  expr="taMath::EUCLIDIAN";
	 };
	};
	ProgArg @[6] {
	 arg_type=bool;
	 type="bool";
	 name="norm";
	 required=0;
	 def_val="false";
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[7] {
	 arg_type=float;
	 type="float";
	 name="tol";
	 required=0;
	 def_val="0.0f";
	 expr {
	  expr=".5f";
	 };
	};
       };
      };
     };
     false_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      DataAnalCall @[0] {
       desc=;
       flags=;
       result_var=NULL;
       object_type=taDataAnal;
       method=taDataAnal::Cluster;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="clust_data";
	 required=1;
	 def_val=;
	 expr {
	  expr="ClusterPlotData";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="view";
	 required=1;
	 def_val=;
	 expr {
	  expr="true";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="src_data";
	 required=1;
	 def_val=;
	 expr {
	  expr="cluster_data_src";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="const taString&";
	 name="data_col_nm";
	 required=1;
	 def_val=;
	 expr {
	  expr="\"Input\"";
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="const taString&";
	 name="name_col_nm";
	 required=1;
	 def_val=;
	 expr {
	  expr="\"Name\"";
	 };
	};
	ProgArg @[5] {
	 arg_type=taMath::DistMetric;
	 type="taMath::DistMetric";
	 name="metric";
	 required=0;
	 def_val="taMath::EUCLIDIAN";
	 expr {
	  expr="taMath::EUCLIDIAN";
	 };
	};
	ProgArg @[6] {
	 arg_type=bool;
	 type="bool";
	 name="norm";
	 required=0;
	 def_val="false";
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[7] {
	 arg_type=float;
	 type="float";
	 name="tol";
	 required=0;
	 def_val="0.0f";
	 expr {
	  expr=".5f";
	 };
	};
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[0][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="biases_on";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="whether to turn on the special bias weights that equalize hidden unit activations, despite differences in bottom-up netinput from input layer, due to differences in number of active units in each digit image";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][0].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=Network::Init_Acts;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=taBase::UpdateAllViews;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="biases_on";
	required=1;
	def_val=;
	expr {
	 expr="biases_on";
	};
       };
      };
      target=.projects[0].programs[0]$$;
      targ_ld_init="*SetBiasWeights*";
     };
     NetCounterInit @[1] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[2] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][0].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[4] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][0].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[5] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][0].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=$.projects[0].programs.gp[0][0].args[1]$;
      index_var=.projects[0].programs.gp[0][0].vars[4]$$;
      order_var=.projects[0].programs.gp[0][0].vars[0]$$;
      order=SEQUENTIAL;
      item_idx_list{ 0;1;2;3;4;5;6;7;8;9;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[6] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][1].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][1].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][1].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=1;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=1;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][5]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[5] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      update_var=.projects[0].programs.gp[0][1].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
      counter=Network::cycle;
      update_after=1;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][4]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][2].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][2].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][2].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
	counter=Network::cycle;
	update_after=1;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      update_var=.projects[0].programs.gp[0][2].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][3].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][4].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][4].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="act";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0.5: lw=0: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="hid_net";
	computed=0;
	object_type=LeabraLayer;
	object=$.projects[0].networks[0].layers[1]$;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][5].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAqAAAAsIAAALlAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="Digit_Network";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=-0.01078028: y=-0.1624029: z=-0.05928138: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=-0.01078028: y=-0.1624029: z=-0.05928138: }: };
	  display=1;
	  lay_mv=0;
	  net_text=0;
	  net_text_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=-0.5: z=0: }: };
	  net_text_rot=0;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[1].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_BOTH;
	  max_size {x=5: y=7: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.03;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="bias.wt";
	    auto_scale=1;
	    min=-9;
	    max=9;
	   };
	   ScaleRange @[3] {
	    name="bias.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;Hidden=0;	  };
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[1][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1.000001: z=1.000001: }: rotate={x=-1.000008: y=0: z=0: rot=0.2240707: }: translate={x=1.154747: y=-0.2802985: z=8.95353e-08: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="trial";
	    m_data=.projects[0].data.gp[1][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[1][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input_act";
	    m_data=.projects[0].data.gp[1][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Hidden_act";
	    m_data=.projects[0].data.gp[1][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="hid_net";
	    m_data=.projects[0].data.gp[1][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1.000001: z=1.000001: }: rotate={x=-1.000008: y=0: z=0: rot=0.2240707: }: translate={x=1.154747: y=-0.2802985: z=8.95353e-08: }: };
	  view_rows=10;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=4: };
	  width=0.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.04: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.8037335: y=0.8665001: z=2.125448: };
	 orient {x=-0.9999991: y=0: z=0: rot=0.2200002: };
	 focal_dist=2.551682;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.4957334: y=0.7148152: z=1.44713: };
	 orient {x=-0.9999991: y=0: z=0: rot=0.2200002: };
	 focal_dist=1.856611;
	};
	T3SavedView @[2] {
	 name="Grid";
	 view_saved=1;
	 pos {x=1.401733: y=0.508072: z=1.148662: };
	 orient {x=-1: y=0: z=0: rot=0.2200002: };
	 focal_dist=1.550772;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="Digits";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0.001574636: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0.001574636: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=1: };
	  width=0.2;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=.projects[0].data.gp[0][1]$$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.311184: y=0.002151445: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.311184: y=0.002151445: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=1: };
	  width=0.2;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[2] {
	  name=;
	  m_data=.projects[0].data.gp[0][2]$$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.626482: y=0.001543311: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][2].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][2].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.626482: y=0.001543311: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=1: };
	  width=0.2;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.413241: y=0.5193474: z=1.407837: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.417837;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="ClusterPlotData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[2][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="X";
	    m_data=.projects[0].data.gp[2][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="Y";
	    m_data=.projects[0].data.gp[2][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="Label";
	    m_data=.projects[0].data.gp[2][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=56: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="X";
	   fixed_range {fix_min=0: min=0: fix_max=1: max=1.626346: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1.626346: };
	   range {min=0: max=1.626346: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Y";
	   fixed_range {fix_min=1: min=0.2: fix_max=1: max=9.8: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0.2: max=9.8: };
	   range {min=0.2: max=9.8: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Label";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=COLOR_AXIS;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="X";
	   fixed_range {fix_min=0: min=0: fix_max=1: max=6.89311: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=6.89311: };
	   range {min=0: max=6.89311: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.4449999: z=1.624621: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.637121;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7285992503166199;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=1;
     val_type_fixed=1;
    };
   };
   name="Localist_Network";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnitSpec_0";
     desc=;
     unique{ opt_thresh;     };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[4]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=6: i=0: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="LeabraConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=1: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LeabraLayerSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="InputLayer";
       desc=;
       unique{ kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=17: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=2: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraBiasSpec @[4] {
     name="LeabraBiasSpec_0";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=5: y=7: z=2: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=5: y=7: n_not_xy=0: n=35: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=5: y=7: n_not_xy=0: n=35: };
     scaled_act_geom {x=5: y=7: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=5: y=7: n_not_xy=0: n=35: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[1].projections[0]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2399128;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.6850266;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[2] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.692467;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[3] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.5313483;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[4] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1683505;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[5] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3111369;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[6] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1850694;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[7] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1058323;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[8] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3359124;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[9] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3049898;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[10] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3063857;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[11] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2410375;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[12] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {12; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2368207;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[13] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {13; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1040505;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[14] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {14; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.6132035;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[15] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {15; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=3: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2360821;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[16] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {16; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=3: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3243079;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[17] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {17; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=3: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.6199615;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[18] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {18; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=3: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.5284551;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[19] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {19; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=3: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2604055;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[20] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {20; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=4: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.5445176;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[21] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {21; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=4: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1139838;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[22] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {22; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=4: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.09595025;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[23] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {23; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=4: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3992063;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[24] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {24; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=4: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.4030842;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[25] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {25; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=5: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.4676903;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[26] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {26; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=5: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2429453;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[27] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {27; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=5: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1718296;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[28] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {28; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=5: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1959625;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[29] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {29; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=5: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.4660803;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[30] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {30; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=6: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1546469;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[31] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {31; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=6: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.5376426;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[32] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {32; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=6: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.767233;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[33] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {33; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=6: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.6831993;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[34] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {34; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=6: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2302217;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.38: max=0.95: max_i=3: };
     acts_m {cmpt=1: avg=0.38: max=0.95: max_i=3: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=17: pct=0.4857143: pct_c=0.5142857: adth_k=8: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0: i_kwta_pt=0: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[0]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Hidden";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=1: z=1: };
     disp_scale=1;
     un_geom {x=5: y=2: n_not_xy=0: n=10: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=5: y=2: n_not_xy=0: n=10: };
     scaled_act_geom {x=5: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1]$$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=5: y=2: n_not_xy=0: n=10: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Zero";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 0; 1; 0; 0; 0; 1; 0; 1; 0; 1; 0; 0; 0; 1; 1; 0; 0; 0; 1; 1; 0; 0; 0; 1; 0; 1; 0; 1; 0; 0; 0; 1; 0; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {7; };
       };
       n_recv_cons=35;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.07403586;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="One";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {1; 1; 1; 1; 1; 0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 1; 0; 1; 0; 0; 0; 1; 1; 0; 0; 0; 0; 1; 0; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {7; };
       };
       n_recv_cons=35;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.08220694;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[2] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Two";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {1; 1; 1; 1; 1; 1; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 1; 0; 0; 0; 0; 0; 1; 1; 0; 0; 0; 1; 0; 1; 1; 1; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.08666485;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[3] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Three";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 1; 1; 0; 1; 0; 0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 1; 1; 0; 0; 0; 0; 1; 0; 1; 0; 0; 0; 1; 0; 1; 1; 1; 1; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1004838;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[4] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Four";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 0; 0; 1; 0; 0; 0; 0; 1; 0; 1; 1; 1; 1; 1; 1; 0; 0; 1; 0; 0; 1; 0; 1; 0; 0; 0; 1; 1; 0; 0; 0; 0; 1; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {7; };
       };
       n_recv_cons=35;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.08353955;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[5] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Five";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 1; 1; 0; 1; 0; 0; 0; 1; 0; 0; 0; 0; 1; 0; 1; 1; 1; 0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 1; 1; 1; 1; 1; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=0: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1358814;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[6] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Six";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 1; 1; 0; 1; 0; 0; 0; 1; 1; 1; 0; 0; 1; 1; 0; 1; 1; 0; 1; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 1; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=1: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.07849658;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[7] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Seven";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 1; 1; 1; 1; 1; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {9; };
       };
       n_recv_cons=35;
       pos {x=2: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.07135852;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[8] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Eight";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 1; 1; 0; 1; 0; 0; 0; 1; 1; 0; 0; 0; 1; 0; 1; 1; 1; 0; 1; 0; 0; 0; 1; 1; 0; 0; 0; 1; 0; 1; 1; 1; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=3: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1238808;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[9] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="Nine";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 35;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; };
	 wt = {0; 1; 1; 0; 0; 0; 0; 0; 1; 0; 0; 0; 0; 0; 1; 0; 1; 1; 0; 1; 1; 0; 0; 1; 1; 1; 0; 0; 0; 1; 0; 1; 1; 1; 0; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {2; };
       };
       n_recv_cons=35;
       pos {x=4: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.1584773;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="Zero";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.09191494: max=0.9191494: max_i=4: };
     acts_m {cmpt=1: avg=0.09191494: max=0.9191494: max_i=4: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=2: pct=0.2: pct_c=0.8: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.009329055: i_kwta_pt=0: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=376;
   group_name=;
   trial_name="5";
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=1;
   cur_sum_sse=0;
   avg_sse_n=5;
   cur_cnt_err=0;
   train_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="": start={usr=4057: sys=885: tot=128177587254: }: end={usr=3705: sys=788: tot=128177581318: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=9.004952181121938e+130;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=45;
   n_cons=350;
   max_size {x=5: y=7: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=1;
   time_inc=1;
   cycle_max=30;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=0;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0.001;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=15;
   avg_cycles=15;
   avg_cycles_sum=75;
   avg_cycles_n=5;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0.3555556;
   send_pct_n=16;
   send_pct_tot=45;
   avg_send_pct=0.03037038;
   avg_send_pct_sum=2.511112;
   avg_send_pct_n=76;
   maxda_stopcrit=0.005;
   maxda=0.53275;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
