// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [2] {
    taDoc @[0] { };
    taDoc @[1] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [5] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem @[4] { };
	EditMbrItem_Group @.gp[0] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
      };

      EditMthItem_Group @.mths = [6] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
	EditMthItem @[5] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [6] { 
      DataTable @[0] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[3] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[4] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[5] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
    };
    DataTable_Group @.gp[1] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [9] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [4] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
    };
    DataTable_Group @.gp[2] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [3] {
	  float_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	};
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [2] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [9] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [16] {
	AssignExpr @[0] { };
	Comment @[1] { };
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[3] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	DoneWritingDataRow @[4] { };
	DataGenCall @[5] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	Comment @[6] { };
	MethodCall @[7] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[8] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[9] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[10] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[11] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	MethodCall @[12] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	DoneWritingDataRow @[13] { };
	DataGenCall @[14] { 
	  ProgArg_List @.meth_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	DataProcCall @[15] { 
	  ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [10] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [7] {
	MemberAssign @[0] { };
	MemberAssign @[1] { };
	MemberAssign @[2] { };
	MemberAssign @[3] { };
	MethodCall @[4] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[5] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[6] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
      };
    };
    Program_Group @.gp[0] = [9] { 
      Program @[0] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [6] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	  MemberMethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  ProgramCall @[0] { 
	    ProgArg_List @.prog_args = [0] {
	    };
	  };
	  MemberMethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[4] { };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  AssignExpr @[6] { };
	  WhileLoop @[7] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [10] {
	  MemberMethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetCounterInit @[1] { };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[5] { 
	    ProgEl_List @.loop_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[9] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[4] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  ProgramCall @[5] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [3] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [9] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [4] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  AssignExpr @[3] { };
	  DataVarProg @[4] { };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [4] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [1] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [4] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [3] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[2] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[3] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [5] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraBiasSpec @[4] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
      };

      Layer_Group @.layers = [2] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [25] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [1] {
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
= Hebbian Correlational Learning =

* GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can just always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of the middle '''Panels''' frame.

Our approach toward model learning is based on '''correlations''' in the environment.  These correlations are important, because in general it seems that the world is inhabited by things with relatively stable features (e.g., a tree with branches, mammals with legs, an individual's face with eyes, nose, and mouth, and so on), and these features will be manifest as reliable correlations in the patterns of activity in our sensory inputs.

Figure 4.4 in the textbook shows a simple example of the correlations between the individual pixels (picture elements) that make up the image of a line.  These pixels will all be active together when the line is present in the input, producing a positive correlation in their activities.  This correlation will be reliable (present across many different input images) to the extent that there is something reliable ''in the world'' that tends to produce such lines (e.g., edges of objects).  Further, the parsimony of our model can be enhanced if only the strongest (most reliable) features or components of the correlational structure are extracted.  We will see in the next section how Hebbian learning will cause units to represent the strongest correlations in the environment.

== Initial Observation of Correlational Learning ==

Before delving into a more detailed analysis of Hebbian learning in the next section, we will first explore a simplified example of the case shown in figure 4.4 in a simulation (this corresponds to section 4.3.1 in the textbook).  In this exploration, we will see how a single unit (using a Hebbian learning mechanism that will be explained in detail below) learns to represent the correlations present between the pixels in a line.

You will see a network with a 5x5 input layer and a single receiving hidden unit (figure 4.5 in the textbook), in addition to the usual other windows.  To make things as simple as possible, we will just present a single rightward leaning diagonal line and see what effect the Hebbian learning has on this hidden unit's weights.  Thus, the environment will have these units 100 percent correlated with each other and the firing of the hidden unit, and this extreme strong correlation should be encoded by the effects of the Hebbian learning mechanism on the weights.

First, let's look at the initial weights of this hidden unit.

* Select <code>r.wt</code> in the [[.PanelTab.HebbCorrelNet]] netview control panel and then click on the hidden unit using the red arrow button.

You should see a uniform set of .5 weight values, which provide an \"blank page\" starting point for observing the effects of subsequent learning.

* Then, click back on act, and then do [[.programs.LeabraTrain.Init()|Init]] and [[.programs.LeabraTrain.Run()|Run]] in the [[.PanelTab.ControlPanel]] (click on Yes to Initialize the Weights in the dialog that appears).

You will just see the activation of the right-leaning diagonal line.

* Then, click back on r.wt.

You will see that the unit's weights have learned to represent this line in the environment.  

* Click on <code>Init</code> and <code>Run</code> again.

You can now see the entire progression from the initial weights to the line representation while looking at the weights.

The simple point of this exploration is that Hebbian learning will tend to cause units to represent stable things in the environment.  This is a particularly simple case where there was just a single thing  in the environment, but it serves to convey the point.  

* If you wish to stop now and return at another time, you can close this project first by selecting <code>File->Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File->Quit</code> in the <code>.viewers[0](root) window.</code>

== Thorough Exploration of Hebbian Model Learning ==

This section (corresponding to section 4.6 in the textbook) provides a more detailed exploration of this Hebbian learning model. We see how a single unit learns in response to different patterns of correlation between its activity and a set of input patterns.  This exploration will illustrate how conditionalizing the activity of the receiving unit can shape the resulting weights to emphasize a feature present in only a subset of input patterns.  However, we will find that we need to introduce some additional factors in the learning rule to make this emphasis really effective.  These factors will be even more important for the self-organizing case that is explored in a subsequent section.

As before, we will want to watch the weights of the hidden unit as it learns.

* Select r.wt as the variable to view in the network window, and click on the hidden unit.  Now, click on the [[.T3Tab.Input_Patterns]] tab in the 3D view window to see the input patterns.

You should see that the OneLineEnv_Spec set of input patterns (on the left of the display) has 2 events, one having a right-leaning diagonal line, and the other having a left leaning one.  These are the two sets of correlations that exist in this simple environment.

To keep things simple in this simulation, we will manipulate the percentage of time that the receiving unit is active in conjunction with each of these events to alter the conditional probabilities that drive learning in the CPCA algorithm.  Thus, we are only simulating those events that happen when the receiver is active -- when the receiver is not active, no learning occurs, so we can just ignore all these other events for the present purposes.  As a result, what we think of as conditional probabilities actually appear in the simulation as just plain unconditional probabilities -- we are ignoring everything outside the conditional (where the unit is inactive).  In later simulations, we will explore the more realistic case of multiple receiving units that are activated by different events, and we will see how more plausible ways of conditional probability learning can arise through self-organizing learning.

The <code>frequency</code> column in the input data shows the probabilities or normalized frequencies associated with each event.

You should see that the Right event has frequency 1, and the Left event has frequency 0, indicating that the receiving unit will be active all of the time in conjunction with the right-leaning diagonal line, and none of the time with the left-leaning one (this was the default for the initial exploration from before).

Again, these absolute probabilities of presenting these lines actually correspond to conditional probabilities, because we are ignoring all the other possible cases where the receiving unit is inactive -- we are implicitly conditioning the entire simulation on the receiving unit being active (so that it is indeed always active for every input pattern).

The parameter <code>p_right</code> in the [[.PanelTab.ControlPanel]] determines the frequencies of the events in the environment, with the Right event being set to p_right and Left to 1-p_right.
  
* Set p_right to .7, and hit Apply and then the [[.programs.LeabraTrain.Init()|Init]] button -- you will see the frequency values updated to .7 and .3. Then, go ahead and switch back to viewing the [[.T3Tab.HebbCorrelNet]] view before continuing.
  
Keep in mind as we do these exercises that this single receiving unit will ordinarily just be one of multiple such receiving units looking at the same input patterns.  Thus, we want this unit to specialize on representing one of the correlated features in the environment (i.e., 1 of the 2 lines in this case).  We can manipulate this specialization by making the conditional probabilities weighted more toward one event over the other.

* Now, press the Run button in the control panel.

This will run the network through 25 sets (epochs) of 100 randomly ordered event presentations, with 70 of these presentations being the Right event, and 30 being the Left event (given a p_right value of .7).  The CPCA Hebbian learning rule (equation 4.12 in the textbook) is applied after each event presentation and the weights updated accordingly.  You will see the display of the weights in the network window being updated after each trial.
  
Another way to look at the development of the weights over learning is to use a graph log.

* Select the [[.T3Tab.EpochOutputData]] tab in the right 3D view panel, to reveal a graph log, and then do Init->Run again.

The graph log (figure 4.11 in the textbook) displays the value of one of the weights from a unit in the right-leaning diagonal line (wt_right, in black), and from a unit in the left-leaning diagonal line (wt_left, in red).  You should notice that as learning proceeds, the weights from the units active in the Right event will hover right around .7 (with the exception of the central unit, which is present in both events and will have a weight of around 1), while the weights for the Left event will hover around .3.  Thus, as expected, the CPCA learning rule causes the weights to reflect the conditional probability that the input unit is active given that the receiver was active.  Experiment with different values of p_right, and verify that this holds for all sorts of different probabilities.

=== Learning Rate ===

The parameter <code>lrate</code> in the [[.PanelTab.ControlPanel]], which corresponds to epsilon in the CPCA learning rule (equation 4.12), determines how rapidly the weights are updated after each event.
 
* Change lrate to .1 and then <code>Init->Run</code>.

<hr>

'''Question 4.1 (a)''' ''How does this change in the learning rate affect the general character of the weight updates as displayed in the network window?'' '''(b)''' ''Explain why this happens.'' '''(c)''' ''Explain the relevance (if any) this might have for the importance of integrating over multiple experiences (events) in learning.''

<hr>

* Set the lrate parameter back to .005.

=== Selectivity ===

When you explored different values of p_right previously, you were effectively manipulating how ''selective'' the receiving unit was for one type of event over another.  Thus, you were taking advantage of the conditional aspect of CPCA Hebbian learning by effectively conditionalizing its representation of the input environment.  As we stated earlier, instead of manipulating the frequency with which the two events occurred in the environment, you should think of this as manipulating the frequency with which the receiving unit was co-active with these events, because the receiving unit is always active for these inputs.

Now we want to compare the conditionalizing aspect of CPCA with the unconditional PCA algorithm.  Let's assume that each event Right and Left) has an equal probability of appearing in the environment.  

* Set p_right to .5, Apply, and Init->Run.

This will simulate the effects of a standard (unconditional) form of PCA, where the receiving unit is effectively always on for all the events in the environment (unlike CPCA which can have the receiving unit active only  when just one of the lines is present in the environment).

<hr>

'''Question 4.2 (a)''' ''What result does p_right=.5 lead to for the weights?'' '''(b)''' ''Does this weight pattern suggest the existence of two separate diagonal line features existing in the environment?  Explain your answer.'' '''(c)''' ''How does this compare with the \"blob\" solution for the natural scene images as discussed in Section 4.5 and shown in figure 4.8 in the textbook?''

<hr>

'''Question 4.3 (a)''' ''How would you set p_right to simulate the hidden unit controlled in such a way as to come on only when there is a right-leaning diagonal line in the input, and never for the left one?'' '''(b)''' ''What result does this lead to for the weights?'' '''(c)''' ''Explain why this result might be more informative than the case  explored in the previous question.'' '''(d)''' ''How would you extend the architecture and training of the network to represent this environment of two diagonal lines in a fully satisfactory way? Explain your answer.''

<hr>

The simple environment we have been using so far is not very realistic, because it assumes a one-to-one mapping between input patterns and the categories of features that we would typically want to represent.

* First, change the <code>p_right</code> parameter back to .7. Switch the <code>input_data</code> from <code>OneLineEnv</code> to <code>ThreeLinesEnv</code>  in the [[.PanelTab.ControlPanel]] (and Apply).  Then, click on [[.T3Tab.Input_Patterns]] in the right 3D view panel to view these input patterns.

Notice that there are now three different versions of both the left and right diagonal lines, with upper and lower diagonals in addition to the original two center diagonal lines.  In this environment, p_right is spread among all three types of right lines, which are conceived of as mere subtypes of the more general category of right lines (and likewise for 1-p_right and the left lines).  This is reflected in the frequency column as you can see.

* Go ahead and Init->Run this environment, while looking back at the network view r.wt weights.

<em> '''Software Hint:''' To making viewing of the weight values for each unit easier in this exercise, you can use the <code>Rotx</code> tool in the bottom left corner of the [[.T3Tab.HebbCorrelNet]] tab (far right frame) to rotate the network so as to better \"line up\" the <code>r.wt</code> values with its corresponding unit. </em>

When done training, you should see that the five center units end up with weights of .3333 or so (.2333 + .1), while the other right line units end up with weights of around .2333 and the left ones are around .1.  Although this is the correct result for representing the conditional probabilities, this result illustrates a couple of problems with the CPCA learning algorithm.  First, when units represent categories of features instead of single instances, the weights end up being ''diluted'' because the receiving unit is active for several different input patterns, so the conditional probabilities for each individual pattern can be relatively small.  Second, this dilution can be compounded by a receiving unit that has somewhat less than perfect selectivity for one category of features (right) over others (left), resulting in relatively small differences in weight magnitude (e.g., .233 for right versus .1 for left).  This is a real problem because units are generally not very selective during the crucial early phases of learning for reasons that will become clear later.

Thus, in some sense, the CPCA algorithm is ''too faithful'' to the actual conditional probabilities, and does not do enough to emphasize the selectivity of the receiving unit.  Also, these small overall weight values reduce the ''dynamic range'' of the weights, and end up being inconsistent with the weight values produced by the task learning algorithm described in chapter 5.  The next section in the textbook shows how we can deal with these limitations of the basic CPCA rule.  After that, we will revisit this simulation.

* If you wish to stop now and return at another time, you can close this project first by selecting <code>File->Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File->Quit</code> in the <code>.viewers[0](root) window.</code>

== Renormalization and Contrast Enhancement in CPCA ==

This section corresponds to section 4.7.3 in the textbook, where we explore the effects of renormalization and contrast enhancment on Hebbian learning.

We are first going to explore the ''renormalization'' of the weights by taking into account the expected activity level over the input layer, alpha.  Because most of our line stimuli have 5 units active, and there are 25 units in the input layer, this alpha value is set to .2.  Let's explore this issue using an environment where the features have zero correlation with the receiving unit, and see how the renormalization results in weight values of .5 for this case.

* Set input_data in the control panel to FiveHorizLines (Apply).  Click on [[.T3Tab.Input_Patterns]] to see these patterns.

You should see that the environment contains 5 horizontal lines, each of which is presented with equal probability (i.e., 1/5 or .2).  Thus, these line features represent the zero correlation case, because they each co-occur with the receiving unit with the same probability as the expected activity level over the input layer (.2).  In other words, you would expect this same level of co-occurrence if you simply activated input units at random such that the overall activity level on the input was at .2.

* Click on r.wt in the [[.T3Tab.HebbCorrelNet]] panel (and select the  hidden unit), and then [[.programs.LeabraTrain.Init()|Init]] and [[.programs.LeabraTrain.Run()|Run]] the network.

You will see that because of the very literal behavior of the unmodified CPCA algorithm in reflecting the conditional probabilities, the weights are all around .2 at the end of learning.  Thus, if we were interpreting these weights in terms of the standard meaning of conditional probabilities (i.e., where .5 represents zero
correlation), we would conclude that the input units are anticorrelated with the receiving unit.  However, we know that this is not correct given the sparse activity levels in the input.

* Now, set savg_cor.cor (which is the q_m parameter in equation 4.20 in the textbook) in the [[.PanelTab.ControlPanel]] to a value of 1 instead of 0.

This means that we will now be applying the full correction for the average activity level in the sending (input) layer.  

* Run the network again.

You should observe that the weights now hover around .5, which is the correct value for expressing the lack of correlation.

Although the ability to fully correct for sparse sending activations is useful, one does not always want to do this.  In particular, if we have any prior expectation about how many individual input patterns should be represented by a given hidden unit, then we can set savg_cor.cor appropriately so that the .5 level corresponds roughly to this prior expectation.  For example, if we know that the units should have relatively ''selective'' representations (e.g., one or two input features per unit), then we might want to set savg_cor.cor to .5 or even less, because the full correction for the input layer alpha will result in larger weights for features that are relatively weakly correlated compared to this expected level of selectivity.  If units are expected to represent a number of input features, then a value of savg_cor.cor closer to 1 is more appropriate.  We will revisit this issue.

Now, let's explore the contrast enhancement sigmoid function of the effective weights.  The parameters wt_sig.gain and .off in the control panel control the gain and offset of the sigmoid function.  First, we will plot the shape of the contrast enhancement function for different values of these parameters.

* First set wt_sig.gain to 6 instead of 1.  Click the <code>Graph Wt Sig Fun</code> button in the control panel, keep the graph_data value in the popup dialog at New Graph Data, which will bring up a new graph view in a new tab in the 3D view area.

You should see a sigmoidal function (the shape of the resulting effective weights function) plotted.  The horizontal axis, Wt, represents the raw linear weight value, and the vertical axis, Sig Wt, represents the contrast enhanced effective weight value.  The increase in wt_sig.gain results in substantial contrast enhancement.

* Try setting wt_sig.gain to various different values, and then clicking the <code>Graph Wt Sig Fun</code> button again. 

<em>'''Software Hint:''' For these subsequent graphs, you can select <code>LeabraConSpec_0_WtSigFun</code> for the graph_data value in the dialog box that comes up (instead of leaving it New Graph Data) and it will just update the existing graph instead of making a new one).  This should give you a good sense of its effect on the shape of this function.</em>

We next see the effects of wt_sig.gain on learning. You will again want to be watching the <code>r.wt</code> values in the [[.T3Tab.HebbCorrelNet]] tab (far right frame).

* First, hit the Defaults button in the [[.PanelTab.ControlPanel]], then change p_right to .7, savg_cor.cor to 1, and set the input_data to ThreeLinesEnv. Now do <code>Init->Run</code>.

This run provides a baseline for comparison.  You should see a somewhat bloblike representation in the weights of the network, where the right lines are a bit more strong than the left lines, but not dramatically so.  

* Now increase wt_sig.gain from 1 to 6, and Run again.

You should very clearly see that only the right lines are represented, and with relatively strong weights.  Thus, the contrast enhancement allows the network to represent the reality of the distinct underlying left and right categories of features even when it is imperfectly selective (.7) to these features.  This effect will be especially important for self-organizing learning, as we will see in the next project.

Now, let's use the wt_sig.off parameter to encourage the network to pay attention to only the ''strongest'' of correlations in the input.  

* Leaving wt_sig.gain at 6, change wt_sig.off to 1.25, and (with the [[.T3Tab.LeabraConSpec_0_WtSigFun]] tab showing in the far right frame)  do <code>Graph Wt Sig Fun</code> to see how this affects the effective weight function.  You may have to go back and forth between 1 and 1.25 a couple of times to be able to see the difference -- it is more subtle than the gain parameter.

* With wt_sig.off set to 1.25, Run the network (with the [[.T3Tab.HebbCorrelNet]] tab active).

<hr>

'''Question 4.4 (a)''' ''How does this change the results compared to the case where wt_sig.off is 1?'' '''(b)''' ''Explain why this occurs.'' '''(c)''' ''Find a value of wt_sig.off that makes the non-central (non-overlapping) units of the right lines (i.e., the 4 units in the lower left corner and the 4 units in the upper right corner) have weights around .1 or less.'' '''(d)''' ''Do the resulting weights accurately reflect the correlations present in any single input pattern?  Explain your answer.'' '''(e)''' ''Can you imagine why this representation might be useful in some cases?''

<hr>

An alternative way to accomplish some of the effects of the wt_sig.off parameter is to set the savg_cor.cor parameter to a value of less than 1.  As described above, this will make the units more ''selective'' because weak correlations will not be renormalized to as high a weight value.

* Set wt_sig.off back to 1, and set savg_cor.cor to .7.

<hr>

'''Question 4.5 (a)''' ''What effect does this have on the learned weight values?'' '''(b)''' ''How does this compare with the wt_sig.off parameter you found in the previous question?''

<hr>

This last question shows that because the contrast enhancement from wt_sig.gain magnifies differences around .5 (with wt_sig.off=1), the savg_cor.cor can have a big effect by changing the amount of correlated activity necessary to achieve this .5 value.  A lower savg_cor.cor will result in smaller weight values for more weakly correlated inputs -- when the wt_sig.gain parameter is large, then these smaller values get pushed down toward zero, causing the unit to essentially ignore these inputs.  Thus, these interactions between contrast enhancement and renormalization can play an important role in determining what the unit tends to detect.

These simulations demonstrate how the correction factors of renormalization and contrast enhancement can increase the effectiveness of the CPCA algorithm.  These correction factors represent quantitative adjustments to the CPCA algorithm to address its limitations of dynamic range and selectivity, while preserving the basic computation performed by the algorithm to stay true to its biological and computational motivations.  

* To continue on to the next simulation, close this project first by selecting <code>File->Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Or, if you wish to stop now, quit by then selecting <code>File->Quit</code> in the <code>.viewers[0](root) window.

</body>
</html>
";
   html_text="<html><head></head><body>
<h1> Hebbian Correlational Learning </h1>
<p>
</p><ul><li> GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can just always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of the middle  <b>Panels</b>  frame.
</li></ul>
Our approach toward model learning is based on  <b>correlations</b>  in the environment.  These correlations are important, because in general it seems that the world is inhabited by things with relatively stable features (e.g., a tree with branches, mammals with legs, an individual's face with eyes, nose, and mouth, and so on), and these features will be manifest as reliable correlations in the patterns of activity in our sensory inputs.
<p>
Figure 4.4 in the textbook shows a simple example of the correlations between the individual pixels (picture elements) that make up the image of a line.  These pixels will all be active together when the line is present in the input, producing a positive correlation in their activities.  This correlation will be reliable (present across many different input images) to the extent that there is something reliable  <i>in the world</i>  that tends to produce such lines (e.g., edges of objects).  Further, the parsimony of our model can be enhanced if only the strongest (most reliable) features or components of the correlational structure are extracted.  We will see in the next section how Hebbian learning will cause units to represent the strongest correlations in the environment.
</p><p>
</p><h2> Initial Observation of Correlational Learning </h2>
<p>
Before delving into a more detailed analysis of Hebbian learning in the next section, we will first explore a simplified example of the case shown in figure 4.4 in a simulation (this corresponds to section 4.3.1 in the textbook).  In this exploration, we will see how a single unit (using a Hebbian learning mechanism that will be explained in detail below) learns to represent the correlations present between the pixels in a line.
</p><p>
You will see a network with a 5x5 input layer and a single receiving hidden unit (figure 4.5 in the textbook), in addition to the usual other windows.  To make things as simple as possible, we will just present a single rightward leaning diagonal line and see what effect the Hebbian learning has on this hidden unit's weights.  Thus, the environment will have these units 100 percent correlated with each other and the firing of the hidden unit, and this extreme strong correlation should be encoded by the effects of the Hebbian learning mechanism on the weights.
</p><p>
First, let's look at the initial weights of this hidden unit.
</p><p>
</p><ul><li> Select <code>r.wt</code> in the <a href=\"ta:.PanelTab.HebbCorrelNet\">HebbCorrelNet</a> netview control panel and then click on the hidden unit using the red arrow button.
</li></ul>
You should see a uniform set of .5 weight values, which provide an \"blank page\" starting point for observing the effects of subsequent learning.
<p>
</p><ul><li> Then, click back on act, and then do <a href=\"ta:.programs.LeabraTrain.Init()\">Init</a> and <a href=\"ta:.programs.LeabraTrain.Run()\">Run</a> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> (click on Yes to Initialize the Weights in the dialog that appears).
</li></ul>
You will just see the activation of the right-leaning diagonal line.
<p>
</p><ul><li> Then, click back on r.wt.
</li></ul>
You will see that the unit's weights have learned to represent this line in the environment.  
<p>
</p><ul><li> Click on <code>Init</code> and <code>Run</code> again.
</li></ul>
You can now see the entire progression from the initial weights to the line representation while looking at the weights.
<p>
The simple point of this exploration is that Hebbian learning will tend to cause units to represent stable things in the environment.  This is a particularly simple case where there was just a single thing  in the environment, but it serves to convey the point.  
</p><p>
</p><ul><li> If you wish to stop now and return at another time, you can close this project first by selecting <code>File-&gt;Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File-&gt;Quit</code> in the <code>.viewers[0](root) window.</code>
</li></ul>
<h2> Thorough Exploration of Hebbian Model Learning </h2>
<p>
This section (corresponding to section 4.6 in the textbook) provides a more detailed exploration of this Hebbian learning model. We see how a single unit learns in response to different patterns of correlation between its activity and a set of input patterns.  This exploration will illustrate how conditionalizing the activity of the receiving unit can shape the resulting weights to emphasize a feature present in only a subset of input patterns.  However, we will find that we need to introduce some additional factors in the learning rule to make this emphasis really effective.  These factors will be even more important for the self-organizing case that is explored in a subsequent section.
</p><p>
As before, we will want to watch the weights of the hidden unit as it learns.
</p><p>
</p><ul><li> Select r.wt as the variable to view in the network window, and click on the hidden unit.  Now, click on the <a href=\"ta:.T3Tab.Input_Patterns\">Input_Patterns</a> tab in the 3D view window to see the input patterns.
</li></ul>
You should see that the OneLineEnv_Spec set of input patterns (on the left of the display) has 2 events, one having a right-leaning diagonal line, and the other having a left leaning one.  These are the two sets of correlations that exist in this simple environment.
<p>
To keep things simple in this simulation, we will manipulate the percentage of time that the receiving unit is active in conjunction with each of these events to alter the conditional probabilities that drive learning in the CPCA algorithm.  Thus, we are only simulating those events that happen when the receiver is active -- when the receiver is not active, no learning occurs, so we can just ignore all these other events for the present purposes.  As a result, what we think of as conditional probabilities actually appear in the simulation as just plain unconditional probabilities -- we are ignoring everything outside the conditional (where the unit is inactive).  In later simulations, we will explore the more realistic case of multiple receiving units that are activated by different events, and we will see how more plausible ways of conditional probability learning can arise through self-organizing learning.
</p><p>
The <code>frequency</code> column in the input data shows the probabilities or normalized frequencies associated with each event.
</p><p>
You should see that the Right event has frequency 1, and the Left event has frequency 0, indicating that the receiving unit will be active all of the time in conjunction with the right-leaning diagonal line, and none of the time with the left-leaning one (this was the default for the initial exploration from before).
</p><p>
Again, these absolute probabilities of presenting these lines actually correspond to conditional probabilities, because we are ignoring all the other possible cases where the receiving unit is inactive -- we are implicitly conditioning the entire simulation on the receiving unit being active (so that it is indeed always active for every input pattern).
</p><p>
The parameter <code>p_right</code> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> determines the frequencies of the events in the environment, with the Right event being set to p_right and Left to 1-p_right.
  
</p><ul><li> Set p_right to .7, and hit Apply and then the <a href=\"ta:.programs.LeabraTrain.Init()\">Init</a> button -- you will see the frequency values updated to .7 and .3. Then, go ahead and switch back to viewing the <a href=\"ta:.T3Tab.HebbCorrelNet\">HebbCorrelNet</a> view before continuing.
  </li></ul>
Keep in mind as we do these exercises that this single receiving unit will ordinarily just be one of multiple such receiving units looking at the same input patterns.  Thus, we want this unit to specialize on representing one of the correlated features in the environment (i.e., 1 of the 2 lines in this case).  We can manipulate this specialization by making the conditional probabilities weighted more toward one event over the other.
<p>
</p><ul><li> Now, press the Run button in the control panel.
</li></ul>
This will run the network through 25 sets (epochs) of 100 randomly ordered event presentations, with 70 of these presentations being the Right event, and 30 being the Left event (given a p_right value of .7).  The CPCA Hebbian learning rule (equation 4.12 in the textbook) is applied after each event presentation and the weights updated accordingly.  You will see the display of the weights in the network window being updated after each trial.
  
Another way to look at the development of the weights over learning is to use a graph log.
<p>
</p><ul><li> Select the <a href=\"ta:.T3Tab.EpochOutputData\">EpochOutputData</a> tab in the right 3D view panel, to reveal a graph log, and then do Init-&gt;Run again.
</li></ul>
The graph log (figure 4.11 in the textbook) displays the value of one of the weights from a unit in the right-leaning diagonal line (wt_right, in black), and from a unit in the left-leaning diagonal line (wt_left, in red).  You should notice that as learning proceeds, the weights from the units active in the Right event will hover right around .7 (with the exception of the central unit, which is present in both events and will have a weight of around 1), while the weights for the Left event will hover around .3.  Thus, as expected, the CPCA learning rule causes the weights to reflect the conditional probability that the input unit is active given that the receiver was active.  Experiment with different values of p_right, and verify that this holds for all sorts of different probabilities.
<p>
</p><h3> Learning Rate </h3>
<p>
The parameter <code>lrate</code> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>, which corresponds to epsilon in the CPCA learning rule (equation 4.12), determines how rapidly the weights are updated after each event.
 
</p><ul><li> Change lrate to .1 and then <code>Init-&gt;Run</code>.
</li></ul>
<hr>
<p>
 <b>Question 4.1 (a)</b>   <i>How does this change in the learning rate affect the general character of the weight updates as displayed in the network window?</i>   <b>(b)</b>   <i>Explain why this happens.</i>   <b>(c)</b>   <i>Explain the relevance (if any) this might have for the importance of integrating over multiple experiences (events) in learning.</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Set the lrate parameter back to .005.
</li></ul>
<h3> Selectivity </h3>
<p>
When you explored different values of p_right previously, you were effectively manipulating how  <i>selective</i>  the receiving unit was for one type of event over another.  Thus, you were taking advantage of the conditional aspect of CPCA Hebbian learning by effectively conditionalizing its representation of the input environment.  As we stated earlier, instead of manipulating the frequency with which the two events occurred in the environment, you should think of this as manipulating the frequency with which the receiving unit was co-active with these events, because the receiving unit is always active for these inputs.
</p><p>
Now we want to compare the conditionalizing aspect of CPCA with the unconditional PCA algorithm.  Let's assume that each event Right and Left) has an equal probability of appearing in the environment.  
</p><p>
</p><ul><li> Set p_right to .5, Apply, and Init-&gt;Run.
</li></ul>
This will simulate the effects of a standard (unconditional) form of PCA, where the receiving unit is effectively always on for all the events in the environment (unlike CPCA which can have the receiving unit active only  when just one of the lines is present in the environment).
<p>
</p><hr>
<p>
 <b>Question 4.2 (a)</b>   <i>What result does p_right=.5 lead to for the weights?</i>   <b>(b)</b>   <i>Does this weight pattern suggest the existence of two separate diagonal line features existing in the environment?  Explain your answer.</i>   <b>(c)</b>   <i>How does this compare with the \"blob\" solution for the natural scene images as discussed in Section 4.5 and shown in figure 4.8 in the textbook?</i> 
</p><p>
</p><hr>
<p>
 <b>Question 4.3 (a)</b>   <i>How would you set p_right to simulate the hidden unit controlled in such a way as to come on only when there is a right-leaning diagonal line in the input, and never for the left one?</i>   <b>(b)</b>   <i>What result does this lead to for the weights?</i>   <b>(c)</b>   <i>Explain why this result might be more informative than the case  explored in the previous question.</i>   <b>(d)</b>   <i>How would you extend the architecture and training of the network to represent this environment of two diagonal lines in a fully satisfactory way? Explain your answer.</i> 
</p><p>
</p><hr>
<p>
The simple environment we have been using so far is not very realistic, because it assumes a one-to-one mapping between input patterns and the categories of features that we would typically want to represent.
</p><p>
</p><ul><li> First, change the <code>p_right</code> parameter back to .7. Switch the <code>input_data</code> from <code>OneLineEnv</code> to <code>ThreeLinesEnv</code>  in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> (and Apply).  Then, click on <a href=\"ta:.T3Tab.Input_Patterns\">Input_Patterns</a> in the right 3D view panel to view these input patterns.
</li></ul>
Notice that there are now three different versions of both the left and right diagonal lines, with upper and lower diagonals in addition to the original two center diagonal lines.  In this environment, p_right is spread among all three types of right lines, which are conceived of as mere subtypes of the more general category of right lines (and likewise for 1-p_right and the left lines).  This is reflected in the frequency column as you can see.
<p>
</p><ul><li> Go ahead and Init-&gt;Run this environment, while looking back at the network view r.wt weights.
</li></ul>
<em>  <b>Software Hint:</b>  To making viewing of the weight values for each unit easier in this exercise, you can use the <code>Rotx</code> tool in the bottom left corner of the <a href=\"ta:.T3Tab.HebbCorrelNet\">HebbCorrelNet</a> tab (far right frame) to rotate the network so as to better \"line up\" the <code>r.wt</code> values with its corresponding unit. </em>
<p>
When done training, you should see that the five center units end up with weights of .3333 or so (.2333 + .1), while the other right line units end up with weights of around .2333 and the left ones are around .1.  Although this is the correct result for representing the conditional probabilities, this result illustrates a couple of problems with the CPCA learning algorithm.  First, when units represent categories of features instead of single instances, the weights end up being  <i>diluted</i>  because the receiving unit is active for several different input patterns, so the conditional probabilities for each individual pattern can be relatively small.  Second, this dilution can be compounded by a receiving unit that has somewhat less than perfect selectivity for one category of features (right) over others (left), resulting in relatively small differences in weight magnitude (e.g., .233 for right versus .1 for left).  This is a real problem because units are generally not very selective during the crucial early phases of learning for reasons that will become clear later.
</p><p>
Thus, in some sense, the CPCA algorithm is  <i>too faithful</i>  to the actual conditional probabilities, and does not do enough to emphasize the selectivity of the receiving unit.  Also, these small overall weight values reduce the  <i>dynamic range</i>  of the weights, and end up being inconsistent with the weight values produced by the task learning algorithm described in chapter 5.  The next section in the textbook shows how we can deal with these limitations of the basic CPCA rule.  After that, we will revisit this simulation.
</p><p>
</p><ul><li> If you wish to stop now and return at another time, you can close this project first by selecting <code>File-&gt;Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File-&gt;Quit</code> in the <code>.viewers[0](root) window.</code>
</li></ul>
<h2> Renormalization and Contrast Enhancement in CPCA </h2>
<p>
This section corresponds to section 4.7.3 in the textbook, where we explore the effects of renormalization and contrast enhancment on Hebbian learning.
</p><p>
We are first going to explore the  <i>renormalization</i>  of the weights by taking into account the expected activity level over the input layer, alpha.  Because most of our line stimuli have 5 units active, and there are 25 units in the input layer, this alpha value is set to .2.  Let's explore this issue using an environment where the features have zero correlation with the receiving unit, and see how the renormalization results in weight values of .5 for this case.
</p><p>
</p><ul><li> Set input_data in the control panel to FiveHorizLines (Apply).  Click on <a href=\"ta:.T3Tab.Input_Patterns\">Input_Patterns</a> to see these patterns.
</li></ul>
You should see that the environment contains 5 horizontal lines, each of which is presented with equal probability (i.e., 1/5 or .2).  Thus, these line features represent the zero correlation case, because they each co-occur with the receiving unit with the same probability as the expected activity level over the input layer (.2).  In other words, you would expect this same level of co-occurrence if you simply activated input units at random such that the overall activity level on the input was at .2.
<p>
</p><ul><li> Click on r.wt in the <a href=\"ta:.T3Tab.HebbCorrelNet\">HebbCorrelNet</a> panel (and select the  hidden unit), and then <a href=\"ta:.programs.LeabraTrain.Init()\">Init</a> and <a href=\"ta:.programs.LeabraTrain.Run()\">Run</a> the network.
</li></ul>
You will see that because of the very literal behavior of the unmodified CPCA algorithm in reflecting the conditional probabilities, the weights are all around .2 at the end of learning.  Thus, if we were interpreting these weights in terms of the standard meaning of conditional probabilities (i.e., where .5 represents zero
correlation), we would conclude that the input units are anticorrelated with the receiving unit.  However, we know that this is not correct given the sparse activity levels in the input.
<p>
</p><ul><li> Now, set savg_cor.cor (which is the q_m parameter in equation 4.20 in the textbook) in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> to a value of 1 instead of 0.
</li></ul>
This means that we will now be applying the full correction for the average activity level in the sending (input) layer.  
<p>
</p><ul><li> Run the network again.
</li></ul>
You should observe that the weights now hover around .5, which is the correct value for expressing the lack of correlation.
<p>
Although the ability to fully correct for sparse sending activations is useful, one does not always want to do this.  In particular, if we have any prior expectation about how many individual input patterns should be represented by a given hidden unit, then we can set savg_cor.cor appropriately so that the .5 level corresponds roughly to this prior expectation.  For example, if we know that the units should have relatively  <i>selective</i>  representations (e.g., one or two input features per unit), then we might want to set savg_cor.cor to .5 or even less, because the full correction for the input layer alpha will result in larger weights for features that are relatively weakly correlated compared to this expected level of selectivity.  If units are expected to represent a number of input features, then a value of savg_cor.cor closer to 1 is more appropriate.  We will revisit this issue.
</p><p>
Now, let's explore the contrast enhancement sigmoid function of the effective weights.  The parameters wt_sig.gain and .off in the control panel control the gain and offset of the sigmoid function.  First, we will plot the shape of the contrast enhancement function for different values of these parameters.
</p><p>
</p><ul><li> First set wt_sig.gain to 6 instead of 1.  Click the <code>Graph Wt Sig Fun</code> button in the control panel, keep the graph_data value in the popup dialog at New Graph Data, which will bring up a new graph view in a new tab in the 3D view area.
</li></ul>
You should see a sigmoidal function (the shape of the resulting effective weights function) plotted.  The horizontal axis, Wt, represents the raw linear weight value, and the vertical axis, Sig Wt, represents the contrast enhanced effective weight value.  The increase in wt_sig.gain results in substantial contrast enhancement.
<p>
</p><ul><li> Try setting wt_sig.gain to various different values, and then clicking the <code>Graph Wt Sig Fun</code> button again. 
</li></ul>
<em> <b>Software Hint:</b>  For these subsequent graphs, you can select <code>LeabraConSpec_0_WtSigFun</code> for the graph_data value in the dialog box that comes up (instead of leaving it New Graph Data) and it will just update the existing graph instead of making a new one).  This should give you a good sense of its effect on the shape of this function.</em>
<p>
We next see the effects of wt_sig.gain on learning. You will again want to be watching the <code>r.wt</code> values in the <a href=\"ta:.T3Tab.HebbCorrelNet\">HebbCorrelNet</a> tab (far right frame).
</p><p>
</p><ul><li> First, hit the Defaults button in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>, then change p_right to .7, savg_cor.cor to 1, and set the input_data to ThreeLinesEnv. Now do <code>Init-&gt;Run</code>.
</li></ul>
This run provides a baseline for comparison.  You should see a somewhat bloblike representation in the weights of the network, where the right lines are a bit more strong than the left lines, but not dramatically so.  
<p>
</p><ul><li> Now increase wt_sig.gain from 1 to 6, and Run again.
</li></ul>
You should very clearly see that only the right lines are represented, and with relatively strong weights.  Thus, the contrast enhancement allows the network to represent the reality of the distinct underlying left and right categories of features even when it is imperfectly selective (.7) to these features.  This effect will be especially important for self-organizing learning, as we will see in the next project.
<p>
Now, let's use the wt_sig.off parameter to encourage the network to pay attention to only the  <i>strongest</i>  of correlations in the input.  
</p><p>
</p><ul><li> Leaving wt_sig.gain at 6, change wt_sig.off to 1.25, and (with the <a href=\"ta:.T3Tab.LeabraConSpec_0_WtSigFun\">LeabraConSpec_0_WtSigFun</a> tab showing in the far right frame)  do <code>Graph Wt Sig Fun</code> to see how this affects the effective weight function.  You may have to go back and forth between 1 and 1.25 a couple of times to be able to see the difference -- it is more subtle than the gain parameter.
</li></ul>
<ul><li> With wt_sig.off set to 1.25, Run the network (with the <a href=\"ta:.T3Tab.HebbCorrelNet\">HebbCorrelNet</a> tab active).
</li></ul>
<hr>
<p>
 <b>Question 4.4 (a)</b>   <i>How does this change the results compared to the case where wt_sig.off is 1?</i>   <b>(b)</b>   <i>Explain why this occurs.</i>   <b>(c)</b>   <i>Find a value of wt_sig.off that makes the non-central (non-overlapping) units of the right lines (i.e., the 4 units in the lower left corner and the 4 units in the upper right corner) have weights around .1 or less.</i>   <b>(d)</b>   <i>Do the resulting weights accurately reflect the correlations present in any single input pattern?  Explain your answer.</i>   <b>(e)</b>   <i>Can you imagine why this representation might be useful in some cases?</i> 
</p><p>
</p><hr>
<p>
An alternative way to accomplish some of the effects of the wt_sig.off parameter is to set the savg_cor.cor parameter to a value of less than 1.  As described above, this will make the units more  <i>selective</i>  because weak correlations will not be renormalized to as high a weight value.
</p><p>
</p><ul><li> Set wt_sig.off back to 1, and set savg_cor.cor to .7.
</li></ul>
<hr>
<p>
 <b>Question 4.5 (a)</b>   <i>What effect does this have on the learned weight values?</i>   <b>(b)</b>   <i>How does this compare with the wt_sig.off parameter you found in the previous question?</i> 
</p><p>
</p><hr>
<p>
This last question shows that because the contrast enhancement from wt_sig.gain magnifies differences around .5 (with wt_sig.off=1), the savg_cor.cor can have a big effect by changing the amount of correlated activity necessary to achieve this .5 value.  A lower savg_cor.cor will result in smaller weight values for more weakly correlated inputs -- when the wt_sig.gain parameter is large, then these smaller values get pushed down toward zero, causing the unit to essentially ignore these inputs.  Thus, these interactions between contrast enhancement and renormalization can play an important role in determining what the unit tends to detect.
</p><p>
These simulations demonstrate how the correction factors of renormalization and contrast enhancement can increase the effectiveness of the CPCA algorithm.  These correction factors represent quantitative adjustments to the CPCA algorithm to address its limitations of dynamic range and selectivity, while preserving the basic computation performed by the algorithm to stay true to its biological and computational motivations.  
</p><p>
</p><ul><li> To continue on to the next simulation, close this project first by selecting <code>File-&gt;Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Or, if you wish to stop now, quit by then selecting <code>File-&gt;Quit</code> in the <code>.viewers[0](root) window.
</code></li></ul><code>


</code></body></html>";
  };
  taDoc @[1] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Hebbian_Correlation";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Hebbian_Correlation";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Hebbian Correlation,CECN1 Projects,Emergent,.PanelTab.HebbCorrelNet,.programs.LeabraTrain.Init(),.programs.LeabraTrain.Run(),.PanelTab.ControlPanel,.T3Tab.Input Patterns,.T3Tab.HebbCorrelNet,.T3Tab.EpochOutputData\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Hebbian Correlation - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Hebbian_Correlation\";
		var wgTitle = \"CECN1 Hebbian Correlation\";
		var wgAction = \"view\";
		var wgArticleId = \"24\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 474;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Hebbian_Correlation skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Hebbian Correlation</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Hebbian_Correlational_Model_Learning\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Hebbian Correlational Model Learning</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Initial_Observation_of_Correlational_Learning\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Initial Observation of Correlational Learning</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Thorough_Exploration_of_Hebbian_Model_Learning\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Thorough Exploration of Hebbian Model Learning</span></a>
<ul>
<li class=\"toclevel-3\"><a href=\"#Learning_Rate\"><span class=\"tocnumber\">2.2.1</span> <span class=\"toctext\">Learning Rate</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Selectivity\"><span class=\"tocnumber\">2.2.2</span> <span class=\"toctext\">Selectivity</span></a></li>
</ul>
</li>
<li class=\"toclevel-2\"><a href=\"#Renormalization_and_Contrast_Enhancement_in_CPCA\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Renormalization and Contrast Enhancement in CPCA</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Hebbian_Correlational_Model_Learning\" id=\"Hebbian_Correlational_Model_Learning\"></a><h1> <span class=\"mw-headline\"> Hebbian Correlational Model Learning </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/1/1c/hebb_correl.proj\" class=\"internal\" title=\"hebb correl.proj\">hebb_correl.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p>Our approach toward model learning is based on <b>correlations</b> in the environment.  These correlations are important, because in general it seems that the world is inhabited by things with relatively stable features (e.g., a tree with branches, mammals with legs, an individual's face with eyes, nose, and mouth, and so on), and these features will be manifest as reliable correlations in the patterns of activity in our sensory inputs.
</p><p>Figure 4.4 in the textbook shows a simple example of the correlations between the individual pixels (picture elements) that make up the image of a line.  These pixels will all be active together when the line is present in the input, producing a positive correlation in their activities.  This correlation will be reliable (present across many different input images) to the extent that there is something reliable {\\em in the world} that tends to produce such lines (e.g., edges of objects).  Further, the parsimony of our model can be enhanced if only the strongest (most reliable) features or components of the correlational structure are extracted.  We will see in the next section how Hebbian learning will cause units to represent the strongest correlations in the environment.
</p>
<a name=\"Initial_Observation_of_Correlational_Learning\" id=\"Initial_Observation_of_Correlational_Learning\"></a><h2> <span class=\"mw-headline\"> Initial Observation of Correlational Learning </span></h2>
<p>Before delving into a more detailed analysis of Hebbian learning in the next section, we will first explore a simplified example of the case shown in figure 4.4 in a simulation (this corresponds to section 4.3.1 in the textbook).  In this exploration, we will see how a single unit (using a Hebbian learning mechanism that will be explained in detail below) learns to represent the correlations present between the pixels in a line.
</p><p>You will see a network with a 5x5 input layer and a single receiving hidden unit (figure 4.5 in the textbook), in addition to the usual other windows.  To make things as simple as possible, we will just present a single rightward leaning diagonal line and see what effect the Hebbian learning has on this hidden unit's weights.  Thus, the environment will have these units 100 percent correlated with each other and the firing of the hidden unit, and this extreme strong correlation should be encoded by the effects of the Hebbian learning mechanism on the weights.
</p><p>First, let's look at the initial weights of this hidden unit.
</p>
<ul><li> Select <code>r.wt</code> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.HebbCorrelNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.HebbCorrelNet (page does not exist)\">.PanelTab.HebbCorrelNet</a> netview control panel and then click on the hidden unit using the red arrow button.
</li></ul>
<p>You should see a uniform set of .5 weight values, which provide an \"blank page\" starting point for observing the effects of subsequent learning.
</p>
<ul><li> Then, click back on act, and then do <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraTrain.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraTrain.Init() (page does not exist)\">Init</a> and <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraTrain.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraTrain.Run() (page does not exist)\">Run</a> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a> (click on Yes to Initialize the Weights in the dialog that appears).
</li></ul>
<p>You will just see the activation of the right-leaning diagonal line.
</p>
<ul><li> Then, click back on r.wt.
</li></ul>
<p>You will see that the unit's weights have learned to represent this line in the environment.  
</p>
<ul><li> Click on \\verb\\Run\\ again.
</li></ul>
<p>You can now see the entire progression from the initial weights to the line representation while looking at the weights.
</p><p>The simple point of this exploration is that Hebbian learning will tend to cause units to represent stable things in the environment.  This is a particularly simple case where there was just a single thing  in the environment, but it serves to convey the point.
</p>
<ul><li> If you wish to stop now and return at another time, you can close this project first by selecting <code>File-&gt;Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File-&gt;Quit</code> in the <code>.viewers[0](root) window.</code>
</li></ul>
<a name=\"Thorough_Exploration_of_Hebbian_Model_Learning\" id=\"Thorough_Exploration_of_Hebbian_Model_Learning\"></a><h2> <span class=\"mw-headline\"> Thorough Exploration of Hebbian Model Learning </span></h2>
<p>This section (corresponding to section 4.6 in the textbook) provides a more detailed exploration of this Hebbian learning model. We see how a single unit learns in response to different patterns of correlation between its activity and a set of input patterns.  This exploration will illustrate how conditionalizing the activity of the receiving unit can shape the resulting weights to emphasize a feature present in only a subset of input patterns.  However, we will find that we need to introduce some additional factors in the learning rule to make this emphasis really effective.  These factors will be even more important for the self-organizing case that is explored in a subsequent section.
</p><p>As before, we will want to watch the weights of the hidden unit as it learns.
</p>
<ul><li> Select r.wt as the variable to view in the network window, and click on the hidden unit.  Now, click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Input_Patterns&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Input Patterns (page does not exist)\">.T3Tab.Input_Patterns</a> tab in the 3D view window to see the input patterns.
</li></ul>
<p>You should see that the OneLineEnv_Spec set of input patterns (on the left of the display) has 2 events, one having a right-leaning diagonal line, and the other having a left leaning one.  These are the two sets of correlations that exist in this simple environment.
</p><p>To keep things simple in this simulation, we will manipulate the percentage of time that the receiving unit is active in conjunction with each of these events to alter the conditional probabilities that drive learning in the CPCA algorithm.  Thus, we are only simulating those events that happen when the receiver is active -- when the receiver is not active, no learning occurs, so we can just ignore all these other events for the present purposes.  As a result, what we think of as conditional probabilities actually appear in the simulation as just plain unconditional probabilities -- we are ignoring everything outside the conditional (where the unit is
inactive).  In later simulations, we will explore the more realistic case of multiple receiving units that are activated by different events, and we will see how more plausible ways of conditional probability learning can arise through self-organizing learning.
</p><p>The <code>frequency</code> column in the input data shows the probabilities or normalized frequencies associated with each event.
</p><p>You should see that the Right event has frequency 1, and the Left event has frequency 0, indicating that the receiving unit will be active all of the time in conjunction with the right-leaning diagonal line, and none of the time with the left-leaning one (this was the default for the initial exploration from before).
</p><p>Again, these absolute probabilities of presenting these lines actually correspond to conditional probabilities, because we are ignoring all the other possible cases where the receiving unit is inactive -- we
are implicitly conditioning the entire simulation on the receiving unit being active (so that it is indeed always active for every input pattern).
</p><p>The parameter <code>p_right</code> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a> determines the frequencies of the events in the environment, with the Right event being set to p_right and Left to 1-p_right.
</p>
<ul><li> Set p_right to .7, and hit Apply and then the <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraTrain.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraTrain.Init() (page does not exist)\">Init</a> button -- you will see the frequency values updated to .7 and .3. Then, go ahead and switch back to viewing the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.HebbCorrelNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.HebbCorrelNet (page does not exist)\">.T3Tab.HebbCorrelNet</a> view before continuing.
</li></ul>
<p>Keep in mind as we do these exercises that this single receiving unit will ordinarily just be one of multiple such receiving units looking at the same input patterns.  Thus, we want this unit to specialize on representing one of the correlated features in the environment (i.e., 1 of the 2 lines in this case).  We can
manipulate this specialization by making the conditional probabilities weighted more toward one event over the other.
</p>
<ul><li> Now, press the Run button in the control panel.
</li></ul>
<p>This will run the network through 25 sets (epochs) of 100 randomly ordered event presentations, with 70 of these presentations being the Right event, and 30 being the Left event (given a p_right value of .7).  The CPCA Hebbian learning rule (equation 4.12 in the textbook) is applied after each event presentation and the weights updated accordingly.  You will see the display of the weights in the network window being updated after each trial.
</p><p>Another way to look at the development of the weights over learning is to use a graph log.
</p>
<ul><li> Select the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.EpochOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.EpochOutputData (page does not exist)\">.T3Tab.EpochOutputData</a> tab in the right 3D view panel, to reveal a graph log, and then do  Run again.
</li></ul>
<p>The graph log (figure 4.11 in the textbook) displays the value of one of the weights from a unit in the right-leaning diagonal line (wt_right, in black), and from a unit in the left-leaning diagonal line (wt_left, in red).  You should notice that as learning proceeds, the weights from the units active in the Right event will hover right around .7 (with the exception of the central unit, which is present in both events and will have a
weight of around 1), while the weights for the Left event will hover around .3.  Thus, as expected, the CPCA learning rule causes the weights to reflect the conditional probability that the input unit is active given that the receiver was active.  Experiment with different values of p_right, and verify that this holds for all sorts of different probabilities.
</p>
<a name=\"Learning_Rate\" id=\"Learning_Rate\"></a><h3> <span class=\"mw-headline\"> Learning Rate </span></h3>
<p>The parameter <code>lrate</code> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>, which corresponds to epsilon in the CPCA learning rule (equation 4.12), determines how rapidly the weights are updated after each event.
</p>
<ul><li> Change lrate to .1 and Run.
</li></ul>
<hr>
<p><b>Question 4.1 (a)</b> <i>How does this change in the learning rate affect the general character of the weight updates as displayed in the network window?</i> <b>(b)</b> <i>Explain why this happens.</i> <b>(c)</b> <i>Explain the relevance (if any) this might have for the importance of integrating over multiple experiences (events) in learning.</i>
</p>
<hr>
<ul><li> Set the lrate parameter back to .005.
</li></ul>
<a name=\"Selectivity\" id=\"Selectivity\"></a><h3> <span class=\"mw-headline\"> Selectivity </span></h3>
<p>When you explored different values of p_right previously, you were effectively manipulating how <i>selective</i> the receiving unit was for one type of event over another.  Thus, you were taking advantage of the conditional aspect of CPCA Hebbian learning by effectively conditionalizing its representation of the input environment.  As we stated earlier, instead of manipulating the frequency with which the two events occurred in the environment, you should think of this as manipulating the frequency with which the receiving unit was co-active with these events, because the receiving unit is always active for these inputs.
</p><p>Now we want to compare the conditionalizing aspect of CPCA with the unconditional PCA algorithm.  Let's assume that each event Right and Left) has an equal probability of appearing in the environment.  
</p>
<ul><li> Set p_right to .5, Apply, and Run.
</li></ul>
<p>This will simulate the effects of a standard (unconditional) form of PCA, where the receiving unit is effectively always on for the entire environment (unlike CPCA which can have the receiving unit active when only one of the lines is present in the environment).
</p>
<hr>
<p><b>Question 4.2 (a)</b> <i>What result does p_right=.5 lead to for the weights?</i> <b>(b)</b> <i>Does this weight pattern suggest the existence of two separate diagonal line features existing in the environment?  Explain your answer.</i> <b>(c)</b> <i>How does this compare with the \"blob\" solution for the natural scene images as discussed above and shown in figure 4.8 in the textbook?</i>
</p>
<hr>
<hr>
<p><b>Question 4.3 (a)</b> <i>How would you set p_right to simulate the hidden unit controlled in such a way as to come on only when there is a right-leaning diagonal line in the input, and never for the left one?</i> <b>(b)</b> <i>What result does this lead to for the weights?</i> <b>(c)</b> <i>Explain why this result might be more informative than the case  explored in the previous question.</i> <b>(d)</b> <i>How would you extend the architecture and training of the network to represent this environment of two diagonal lines in a fully satisfactory way? Explain your answer.</i>
</p>
<hr>
<p>The simple environment we have been using so far is not very realistic, because it assumes a one-to-one mapping between input patterns and the categories of features that we would typically want to represent.
</p>
<ul><li> Switch the <code>input_data</code> from <code>OneLineEnv</code> to <code>ThreeLineEnv</code>  in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a> (and Apply).  Then, click on <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Input_Patterns&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Input Patterns (page does not exist)\">.T3Tab.Input_Patterns</a> in the right 3D view panel to view these input patterns.
</li></ul>
<p>Notice that there are now three different versions of both the left and right diagonal lines, with upper and lower diagonals in addition to the original two center diagonal lines.  In this environment, p_right is spread among all three types of right lines, which are conceived of as mere subtypes of the more general category of
right lines (and likewise for 1-p_right and the left lines).  This is reflected in the frequency column as you can see.
</p>
<ul><li> Go ahead and Run this environment, while looking back at the network view r.wt weights.
</li></ul>
<p>You should see that the right lines all have weights of around .2333 and the left lines have weights around .1.  Although this is the correct result for representing the conditional probabilities, this result illustrates a couple of problems with the CPCA learning algorithm.  First, when units represent categories of features instead of single instances, the weights end up being <i>diluted</i> because the receiving unit is active for several different input patterns, so the conditional probabilities for each individual pattern can be relatively small.  Second, this dilution can be compounded by a receiving unit that has somewhat less than perfect selectivity for one category of features (right) over others (left), resulting in relatively small differences in weight magnitude (e.g., .233 for right versus .1 for left).  This is a real problem because units are generally not very selective during the crucial early phases of learning for reasons that will become clear later.
</p><p>Thus, in some sense, the CPCA algorithm is <i>too faithful</i> to the actual conditional probabilities, and does not do enough to emphasize the selectivity of the receiving unit.  Also, these small overall weight values reduce the <i>dynamic range</i> of the weights, and end up being inconsistent with the weight values produced by the task learning algorithm described in chapter 5.  The next section in the textbook shows how we can deal with these limitations of the basic CPCA rule.  After that, we will revisit this simulation.
</p>
<ul><li> If you wish to stop now and return at another time, you can close this project first by selecting <code>File-&gt;Close Project</code>. It's probably better to not save upon closing so you can sure the exercises will work when reopened. Then, quit out of Emergent by then selecting <code>File-&gt;Quit</code> in the <code>.viewers[0](root) window.</code>
</li></ul>
<a name=\"Renormalization_and_Contrast_Enhancement_in_CPCA\" id=\"Renormalization_and_Contrast_Enhancement_in_CPCA\"></a><h2> <span class=\"mw-headline\"> Renormalization and Contrast Enhancement in CPCA </span></h2>
<p>This section corresponds to section 4.7.3 in the textbook, where we explore the effects of renormalization and contrast enhancment on Hebbian learning.
</p><p>We are first going to explore the <i>renormalization</i> of the weights by taking into account the expected activity level over the input layer, alpha.  Because most of our line stimuli have 5 units active, and there are 25 units in the input layer, this alpha value is set to .2.  Let's explore this issue using an environment where the features have zero correlation with the receiving unit, and see how the renormalization results in weight values of .5 for this case.
</p>
<ul><li> Set input_data in the control panel to FiveHorizLines (Apply).  Click on <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Input_Patterns&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Input Patterns (page does not exist)\">.T3Tab.Input_Patterns</a> to see these patterns.
</li></ul>
<p>You should see that the environment contains 5 horizontal lines, each of which is presented with equal probability (i.e., 1/5 or .2).  Thus, these line features represent the zero correlation case, because they
each co-occur with the receiving unit with the same probability as the expected activity level over the input layer (.2).  In other words, you would expect this same level of co-occurrence if you simply activated input units at random such that the overall activity level on the input was at .2.
</p>
<ul><li> Click on r.wt in the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.HebbCorrelNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.HebbCorrelNet (page does not exist)\">.T3Tab.HebbCorrelNet</a> panel (and select the  hidden unit), and then <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraTrain.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraTrain.Run() (page does not exist)\">Run</a> the network.
</li></ul>
<p>You will see that because of the very literal behavior of the unmodified CPCA algorithm in reflecting the conditional probabilities, the weights are all around .2 at the end of learning.  Thus, if we were interpreting these weights in terms of the standard meaning of conditional probabilities (i.e., where .5 represents zero
correlation), we would conclude that the input units are anticorrelated with the receiving unit.  However, we know that this is not correct given the sparse activity levels in the input.
</p>
<ul><li> Now, set savg_cor.cor (which is the q_m parameter in equation 4.20 in the textbook) in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a> to a value of 1 instead of 0.
</li></ul>
<p>This means that we will now be applying the full correction for the average activity level in the sending (input) layer.  
</p>
<ul><li> Run the network again.
</li></ul>
<p>You should observe that the weights now hover around .5, which is the correct value for expressing the lack of correlation.
</p><p>Although the ability to fully correct for sparse sending activations is useful, one does not always want to do this.  In particular, if we have any prior expectation about how many individual input patterns should be represented by a given hidden unit, then we can set savg_cor.cor appropriately so that the .5 level corresponds roughly to this prior expectation.  For example, if we know that the units should have relatively <i>selective</i> representations (e.g., one or two input features per unit), then we might want to set savg_cor.cor to .5 or even less, because the full correction for the input layer alpha will result in larger weights for features that are relatively weakly correlated compared to this expected level of selectivity.  If units are expected to represent a number of input features, then a value of savg_cor.cor closer to 1 is more appropriate.  We will revisit this issue.
</p><p>Now, let's explore the contrast enhancement sigmoid function of the effective weights.  The parameters wt_sig.gain and .off in the control panel control the gain and offset of the sigmoid function.  First, we will plot the shape of the contrast enhancement function for different values of these parameters.
</p>
<ul><li> First set wt_sig.gain to 6 instead of 1.  Click the <code>Graph Wt Sig Fun</code> button in the control panel, keep the graph_data value in the popup dialog at NULL, which will bring up a new graph view in a new tab in the 3D view area.
</li></ul>
<p>You should see a sigmoidal function (the shape of the resulting effective weights function) plotted.  The horizontal axis, Lin Wt, represents the raw linear weight value, and the vertical axis, Eff Wt, represents the contrast enhanced effective weight value.  The increase in wt_sig.gain results in substantial contrast enhancement.
</p>
<ul><li> Try setting wt_sig.gain to various different values, and then clicking the <code>Graph Wt Sig Fun</code> button (on subsequent runs, you can select LeabraConSpec_0_WtSigFun for the graph_data value and it will just update the existing graph instead of making a new one).  This should give you a good sense of its effect on the shape of this function.
</li></ul>
<p>We next see the effects of wt_sig.gain on learning.
</p>
<ul><li> First, hit the Defaults button in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>, then change savg_cor.cor to 1, set the input_data to ThreeLinesEnv, and Run.
</li></ul>
<p>This run provides a baseline for comparison.  You should see a somewhat bloblike representation in the weights of the network, where the right lines are a bit more strong than the left lines, but not dramatically so.  
</p>
<ul><li> Now increase wt_sig.gain from 1 to 6, and Run again.
</li></ul>
<p>You should very clearly see that only the right lines are represented, and with relatively strong weights.  Thus, the contrast enhancement allows the network to represent the reality of the distinct underlying left and right categories of features even when it is imperfectly selective (.7) to these features.  This effect will be especially important for self-organizing learning, as we will see in the next project.
</p><p>Now, let's use the wt_sig.off parameter to encourage the network to pay attention to only the <i>strongest</i> of correlations in the input.  
</p>
<ul><li> Leaving wt_sig.gain at 6, change wt_sig.off to 1.25, and do <code>Graph Wt Sig Fun</code> to see how this affects the effective weight function.  You may have to go back and forth between 1 and 1.25 a couple of times to be able to see the difference -- it is more subtle than the gain parameter.
</li></ul>
<ul><li> With wt_sig.off set to 1.25, Run the network.
</li></ul>
<hr>
<p><b>Question 4.4 (a)</b> <i>How does this change the results compared to the case where wt_sig.off is 1?</i> <b>(b)</b> <i>Explain why this occurs.</i> <b>(c)</b> <i>Find a value of wt_sig.off that makes the non-central (non-overlapping) units of the right lines (i.e., the 4 units in the lower left corner and the 4 units in the upper right corner) have weights around .1 or less.</i> <b>(d)</b> <i>Do the resulting weights accurately reflect the correlations present in any single input pattern?  Explain your answer.</i> <b>(e)</b> <i>Can you imagine why this representation might be useful in some cases?</i>
</p>
<hr>
<p>An alternative way to accomplish some of the effects of the wt_sig.off parameter is to set the savg_cor.cor parameter to a value of less than 1.  As described above, this will make the units more <i>selective</i> because weak correlations will not be renormalized to as high a weight value.
</p>
<ul><li> Set wt_sig.off back to 1, and set savg_cor.cor to .7.
</li></ul>
<hr>
<p><b>Question 4.5 (a)</b> <i>What effect does this have on the learned weight values?</i> <b>(b)</b> <i>How does this compare with the wt_sig.off parameter you found in the previous question?</i>
</p>
<hr>
<p>This last question shows that because the contrast enhancement from wt_sig.gain magnifies differences around .5 (with wt_sig.off=1), the savg_cor.cor can have a big effect by changing the amount of correlated activity necessary to achieve this .5 value.  A lower savg_cor.cor will result in smaller weight values for more weakly correlated inputs -- when the wt_sig.gain parameter is large, then these smaller values get pushed down toward zero, causing the unit to essentially ignore these inputs.  Thus, these interactions between contrast enhancement and renormalization can play an important role in determining what the unit tends to detect.
</p><p>These simulations demonstrate how the correction factors of renormalization and contrast enhancement can increase the effectiveness of the CPCA algorithm.  These correction factors represent quantitative adjustments to the CPCA algorithm to address its limitations of dynamic range and selectivity, while preserving the basic computation performed by the algorithm to stay true to its biological and computational motivations.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 8/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:24-0!1!0!!en!2!edit=0 and timestamp 20090903204432 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Hebbian_Correlation\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Hebbian_Correlation</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Hebbian_Correlation\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Hebbian_Correlation&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Hebbian_Correlation&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Hebbian_Correlation&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Hebbian_Correlation\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Hebbian_Correlation\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Hebbian_Correlation\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Hebbian_Correlation&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Hebbian_Correlation&amp;oldid=474\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Hebbian+Correlation&amp;oldid=474&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Hebbian+Correlation&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 18 August 2009, at 08:19.</li>
					<li id=\"viewcount\">This page has been accessed 1,910 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.199 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="Hebbian Correlation Learning project -- control panel";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="input_data ";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0].args[1]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="p_right";
     desc=" real value";
     cust_desc=0;
     base=.projects[0].programs[0].vars[0]$$;
     mbr=ProgVar::real_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs[1]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="savg cor";
     desc=" for Hebbian and netinput computation: correction for sending average act levels (i.e., renormalization); also norm_con_n for normalizing netinput computation<br>  cor: [Default: 0.4:0.8]  proportion of correction to apply (0=none, 1=all, .5=half, etc)<br>  thresh: [Default: 0.001]  threshold of sending average activation below which learning does not occur (prevents learning when there is no input)<br>  norm con n: [Default: true]  WARNING: this is now obsolete and only used if wt_scale.old = true -- in normalizing netinput, divide by the actual number of connections (recv group n), not the overall number of units in the sending layer -- THIS SHOULD ALWAYS BE ON AND IS THE NEW DEFAULT";
     cust_desc=0;
     base=$.projects[0].networks[0].specs[1]$;
     mbr=LeabraConSpec::savg_cor;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[4] {
     label="wt sig";
     desc=" sigmoidal weight function for contrast enhancement: high gain makes weights more binary & discriminative<br>  gain: [Default: 1;6]  gain (contrast, sharpness) of the weight contrast function (1 = linear)<br>  off: [Default: 1:1.25]  offset of the function (1=centered at .5, >1=higher, <1=lower) -- 1.25 is standard for Leabra CHL, 1.2 for XCAL";
     cust_desc=0;
     base=$.projects[0].networks[0].specs[1]$;
     mbr=LeabraConSpec::wt_sig;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="HebbCorrelNet trial";
      desc=" trial counter: number of external input patterns that have been presented in the current epoch (updated by program)";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=Network::trial;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="HebbCorrelNet trial name";
      desc=" name associated with the current trial (e.g., name of input pattern, typically set by a LayerWriter)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="HebbCorrelNet epoch";
      desc=" epoch counter: number of times a complete set of training patterns has been presented (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::epoch;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Graph Wt Sig Fun";
     desc=" graph the sigmoidal weight contrast enhancement function (NULL = new data table)";
     cust_desc=0;
     base=$.projects[0].networks[0].specs[1]$;
     mth=LeabraConSpec::GraphWtSigFun;
    };
    EditMthItem @[5] {
     label="Defaults";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[1]$$;
     mth=Program::Run_Gui;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="OneLineEnv_Spec";
    desc="specification of frequencies for the OneLineEnv";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [2] "Right";"Left";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 2] 1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 2] 1;1;      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [2] 0.69999999;0.30000001;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="OneLineEnv";
    desc="one line (right, left) replicated by frequencies for each";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [100] "Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";
"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";
"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";
      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 100] 1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 100] 1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [100] 0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;0.69999999;
0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;
0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;
0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;0.30000001;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="ThreeLinesEnv_Spec";
    desc="three lines of each orientation, with specification for frequencies";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [6] "Right";"URight";"LRight";"Left";"ULeft";"LLeft";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 6] 1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 6] 1;1;1;1;1;1;      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [6] 0.23333333;0.23333333;0.23333333;0.1;0.1;0.1;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    name="ThreeLinesEnv";
    desc="three lines of each orientation replicated by frequencies";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [99] "Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";"Right";
"Right";"Right";"Right";"URight";"URight";"URight";"URight";"URight";"URight";"URight";
"URight";"URight";"URight";"URight";"URight";"URight";"URight";"URight";"URight";"URight";
"URight";"URight";"URight";"URight";"URight";"URight";"LRight";"LRight";"LRight";"LRight";
"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";
"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"LRight";"Left";
"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"Left";"ULeft";
"ULeft";"ULeft";"ULeft";"ULeft";"ULeft";"ULeft";"ULeft";"ULeft";"ULeft";"LLeft";
"LLeft";"LLeft";"LLeft";"LLeft";"LLeft";"LLeft";"LLeft";"LLeft";"LLeft";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 99] 1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
0;0;0;0;0;      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 99] 1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [99] 0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;
0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.23333333;0.1;
0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;
0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;
0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;0.1;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[4] {
    name="FiveHorizLines_Spec";
    desc="specification for 5 horizontal lines";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "H1";"H2";"H3";"H4";"H5";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 5] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 5] 1;1;1;1;1;      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.2;0.2;0.2;0.2;0.2;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[5] {
    name="FiveHorizLines";
    desc="5 horizontal lines (all equal frequency)";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [100] "H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";
"H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";"H1";
"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";
"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";"H2";
"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";
"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";"H3";
"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";
"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";"H4";
"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";
"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";"H5";
      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [5 5 100] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;1;1;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Hidden";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 100] 1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
      };
     };
     float_Data @[3] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [100] 0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;0.2;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[1] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="wt_right";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="wt_left";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="LeabraConSpec_0_WtSigFun";
    desc=;
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     float_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="MIN";
	value 6 0=0;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=1;
	val_type_fixed=0;
       };
      };
      name="Wt";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [101] 0;0.0099999998;0.02;0.029999999;0.039999999;0.049999997;0.059999995;0.069999993;0.079999991;0.089999989;
0.099999987;0.10999998;0.11999998;0.12999998;0.13999999;0.14999999;0.16;0.17;0.18000001;0.19000001;
0.20000002;0.21000002;0.22000003;0.23000003;0.24000004;0.25000003;0.26000002;0.27000001;0.28;0.28999999;
0.29999998;0.30999997;0.31999996;0.32999995;0.33999994;0.34999993;0.35999992;0.36999992;0.37999991;0.3899999;
0.39999989;0.40999988;0.41999987;0.42999986;0.43999985;0.44999984;0.45999983;0.46999982;0.47999981;0.4899998;
0.49999979;0.50999981;0.5199998;0.52999979;0.53999978;0.54999977;0.55999976;0.56999975;0.57999974;0.58999974;
0.59999973;0.60999972;0.61999971;0.6299997;0.63999969;0.64999968;0.65999967;0.66999966;0.67999965;0.68999964;
0.69999963;0.70999962;0.71999961;0.7299996;0.73999959;0.74999958;0.75999957;0.76999956;0.77999955;0.78999954;
0.79999954;0.80999953;0.81999952;0.82999951;0.8399995;0.84999949;0.85999948;0.86999947;0.87999946;0.88999945;
0.89999944;0.90999943;0.91999942;0.92999941;0.9399994;0.94999939;0.95999938;0.96999937;0.97999936;0.98999935;
0.99999934;      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="MIN";
	value 6 0=0;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=1;
	val_type_fixed=0;
       };
      };
      name="SigWt";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [101] 0;1.6596208e-14;1.128869e-12;1.3674673e-11;8.1762201e-11;3.3212241e-10;1.0567206e-09;2.8412552e-09;6.755112e-09;1.4622659e-08;
2.9401177e-08;5.5697512e-08;1.0046413e-07;1.7392583e-07;2.9080175e-07;4.71904e-07;7.4621482e-07;1.1535716e-06;1.7481203e-06;2.6027394e-06;
3.8146854e-06;5.5127871e-06;7.8665707e-06;1.1097836e-05;1.549529e-05;2.143303e-05;2.939391e-05;3.9998908e-05;5.4044285e-05;7.254813e-05;
9.6809301e-05;0.00012848119;0.00016966496;0.00022302697;0.00029194588;0.00038069926;0.00049469713;0.00064077816;0.00082758156;0.0010660174;
0.0013698591;0.0017564921;0.0022478595;0.0028716482;0.0036627948;0.0046653724;0.005934956;0.0075415811;0.0095734298;0.012141384;
0.01538454;0.01947693;0.024635291;0.031128075;0.039285097;0.049507104;0.062273838;0.078147858;0.097770244;0.12184244;
0.15108724;0.18618122;0.22765474;0.27576044;0.330327;0.39063206;0.4553377;0.52253926;0.58994508;0.65516531;
0.71603817;0.77090174;0.81874609;0.8592217;0.89253646;0.91929281;0.94031757;0.95651871;0.96878368;0.97791779;
0.98461515;0.98945141;0.99289048;0.99529707;0.99695277;0.99807078;0.99881023;0.99928808;0.99958867;0.99977189;
0.9998796;0.9999401;0.99997234;0.99998838;0.99999565;0.99999863;0.99999964;0.99999994;1;1;
1;      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="MIN";
	value 6 0=0;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=1;
	val_type_fixed=0;
       };
      };
      name="InvWt";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [101] 0;0.48183146;0.5111258;0.52841866;0.54077715;0.55042976;0.55837208;0.56513578;0.57103842;0.576285;
0.58101541;0.58532941;0.58930075;0.59298539;0.59642684;0.59965962;0.6027115;0.60560524;0.60835969;0.61099076;
0.6135118;0.61593419;0.61826789;0.62052143;0.6227023;0.62481707;0.62687159;0.62887108;0.63082016;0.63272303;
0.63458341;0.63640487;0.63819039;0.63994288;0.64166504;0.64335918;0.64502764;0.64667243;0.64829558;0.64989895;
0.65148419;0.65305299;0.65460688;0.6561473;0.65767568;0.65919346;0.66070181;0.66220212;0.66369551;0.66518331;
0.66666663;0.66814667;0.66962457;0.67110145;0.67257857;0.67405701;0.67553794;0.67702258;0.67851216;0.68000787;
0.68151104;0.68302292;0.68454498;0.68607867;0.68762535;0.68918675;0.69076455;0.6923604;0.69397634;0.6956144;
0.69727671;0.69896573;0.70068401;0.70243442;0.70422;0.70604426;0.70791101;0.7098245;0.71178949;0.7138114;
0.71589625;0.71805114;0.7202841;0.72260451;0.72502339;0.72755378;0.73021126;0.73301482;0.73598778;0.73915923;
0.74256635;0.74625772;0.75029826;0.75477815;0.75982761;0.76564562;0.77255946;0.7811693;0.79278225;0.81137812;
0.95547199;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="GenerateFreqs";
   short_nm="GnrFrq";
   tags=;
   desc="generate frequency versions of input data based on specified frequencies";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="p_right";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="probability of showing a right line";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="p_left";
     var_type=T_Real;
     real_val=0.3;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="probability of showing a left line (computed from p_right)";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="n_total";
     var_type=T_Int;
     int_val=100;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="total number of events to generate";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="OneLineEnv_Spec";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][0]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="OneLineEnv";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][1]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="ThreeLinesEnv_Spec";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][2]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="ThreeLinesEnv";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][3]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="FiveHorizLines_Spec";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][4]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[8] {
     name="FiveHorizLines";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][5]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    AssignExpr @[0] {
     desc=;
     flags=;
     result_var=.projects[0].programs[0].vars[1]$$;
     expr {
      expr="1.0 - p_right";
     };
    };
    Comment @[1] {
     desc="first do the OneLineEnv";
     flags=;
    };
    MethodCall @[2] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[3]$$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_right";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"Right\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[3] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[3]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_left";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"Left\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    DoneWritingDataRow @[4] {
     desc=;
     flags=;
     data_var=$.projects[0].programs[0].vars[3]$;
    };
    DataGenCall @[5] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::ReplicateByFrequency;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="repl_output";
       required=1;
       def_val=;
       expr {
	expr="OneLineEnv";
       };
      };
      ProgArg @[1] {
       arg_type=const_DataTable_ptr;
       type="const DataTable*";
       name="data_list_in";
       required=1;
       def_val=;
       expr {
	expr="OneLineEnv_Spec";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="total_number";
       required=1;
       def_val=;
       expr {
	expr="n_total";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="freq_col_nm";
       required=0;
       def_val="frequency";
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="renorm_freqs";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
     };
    };
    Comment @[6] {
     desc="Next ThreeLinesEnv";
     flags=;
    };
    MethodCall @[7] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[5]$$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_right / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"Right\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[8] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_right / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"URight\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[9] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_right / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"LRight\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[10] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_left / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"Left\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[11] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_left / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"ULeft\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[12] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SetValColRowName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="val";
       required=1;
       def_val=;
       expr {
	expr="p_left / 3.0";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"frequency\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="row_col_name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"Name\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="row_value";
       required=1;
       def_val=;
       expr {
	expr="\"LLeft\"";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    DoneWritingDataRow @[13] {
     desc=;
     flags=;
     data_var=$.projects[0].programs[0].vars[5]$;
    };
    DataGenCall @[14] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::ReplicateByFrequency;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="repl_output";
       required=1;
       def_val=;
       expr {
	expr="ThreeLinesEnv";
       };
      };
      ProgArg @[1] {
       arg_type=const_DataTable_ptr;
       type="const DataTable*";
       name="data_list_in";
       required=1;
       def_val=;
       expr {
	expr="ThreeLinesEnv_Spec";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="total_number";
       required=1;
       def_val=;
       expr {
	expr="n_total";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="freq_col_nm";
       required=0;
       def_val="frequency";
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="renorm_freqs";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
     };
    };
    DataProcCall @[15] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::ReplicateRows;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       expr {
	expr="FiveHorizLines";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       expr {
	expr="FiveHorizLines_Spec";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="n_repl";
       required=1;
       def_val=;
       expr {
	expr="20";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="SetDefaults";
   short_nm="SDflts";
   tags=;
   desc="restores default initial parameters in the simulation";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].data.gp[0][1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="p_right";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="lrate";
     var_type=T_Real;
     real_val=0.005;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="savg_cor";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="wt_sig_off";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="wt_sig_gain";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="ControlPanel";
     var_type=T_Object;
     object_type=SelectEdit;
     object_val=.projects[0].edits[0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="con_spec";
     var_type=T_Object;
     object_type=LeabraConSpec;
     object_val=$.projects[0].networks[0].specs[1]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[8] {
     name="GenerateFreqs";
     var_type=T_Object;
     object_type=Program;
     object_val=.projects[0].programs[0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[9] {
     name="LeabraTrain";
     var_type=T_Object;
     object_type=Program;
     object_val=$.projects[0].programs.gp[0][0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    MemberAssign @[0] {
     desc=;
     flags=;
     obj=.projects[0].programs[1].vars[7]$$;
     path="lrate";
     expr {
      expr="lrate";
     };
     update_after=0;
    };
    MemberAssign @[1] {
     desc=;
     flags=;
     obj=$.projects[0].programs[1].vars[7]$;
     path="savg_cor.cor";
     expr {
      expr="savg_cor";
     };
     update_after=0;
    };
    MemberAssign @[2] {
     desc=;
     flags=;
     obj=$.projects[0].programs[1].vars[7]$;
     path="wt_sig.off";
     expr {
      expr="wt_sig_off";
     };
     update_after=0;
    };
    MemberAssign @[3] {
     desc=;
     flags=;
     obj=$.projects[0].programs[1].vars[7]$;
     path="wt_sig.gain";
     expr {
      expr="wt_sig_gain";
     };
     update_after=0;
    };
    MethodCall @[4] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[1].vars[8]$$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"p_right\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="p_right";
       };
      };
     };
    };
    MethodCall @[5] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[1].vars[9]$$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"input_data\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
     };
    };
    MethodCall @[6] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[1].vars[6]$$;
     method=SelectEdit::UpdateAfterEdit;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=25;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=25;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][0].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=-1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][0].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][0].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][0].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][0].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][0].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
     MemberMethodCall @[5] {
      desc="update from any changes to wt_sig values";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      path="specs.LeabraConSpec_0";
      result_var=NULL;
      method=taList_impl::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     ProgramCall @[0] {
      desc="update the frequency of lines";
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      target=$.projects[0].programs[0]$;
      targ_ld_init="*GenerateFreqs*";
     };
     MemberMethodCall @[1] {
      desc="update from any changes to wt_sig values";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      path="specs.LeabraConSpec_0";
      result_var=NULL;
      method=taList_impl::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][0].vars[6]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[3] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[6]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[4] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     IfElse @[5] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     AssignExpr @[6] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][0].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[7] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[1]$;
	counter=Network::epoch;
	update_after=1;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[8] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].vars[6]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=99;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[0][1].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][1].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     MemberMethodCall @[0] {
      desc="update from any changes to wt_sig values";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="specs.LeabraConSpec_0";
      result_var=NULL;
      method=taList_impl::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetCounterInit @[1] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][1].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[2] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[4] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[5] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraTrial*";
       };
      };
      data_var=.projects[0].programs.gp[0][1].args[1]$$;
      index_var=.projects[0].programs.gp[0][1].vars[4]$$;
      order_var=.projects[0].programs.gp[0][1].vars[0]$$;
      order=PERMUTED;
      item_idx_list{ 15;5;13;71;34;53;21;65;37;7;79;67;81;30;87;40;48;74;64;16;28;78;56;88;18;69;47;1;58;43;12;2;33;95;14;70;42;44;90;82;31;60;26;23;94;4;20;55;75;68;61;10;46;8;9;11;59;50;17;39;41;73;98;63;52;83;96;66;77;24;89;72;0;25;6;85;36;3;84;97;35;51;38;93;29;57;45;32;86;80;22;92;19;62;27;54;49;91;76;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[6] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[9] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][2].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][2].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[4] {
      desc=;
      flags=;
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values based on changes computed by trial program";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     ProgramCall @[5] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      update_var=.projects[0].programs.gp[0][2].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][5]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][3].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][3].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][4]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][4].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][1]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Hidden";
	net_target=LAYER;
	layer_name="Hidden";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][5].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][5].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="wt_right";
	computed=1;
	object_type=LeabraRecvCons;
	object=NULL;
	variable="r.wt";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="wt_left";
	computed=1;
	object_type=LeabraRecvCons;
	object=NULL;
	variable="r.wt";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][1]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="wt_right";
      var_type=T_Real;
      real_val=0.06768161058425903;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="wt_left";
      var_type=T_Real;
      real_val=4.323282183638089e-13;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[3]$$;
      expr {
       expr="network.layers[1].units[0].recv[0].Cn(0).wt";
      };
     };
     AssignExpr @[3] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[4]$$;
      expr {
       expr="network.layers[1].units[0].recv[0].Cn(4).wt";
      };
     };
     DataVarProg @[4] {
      desc=;
      flags=;
      data_var=$.projects[0].programs.gp[0][7].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=1;
      var_1=$.projects[0].programs.gp[0][7].vars[3]$;
      var_2=$.projects[0].programs.gp[0][7].vars[4]$;
      var_3=NULL;
      var_4=NULL;
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      obj=.projects[0].programs.gp[0][8].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAtgAAAqkAAALxAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=1;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="HebbCorrelNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=0;
	  net_text_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=-0.5: z=0: }: };
	  net_text_rot=0;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[1].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_VALUES;
	  max_size {x=5: y=5: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.04;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="r.pdw";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	   ScaleRange @[3] {
	    name="s.pdw";
	    auto_scale=1;
	    min=-0;
	    max=0;
	   };
	  };
	  lay_disp_modes{ Input=0;Hidden=0;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5: y=0.6234747: z=1.374472: };
	 orient {x=-1.000011: y=0: z=0: rot=0.1739982: };
	 focal_dist=1.720017;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="EpochOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][1]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=23: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="avg_cycles";
	    m_data=.projects[0].data.gp[1][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="wt_right";
	    m_data=.projects[0].data.gp[1][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="wt_left";
	    m_data=.projects[0].data.gp[1][1].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.400589: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=24: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=24: };
	   range {min=0: max=24: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="wt_right";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="wt_left";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.445: z=1.624621: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.637121;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="Input_Patterns";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Hidden";
	    m_data=.projects[0].data.gp[0][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="frequency";
	    m_data=.projects[0].data.gp[0][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=6;
	  view_range {min=0: max=1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=0.7;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[0][2]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.858923: y=-0.0007590055: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][2].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][2].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Hidden";
	    m_data=.projects[0].data.gp[0][2].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="frequency";
	    m_data=.projects[0].data.gp[0][2].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.858923: y=-0.0007590055: z=0: }: };
	  view_rows=6;
	  view_range {min=0: max=5: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=0.7;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[2] {
	  name=;
	  m_data=$.projects[0].data.gp[0][4]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=2.71632: y=0.00100112: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][4].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][4].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Hidden";
	    m_data=.projects[0].data.gp[0][4].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="frequency";
	    m_data=.projects[0].data.gp[0][4].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=2.71632: y=0.00100112: z=0: }: };
	  view_rows=6;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=0.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=2.11191: y=0.517621: z=2.876172: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.886172;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[3] {
       name="LeabraConSpec_0_WtSigFun";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataViewMain;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=.projects[0].data.gp[2][0]$$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="Wt";
	    m_data=.projects[0].data.gp[2][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="SigWt";
	    m_data=.projects[0].data.gp[2][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="InvWt";
	    m_data=.projects[0].data.gp[2][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=100: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="Wt";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="SigWt";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=VALUE_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.445: z=1.624621: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.637121;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=-0.02140077762305737;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05958230793476105;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7587548494338989;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="HebbCorrelNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[4]$$: };
     sse_tol=0.5;
     act_fun=LINEAR;
     act {gelin=0: thr=0.25: gain=2: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=1: range=1: scale=1: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.4: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=2.5: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="LeabraConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.005;
     cur_lrate=0.005;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=1: off=1: };
     lmix {hebb=1: err=0: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=0: thresh=0.001: norm_con_n=1: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LeabraLayerSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=5: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraBiasSpec @[4] {
     name="LeabraBiasSpec_0";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=0.02: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=5: y=5: z=2: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_act_geom {x=5: y=5: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=5: y=5: n_not_xy=0: n=25: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs[0]$$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2: max=1: max_i=4: };
     acts_m {cmpt=1: avg=0.2: max=1: max_i=4: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=5: pct=0.2: pct_c=0.8: adth_k=2: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2]$$: };
     hard_clamped=0;
     avg_l_avg=1.401298e-45;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Hidden";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=2: y=1: z=1: };
     disp_scale=1;
     un_geom {x=1: y=1: n_not_xy=0: n=1: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=1: y=1: n_not_xy=0: n=1: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=1: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=1: max=1: max_i=0: };
     acts_m {cmpt=1: avg=1: max=1: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=1: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=1.401298e-45;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name=;
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="": start={usr=44419: sys=23974: tot=1724210747: }: end={usr=46804: sys=25156: tot=1724214522: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="": start={usr=46715: sys=25109: tot=1724214372: }: end={usr=46803: sys=25156: tot=1724214522: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=1.139663675643136e+155;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=26;
   n_cons=25;
   max_size {x=5: y=5: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=PLUS_ONLY;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=1;
   time_inc=1;
   cycle_max=2;
   mid_minus_cycle=-1;
   min_cycles=1;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=0;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=0;
   avg_cycles=0;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=0;
   avg_send_pct=0;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=0.005;
   maxda=0;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=1;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
