// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [3] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [6] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem @[4] { };
	EditMbrItem @[5] { };
	EditMbrItem_Group @.gp[0] = [7] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	};
      };

      EditMthItem_Group @.mths = [5] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [3] {
	  String_Data @[0] { };
	  String_Data @[1] { };
	  String_Data @[2] { };
	};
      };
    };
    DataTable_Group @.gp[1] = [6] { 
      DataTable @[0] { 
	DataTableCols @.data = [9] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [8] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [13] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[2] { };
	  int_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[4] { };
	  String_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	  float_Data @[12] { };
	};
      };
      DataTable @[3] { 
	DataTableCols @.data = [18] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	  float_Data @[12] { };
	  float_Data @[13] { };
	  float_Data @[14] { };
	  float_Data @[15] { };
	  float_Data @[16] { };
	  float_Data @[17] { };
	};
      };
      DataTable @[4] { 
	DataTableCols @.data = [18] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	  float_Data @[12] { };
	  float_Data @[13] { };
	  float_Data @[14] { };
	  float_Data @[15] { };
	  float_Data @[16] { };
	  float_Data @[17] { };
	};
      };
      DataTable @[5] { 
	DataTableCols @.data = [23] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[7] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[8] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[9] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[10] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[11] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[12] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[13] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[14] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[15] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[16] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[17] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[18] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[19] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[20] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[21] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[22] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [6] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [5] {
	MemberAssign @[0] { };
	MemberAssign @[1] { };
	MemberAssign @[2] { };
	RandomCall @[3] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	Switch @[4] { 
	  ProgEl_List @.cases = [3] {
	    CaseBlock @[0] { 
	      ProgEl_List @.prog_code = [2] {
		MemberAssign @[0] { };
		AssignExpr @[1] { };
	      };
	    };
	    CaseBlock @[1] { 
	      ProgEl_List @.prog_code = [2] {
		MemberAssign @[0] { };
		AssignExpr @[1] { };
	      };
	    };
	    CaseBlock @[2] { 
	      ProgEl_List @.prog_code = [2] {
		MemberAssign @[0] { };
		AssignExpr @[1] { };
	      };
	    };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [3] {
	MemberAssign @[0] { };
	MemberAssign @[1] { };
	MemberAssign @[2] { };
      };
    };
    Program @[2] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [16] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
	ProgVar @[10] { };
	ProgVar @[11] { };
	ProgVar @[12] { };
	ProgVar @[13] { };
	ProgVar @[14] { };
	ProgVar @[15] { };
      };

      Function_List @.functions = [1] {
	Function @[0] { 
	  ProgVar_List @.args = [1] {
	    ProgVar @[0] { };
	  };

	  ProgEl_List @.fun_code = [3] {
	    ProgVars @[0] { 
	      ProgVar_List @.local_vars = [1] {
		ProgVar @[0] { };
	      };
	    };
	    ForLoop @[1] { 
	      ProgEl_List @.loop_code = [2] {
		MethodCall @[0] { 
		  ProgArg_List @.meth_args = [2] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		  };
		};
		If @[1] { 
		  ProgEl_List @.true_code = [1] {
		    ReturnExpr @[0] { };
		  };
		};
	      };
	    };
	    ReturnExpr @[2] { };
	  };
	};
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [17] {
	ProgramCall @[0] { 
	  ProgArg_List @.prog_args = [5] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	  };
	};
	OtherProgramVar @[1] { };
	AssignExpr @[2] { };
	AssignExpr @[3] { };
	AssignExpr @[4] { };
	AssignExpr @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	AssignExpr @[8] { };
	AssignExpr @[9] { };
	AssignExpr @[10] { };
	IfElse @[11] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };

	  ProgEl_List @.false_code = [3] {
	    IfReturn @[0] { };
	    FunctionCall @[1] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    FunctionCall @[2] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	  };
	};
	If @[12] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
	If @[13] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
	If @[14] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
	If @[15] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
	If @[16] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
      };
    };
    Program @[3] { 
      ProgObjList @.objs = [2] {
	float_Matrix @[0] { };
	DataTable @[1] { 
	  DataTableCols @.data = [1] {
	    float_Data @[0] { };
	  };
	};
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [5] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
      };

      ProgVar_List @.vars = [14] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
	ProgVar @[10] { };
	ProgVar @[11] { };
	ProgVar @[12] { };
	ProgVar @[13] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [9] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	ResetDataRows @[1] { };
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	DataAnalCall @[3] { 
	  ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	  };
	};
	MathCall @[4] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	DataVarProg @[5] { };
	AssignExpr @[6] { };
	AssignExpr @[7] { };
	IfElse @[8] { 
	  ProgEl_List @.true_code = [1] {
	    AssignExpr @[0] { };
	  };

	  ProgEl_List @.false_code = [1] {
	    AssignExpr @[0] { };
	  };
	};
      };
    };
    Program @[4] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [1] {
	ProgVar @[0] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [1] {
	InitNamedUnits @[0] { };
      };

      ProgEl_List @.prog_code = [3] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
      };
    };
    Program @[5] { 
      ProgObjList @.objs = [3] {
	DataTable @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
     };

	  DataTableCols @.data = [1] {
	    float_Data @[0] { 
       UserDataItem_List @*(.user_data_) {
		UserDataItem @[0] { };
       };
};
	  };
	};
	DataTable @[1] { 
	  DataTableCols @.data = [40] {
	    String_Data @[0] { };
	    String_Data @[1] { };
	    String_Data @[2] { };
	    String_Data @[3] { };
	    String_Data @[4] { };
	    String_Data @[5] { };
	    String_Data @[6] { };
	    String_Data @[7] { };
	    String_Data @[8] { };
	    String_Data @[9] { };
	    String_Data @[10] { };
	    String_Data @[11] { };
	    String_Data @[12] { };
	    String_Data @[13] { };
	    String_Data @[14] { };
	    String_Data @[15] { };
	    String_Data @[16] { };
	    String_Data @[17] { };
	    String_Data @[18] { };
	    String_Data @[19] { };
	    String_Data @[20] { };
	    String_Data @[21] { };
	    String_Data @[22] { };
	    String_Data @[23] { };
	    String_Data @[24] { };
	    String_Data @[25] { };
	    String_Data @[26] { };
	    String_Data @[27] { };
	    String_Data @[28] { };
	    String_Data @[29] { };
	    String_Data @[30] { };
	    String_Data @[31] { };
	    String_Data @[32] { };
	    String_Data @[33] { };
	    String_Data @[34] { };
	    String_Data @[35] { };
	    String_Data @[36] { };
	    String_Data @[37] { };
	    String_Data @[38] { };
	    String_Data @[39] { };
	  };
	};
	DataTable @[2] { 
	  DataTableCols @.data = [40] {
	    String_Data @[0] { };
	    String_Data @[1] { };
	    String_Data @[2] { };
	    String_Data @[3] { };
	    String_Data @[4] { };
	    String_Data @[5] { };
	    String_Data @[6] { };
	    String_Data @[7] { };
	    String_Data @[8] { };
	    String_Data @[9] { };
	    String_Data @[10] { };
	    String_Data @[11] { };
	    String_Data @[12] { };
	    String_Data @[13] { };
	    String_Data @[14] { };
	    String_Data @[15] { };
	    String_Data @[16] { };
	    String_Data @[17] { };
	    String_Data @[18] { };
	    String_Data @[19] { };
	    String_Data @[20] { };
	    String_Data @[21] { };
	    String_Data @[22] { };
	    String_Data @[23] { };
	    String_Data @[24] { };
	    String_Data @[25] { };
	    String_Data @[26] { };
	    String_Data @[27] { };
	    String_Data @[28] { };
	    String_Data @[29] { };
	    String_Data @[30] { };
	    String_Data @[31] { };
	    String_Data @[32] { };
	    String_Data @[33] { };
	    String_Data @[34] { };
	    String_Data @[35] { };
	    String_Data @[36] { };
	    String_Data @[37] { };
	    String_Data @[38] { };
	    String_Data @[39] { };
	  };
	};
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [10] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
      };

      Function_List @.functions = [1] {
	Function @[0] { 
	  ProgVar_List @.args = [3] {
	    ProgVar @[0] { };
	    ProgVar @[1] { };
	    ProgVar @[2] { };
	  };

	  ProgEl_List @.fun_code = [2] {
	    MethodCall @[0] { 
	      ProgArg_List @.meth_args = [0] {
	      };
	    };
	    ForLoop @[1] { 
	      ProgEl_List @.loop_code = [5] {
		DataVarProg @[0] { };
		MiscCall @[1] { 
		  ProgArg_List @.meth_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		MethodCall @[2] { 
		  ProgArg_List @.meth_args = [2] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		  };
		};
		AssignExpr @[3] { };
		ForLoop @[4] { 
		  ProgEl_List @.loop_code = [7] {
		    MethodCall @[0] { 
		      ProgArg_List @.meth_args = [6] {
			ProgArg @[0] { };
			ProgArg @[1] { };
			ProgArg @[2] { };
			ProgArg @[3] { };
			ProgArg @[4] { };
			ProgArg @[5] { };
		      };
		    };
		    IfContinue @[1] { };
		    IfContinue @[2] { };
		    If @[3] { 
		      ProgEl_List @.true_code = [1] {
			AddNewDataRow @[0] { };
		      };
		    };
		    DataVarProg @[4] { };
		    MethodCall @[5] { 
		      ProgArg_List @.meth_args = [3] {
			ProgArg @[0] { };
			ProgArg @[1] { };
			ProgArg @[2] { };
		      };
		    };
		    VarIncr @[6] { };
		  };
		};
	      };
	    };
	  };
	};
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [4] {
	DataAnalCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	  };
	};
	FunctionCall @[1] { 
	  ProgArg_List @.fun_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	  };
	};
	DataAnalCall @[2] { 
	  ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	  };
	};
	FunctionCall @[3] { 
	  ProgArg_List @.fun_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [5] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [7] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  If @[3] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	  AssignExpr @[4] { };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[4] { 
	    ProgEl_List @.loop_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [8] {
	  NetCounterInit @[0] { };
	  ProgramCall @[1] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[3] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  ProgramCall @[6] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[7] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  If @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [4] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [9] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[1] = [9] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [10] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	      DynEnumItem @[2] { };
	      DynEnumItem @[3] { };
	      DynEnumItem @[4] { };
	      DynEnumItem @[5] { };
	      DynEnumItem @[6] { };
	      DynEnumItem @[7] { };
	      DynEnumItem @[8] { };
	      DynEnumItem @[9] { };
	    };
	  };
	};

	ProgVar_List @.args = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	ProgVar_List @.vars = [15] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	  ProgVar @[10] { };
	  ProgVar @[11] { };
	  ProgVar @[12] { };
	  ProgVar @[13] { };
	  ProgVar @[14] { };
	};

	Function_List @.functions = [2] {
	  Function @[0] { 
	    ProgVar_List @.args = [0] {
	    };

	    ProgEl_List @.fun_code = [9] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MethodCall @[1] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MethodCall @[3] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MethodCall @[4] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      MethodCall @[5] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      ProgramCall @[6] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      MethodCall @[7] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      MethodCall @[8] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  Function @[1] { 
	    ProgVar_List @.args = [2] {
	      ProgVar @[0] { };
	      ProgVar @[1] { };
	    };

	    ProgEl_List @.fun_code = [3] {
	      Switch @[0] { 
		ProgEl_List @.cases = [10] {
		  CaseBlock @[0] { 
		    ProgEl_List @.prog_code = [0] {
		    };
		  };
		  CaseBlock @[1] { 
		    ProgEl_List @.prog_code = [3] {
		      MethodCall @[0] { 
			ProgArg_List @.meth_args = [1] {
			  ProgArg @[0] { };
			};
		      };
		      MethodCall @[1] { 
			ProgArg_List @.meth_args = [1] {
			  ProgArg @[0] { };
			};
		      };
		      MethodCall @[2] { 
			ProgArg_List @.meth_args = [1] {
			  ProgArg @[0] { };
			};
		      };
		    };
		  };
		  CaseBlock @[2] { 
		    ProgEl_List @.prog_code = [1] {
		      MethodCall @[0] { 
			ProgArg_List @.meth_args = [1] {
			  ProgArg @[0] { };
			};
		      };
		    };
		  };
		  CaseBlock @[3] { 
		    ProgEl_List @.prog_code = [1] {
		      MethodCall @[0] { 
			ProgArg_List @.meth_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[4] { 
		    ProgEl_List @.prog_code = [1] {
		      MethodCall @[0] { 
			ProgArg_List @.meth_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[5] { 
		    ProgEl_List @.prog_code = [1] {
		      MethodCall @[0] { 
			ProgArg_List @.meth_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[6] { 
		    ProgEl_List @.prog_code = [2] {
		      FunctionCall @[0] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		      FunctionCall @[1] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[7] { 
		    ProgEl_List @.prog_code = [2] {
		      FunctionCall @[0] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		      FunctionCall @[1] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[8] { 
		    ProgEl_List @.prog_code = [2] {
		      FunctionCall @[0] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		      FunctionCall @[1] { 
			ProgArg_List @.fun_args = [2] {
			  ProgArg @[0] { };
			  ProgArg @[1] { };
			};
		      };
		    };
		  };
		  CaseBlock @[9] { 
		    ProgEl_List @.prog_code = [1] {
		      PrintExpr @[0] { };
		    };
		  };
		};
	      };
	      MethodCall @[1] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };
	  };
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  FunctionCall @[0] { 
	    ProgArg_List @.fun_args = [0] {
	    };
	  };
	  ResetDataRows @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  AssignExpr @[0] { };
	  AssignExpr @[1] { };
	  AssignExpr @[2] { };
	  AssignExpr @[3] { };
	  Comment @[4] { };
	  FunctionCall @[5] { 
	    ProgArg_List @.fun_args = [0] {
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [3] {
	      ResetDataRows @[0] { };
	      ForLoop @[1] { 
		ProgEl_List @.loop_code = [3] {
		  AssignExpr @[0] { };
		  AssignExpr @[1] { };
		  ForLoop @[2] { 
		    ProgEl_List @.loop_code = [2] {
		      AssignExpr @[0] { };
		      ForLoop @[1] { 
			ProgEl_List @.loop_code = [3] {
			  FunctionCall @[0] { 
			    ProgArg_List @.fun_args = [0] {
			    };
			  };
			  FunctionCall @[1] { 
			    ProgArg_List @.fun_args = [2] {
			      ProgArg @[0] { };
			      ProgArg @[1] { };
			    };
			  };
			  ProgramCall @[2] { 
			    ProgArg_List @.prog_args = [2] {
			      ProgArg @[0] { };
			      ProgArg @[1] { };
			    };
			  };
			};
		      };
		    };
		  };
		};
	      };
	      ProgramCall @[2] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };

	    ProgEl_List @.false_code = [5] {
	      AssignExpr @[0] { };
	      AssignExpr @[1] { };
	      AssignExpr @[2] { };
	      FunctionCall @[3] { 
		ProgArg_List @.fun_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      ProgramCall @[4] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	  ReturnExpr @[7] { };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [12] {
	  NetCounterInit @[0] { };
	  MemberAssign @[1] { };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[6] { 
	    ProgEl_List @.loop_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[9] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[10] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[11] { };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[4] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  ProgramCall @[5] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  If @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [4] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [13] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [9] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [10] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[2] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  ProgramCall @[3] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  OtherProgramVar @[4] { };
	  OtherProgramVar @[5] { };
	  DataVarProg @[6] { };
	  DataVarProg @[7] { };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[9] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [4] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [18] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	      NetMonItem @[13] { };
	      NetMonItem @[14] { };
	      NetMonItem @[15] { };
	      NetMonItem @[16] { };
	      NetMonItem @[17] { };
	    };
	  };
	  DataTable @[1] { 
	    DataTableCols @.data = [6] {
	      String_Data @[0] { };
	      float_Data @[1] { };
	      float_Data @[2] { };
	      float_Data @[3] { };
	      float_Data @[4] { };
	      float_Data @[5] { };
	    };
	  };
	  DataTable @[2] { 
	    DataTableCols @.data = [6] {
	      String_Data @[0] { };
	      float_Data @[1] { };
	      float_Data @[2] { };
	      float_Data @[3] { };
	      float_Data @[4] { };
	      float_Data @[5] { };
	    };
	  };
	  DataTable @[3] { 
	    DataTableCols @.data = [6] {
	      String_Data @[0] { };
	      float_Data @[1] { };
	      float_Data @[2] { };
	      float_Data @[3] { };
	      float_Data @[4] { };
	      float_Data @[5] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [10] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  DataGroupProg @[0] { 
	    DataOpList @.ops = [6] {
	      DataGroupEl @[0] { };
	      DataGroupEl @[1] { };
	      DataGroupEl @[2] { };
	      DataGroupEl @[3] { };
	      DataGroupEl @[4] { };
	      DataGroupEl @[5] { };
	    };
	  };
	  DataSelectRowsProg @[1] { 
	    DataOpList @.ops = [1] {
	      DataSelectEl @[0] { };
	    };
	  };
	  DataSelectRowsProg @[2] { 
	    DataOpList @.ops = [1] {
	      DataSelectEl @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  OtherProgramVar @[5] { };
	  DataVarProg @[6] { };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  DataProcCall @[8] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [1] {
	  DataGroupProg @[0] { 
	    DataOpList @.ops = [23] {
	      DataGroupEl @[0] { };
	      DataGroupEl @[1] { };
	      DataGroupEl @[2] { };
	      DataGroupEl @[3] { };
	      DataGroupEl @[4] { };
	      DataGroupEl @[5] { };
	      DataGroupEl @[6] { };
	      DataGroupEl @[7] { };
	      DataGroupEl @[8] { };
	      DataGroupEl @[9] { };
	      DataGroupEl @[10] { };
	      DataGroupEl @[11] { };
	      DataGroupEl @[12] { };
	      DataGroupEl @[13] { };
	      DataGroupEl @[14] { };
	      DataGroupEl @[15] { };
	      DataGroupEl @[16] { };
	      DataGroupEl @[17] { };
	      DataGroupEl @[18] { };
	      DataGroupEl @[19] { };
	      DataGroupEl @[20] { };
	      DataGroupEl @[21] { };
	      DataGroupEl @[22] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [6] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [1] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [2] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [8] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[3] { 
	      T3DataView_List @.children = [1] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [13] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		    GridColView @[5] { };
		    GridColView @[6] { };
		    GridColView @[7] { };
		    GridColView @[8] { };
		    GridColView @[9] { };
		    GridColView @[10] { };
		    GridColView @[11] { };
		    GridColView @[12] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[4] { 
	      T3DataView_List @.children = [1] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [18] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		    GridColView @[5] { };
		    GridColView @[6] { };
		    GridColView @[7] { };
		    GridColView @[8] { };
		    GridColView @[9] { };
		    GridColView @[10] { };
		    GridColView @[11] { };
		    GridColView @[12] { };
		    GridColView @[13] { };
		    GridColView @[14] { };
		    GridColView @[15] { };
		    GridColView @[16] { };
		    GridColView @[17] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[5] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [23] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		    GraphColView @[12] { };
		    GraphColView @[13] { };
		    GraphColView @[14] { };
		    GraphColView @[15] { };
		    GraphColView @[16] { };
		    GraphColView @[17] { };
		    GraphColView @[18] { };
		    GraphColView @[19] { };
		    GraphColView @[20] { };
		    GraphColView @[21] { };
		    GraphColView @[22] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [5] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [2] {
	    LeabraBiasSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [2] {
		SchedItem @[0] { };
		SchedItem @[1] { };
	      };
	    };
	    LeabraConSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [2] {
		SchedItem @[0] { };
		SchedItem @[1] { };
	      };
	    };
	  };

	  Schedule @.lrate_sched = [2] {
	    SchedItem @[0] { };
	    SchedItem @[1] { };
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [4] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[2] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[3] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	GpOneToOnePrjnSpec @[4] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
      };

      Layer_Group @.layers = [6] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [48] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [35] { 
	    };
	    LeabraUnit_Group @.gp[1] = [35] { 
	    };
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [70] { 
	    };
	    LeabraUnit_Group @.gp[1] = [70] { 
	    };
	  };
	};
	LeabraLayer @[3] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [35] { 
	    };
	    LeabraUnit_Group @.gp[1] = [35] { 
	    };
	  };
	};
	LeabraLayer @[4] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [49] {
	  };
	};
	LeabraLayer @[5] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [14] { 
	    };
	    LeabraUnit_Group @.gp[1] = [14] { 
	    };
	    LeabraUnit_Group @.gp[2] = [14] { 
	    };
	    LeabraUnit_Group @.gp[3] = [14] { 
	    };
	    LeabraUnit_Group @.gp[4] = [14] { 
	    };
	    LeabraUnit_Group @.gp[5] = [14] { 
	    };
	    LeabraUnit_Group @.gp[6] = [14] { 
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>

= Dyslexia Model: Normal and Disordered Reading =

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

This model simulates normal and disordered (dyslexic) reading performance in terms of a distributed representation of word-level knowledge across Orthography, Semantics, and Phonology.  It is based on a model by Plaut and Shallice (1993).  Note that this form of dyslexia is ''aquired'' (via brain lesions such as stroke) and not the more prevalent developmental variety.

Because the network takes some time to train (for 260 epochs), we will just load in a pre-trained network to begin with.

* Do Load Weights in the overall [[.PanelTab.ControlPanel]].

== Normal Reading Performance ==

For our initial exploration, we will just observe the behavior of the network as it \"reads\" the words presented to the orthographic input layer.  Note that the letters in the input are ordered left-to-right, bottom to top.

* Press Step in the control panel.

You will see the activation flow through the network, and it should settle into the correct pronunciation and semantics for the first word, \"tart\" (the bakery food).  In the network data at the bottom of the network view, you can see the output_name showing what the network produced over the phonology output layer (note: version 4.0.14 and earlier have a bug that shows the wrong letters here).

* Click on the [[.T3Tab.TrialTestOutputData]] tab to see a record of the network's performance on this word.

The group column shows whether this item is concrete (Con) or abstract (Abs), the trial_name column indicates the input pattern, and closest_name column shows the word that is closest to what the network produced, and the columns after that indicate what type of error the network makes, if any.  All of these should be 0, as the network is intact and well trained.

* Switch back to the [[.T3Tab.DyslexiaNet]] view and continue to Step through the words, paying particular attention to the timing of when the Phonological layer gets active relative to the Semantic one (you can set the step_proc to LeabraCycleTest to see this more clearly).

<hr>

'''Question 10.1 (a)''' <em> Do you think the initial phonological activation is caused by the \"direct\" input via orthography or the \"indirect\" input via semantics?  '''(b)''' Check for any cases where this initial phonological pattern is subsequently altered when the later input arrives, and describe what you find.  '''(c)''' Discuss what this might imply about the behavior of the network under damage to either of these pathways.</em>

<hr>

== Reading with Complete Pathway Lesions ==

We next explore the network's ability to read with one of the two pathways to phonology removed from action.  This relatively simple manipulation provides some insight into the network's behavior, and can be mapped onto two of the three dyslexias.  Specifically, when we remove the semantic pathway, leaving an intact direct pathway, we reproduce the characteristics of surface dyslexia, where words can be read but access to semantic representations is impaired and visual errors are made.  When we remove the direct pathway, reading must go through the semantic pathway, and we reproduce the effects of deep dyslexia by finding both semantic and visual errors.  Note that phonological dyslexia is a milder form of deep dyslexia, which we explore when we perform incremental amounts of partial damage instead of lesioning entire pathways.

We begin by lesioning the semantic pathway.

* Set lesion_type on the control panel to SEMANTICS_FULL (Apply), and do Test: Init, Step.

This does not actually remove any units or other network structure; it just flips a \"lesion\" flag that (reversibly) deactivates an entire layer (its color frame changes from emerald to grey to indicate this inactive status).  Note that by removing an entire pathway, we make the network rely on the intact one.  This means that the errors one would expect are those associated with the properties of the ''intact'' pathway, not the lesioned one.  For example, lesioning the direct pathway makes the network rely on semantics, allowing for the possibility of semantic errors to the extent that the semantic pathway doesn't quite get things right without the assistance of the missing direct pathway.  Completely lesioning the semantic pathway itself does ''not'' lead to semantically related errors -- there is no semantic information left for such errors to be based on!

* Do Run to test the network on all items, and look at the results in the [[.T3Tab.TrialTestOutputData]] view.

<hr>

'''Question 10.2 (a)''' <em>How many times did the network with only the direct pathway make a reading mistake overall (you can count the number of 1's in the various error columns, or look at the AllEpochTestOutputData view which has counted them for you)?  Notice that the network does not produce any blend outputs, indicating that the phonological output closely matched a known word.  '''(b)''' What does the lack of blends say about the cleanup properties of the network? </em>

<hr>

For each of the errors, compare the word the network produced (closest_name) with the input word (trial_name).  If the produced word is very similar orthographically (and phonologically) to the input word, this is called a ''visual'' error, because the error is based on the visual properties instead of the semantic properties of the word.  The simulation automatically scores errors as visual if the input orthography and the response orthography (determined from the response phonology) overlap by two or more letters.  You should see this reflected in the vis column in the grid view.  (Figure 10.8 in the textbook shows data from the old PDP++ model, which is not the same as this one).

<hr>

'''Question 10.3''' <em>How many of the semantically lesioned network's errors were visual, broken down by concrete and abstract, and overall?</em>

<hr>

Now, let's try the direct pathway lesion and retest the network 

* Set lesion_type to DIRECT_FULL, Apply, and do a Run.

<hr>

'''Question 10.4 (a)''' <em>What was the total number of errors this time, and how many of these errors were visual?  '''(b)''' For the remainder of the errors, use your \"common sense\" judgment and the cluster plot in Figure 10.7 (which usually agrees with common sense, but not always) to determine if there is a semantic similarity between the response and the input word (i.e., semantic errors) -- count the number of cases for which you  think this is true.</em>

<hr>

The simulation also does automatic coding of semantic errors, but they are somewhat more difficult to code because of the variable amount of activity in each pattern.  We use the criterion that if the input and response semantic representations overlap by .4 or more as measured by the ''cosine'' or ''normalized inner product'' between the patterns, then errors are scored as semantic.  The formula for the cosine is shown in the textbook on page 337 -- it goes from 0 for totally non-overlapping patterns to 1 for completely overlapping ones.  The value of .4 does a good job of including just the nearest neighbors in the cluster plot shown in Figure 10.7.  Nevertheless, because of the limited semantics, the automatically coded semantic errors do not always agree with our intuitions.

The text log also has columns for blend responses (when the distance to the closest valid output pattern is greater than 1), and a catch-all ''other'' column when none of these criteria apply (due to space constraints, neither of these are shown in the Figures in the textbook).

To summarize the results so far, we have seen that a lesion to the semantic pathway results in purely visual errors, while a lesion to the direct pathway results in a combination of visual and semantic errors.  To a first order of approximation, this pattern is observed in surface and deep dyslexia, respectively.  As simulated in the PMSP model, people with surface dyslexia are actually more likely to make errors on low-frequency irregular words, but we cannot examine this aspect of performance because frequency and regularity are not manipulated in our simple corpus of words.  Thus, the critical difference for our model is that surface dyslexia does not involve semantic errors, while the deep dyslexia does.  Visual errors are made in both cases.

== Reading with Partial Pathway Lesions ==

We next explore the effects of more realistic types of lesions that involve partial, random damage to the units in the various pathways, where we systematically vary the percentage of units damaged.  There are six different lesion types, corresponding to damaging different layers in the semantic and direct pathways as shown in Table 10.4 in the textbook (and shown in the lesion_type chooser in the control panel).  For each type of lesion, one can specify the percent of units removed from the layer in question with the lesion_pct value.

The first two lesion types damage the semantic pathway hidden layers (OS_Hid and SP_Hid), to simulate the effects of surface dyslexia.  The next type damages the direct pathway (OP_Hid), to simulate the effects of phonological dyslexia, and at high levels, deep dyslexia.  The next two lesion types damage the semantic pathway hidden layers again (OS_Hid and SP_Hid) but with a simultaneous complete lesion of the direct pathway, which corresponds to the model of deep dyslexia explored by Plaut & Shallice (1993).  Finally, the last lesion type damages the direct pathway hidden layer again (OP_Hid) but with a simultaneous complete lesion of the semantic pathway, which should produce something like an extreme form of surface dyslexia.  This last condition is included more for completeness than for any particular neuropsychological motivation.

=== Semantic Pathway Lesions ===

* Set lesion_type to OS_HID and lesion_pct to .1 and do Run -- then play with different lesion pct values.

You should observe that the network makes almost exclusively visual errors (like the network with a full semantic pathway lesion).  Results with 25 samples per lesion level from the PDP++ model are shown in Figure 10.10 in the text, and corresponding results from this model can be found in the BatchTestOutputData tab.

* Click on [[.T3Tab.BatchTestOutputData]] -- it should be showing results from OS_HID lesions as indicated by the labels in the graph.  This graph is configured to only show 10 data points at a time (view rows = 10 in the corresponding control panel), so to see the other data you have to use the scroll bar at the bottom of the graph -- drag that to the right to explore the full set of data, then return to the OS_HID case.

Your results should also show this general pattern of purely visual errors (or perhaps some \"other\" errors at high lesion levels), which is generally consistent with surface dyslexia, as expected.  It is somewhat counterintuitive that semantic errors are not made when lesioning the semantic pathway, but remember that the intact direct pathway provides orthographic input directly to the phonological pathway.  This input generally constrains the phonological output to be something related to the orthographic input, and it prevents any visually unrelated semantic errors from creeping in.  In other words, any tendency toward semantic errors due to damage to the semantic pathway is preempted by the direct orthographic input.  We will see that when this direct input is removed, semantic errors are indeed made.

<!-- NOTE: this is no longer the case!
Interestingly, lesions of the semantic layer itself produce more errors for {\\em concrete} versus abstract words -- this is (also) somewhat counterintuitive.  This finding can be understood by considering the division of labor that develops when the semantic system is much better able to process concrete words compared with abstract ones.  The direct pathway will then have to take up more of the responsibility for processing abstract words.  The effects of damage can be understood in two complementary ways.  From the perspective of dependence on the damaged semantic pathway, concrete words suffer more because they depend more on this damaged pathway. From the perspective of dependence on the intact direct pathway, abstract words suffer less because they depend more on this intact pathway.  This result shows that there can be general effects of semantic variables even though the network does not make specific confusions among words with similar semantics (i.e., semantic errors). However, we are not aware of data from people with surface dyslexia that would substantiate the existence of this effect in humans, and it is possible that other factors such as frequency and regularity would swamp this effect.
-->

* Do some SP_HID lesions at various lesion_pct levels, and then look at the [[.T3Tab.BatchTestOutputData]] results for SP_HID lesions.

You should observe lots of visual errors, but interestingly, the network also makes some semantic errors in this case.  This is due to being much closer to the phonological output, such that the damage can have a more direct effect where incorrect semantic information influences the output.

* Next, skip ahead to the OP_HID_DIRECT_FULL and SP_HID_DIRECT_FULL cases, both for your lesion tests and in the batch output data.

Figure 10.11 in the text shows these same semantic pathway lesions in conjunction with a complete lesion of the direct pathway.  This corresponds to the type of lesion studied by Plaut & Shallice (1993) in their model of deep dyslexia.  For all levels of semantic pathway lesion, we now see semantic errors, together with visual errors and a relatively large number of \"other\" (uncategorizable) errors.  This pattern of errors is generally consistent with that of deep dyslexia, where all of these kinds of errors are observed.  Comparing Figure 10.11 with the previous figure, we see that the direct pathway was playing an important role in generating correct responses, particularly in overcoming the semantic confusions that the semantic pathway would have otherwise made.

<hr>

'''Question 10.5''' <em>Compare the first bar in each graph of Figure 10.11 (corresponding to the case with only a direct pathway lesion, and no damage to the semantic pathway) with the subsequent bars.  '''(a)''' Does additional semantic pathway damage appear to be necessary to produce the semantic error symptoms of deep dyslexia?  '''(b)''' Explain why the direct pathway lesion leads to semantic errors.</em>

<hr>

Figure 10.11 also shows the relative number of semantic errors for the concrete versus abstract words.  One characteristic of deep dyslexia is that patients make more semantic errors on abstract words relative to concrete words.

<hr>

'''Question 10.6 (a)''' <em>Is there evidence in the model for a difference between concrete and abstract words in the number of semantic errors made? '''(b)''' Explain why this occurs in terms of the nature of the semantic representations in the model for these two types of words (recall that concrete words have richer semantics with more overall units).</em>

<hr>

=== Direct Pathway Lesions ===

Figure 10.12 in the textbook shows the effects of direct pathway lesions, both with and without an intact semantic pathway.  Let's focus first on the case with the intact semantic pathway (the Full Sem graphs in the figure).

* Set lesion_type to OP_HID and try some different lesion_pct lesions, and scroll to this data in the batch test graph view.

Notice that for smaller levels of damage more of the errors are visual than semantic.  This pattern corresponds well with phonological dyslexia, especially assuming that this damage to the direct pathway interferes with the pronunciation of nonwords, which can presumably only be read via this direct orthography to phonology pathway. Unfortunately, we can't test this aspect of the model because the small number of training words provides an insufficient sampling of the regularities that underlie successful nonword generalization, but the large-scale model of the direct pathway described in the next section produces nonword pronunciation deficits with even relatively small amounts of damage.

Interestingly, as the level of damage increases, the model makes increasingly more semantic errors, such that the profile of performance at high levels of damage provides a good fit to deep dyslexia, which is characterized by the presence of semantic and visual errors, plus the inability to pronounce nonwords.  The semantic errors result from the learning-based division of labor effect as described previously (Section 10.3.2 in the text).  Furthermore, we see another aspect of deep dyslexia in this data, namely a greater proportion of semantic errors in the abstract words than in the concrete ones (especially when you add together semantic and visual + semantic errors).

* Set lesion_type to OP_HID_SEMANTIC_FULL, and try some lesions for this case (and view the batch graph data).

This case of partial direct pathway damage with a completely lesioned semantic pathway produces mostly visual and \"other\" errors.

</body>
</html>
";
   html_text="<html><head></head><body>
<p>
</p><h1> Dyslexia Model: Normal and Disordered Reading </h1>
<p>
</p><ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
This model simulates normal and disordered (dyslexic) reading performance in terms of a distributed representation of word-level knowledge across Orthography, Semantics, and Phonology.  It is based on a model by Plaut and Shallice (1993).  Note that this form of dyslexia is  <i>aquired</i>  (via brain lesions such as stroke) and not the more prevalent developmental variety.
<p>
Because the network takes some time to train (for 260 epochs), we will just load in a pre-trained network to begin with.
</p><p>
</p><ul><li> Do Load Weights in the overall <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>.
</li></ul>
<h2> Normal Reading Performance </h2>
<p>
For our initial exploration, we will just observe the behavior of the network as it \"reads\" the words presented to the orthographic input layer.  Note that the letters in the input are ordered left-to-right, bottom to top.
</p><p>
</p><ul><li> Press Step in the control panel.
</li></ul>
You will see the activation flow through the network, and it should settle into the correct pronunciation and semantics for the first word, \"tart\" (the bakery food).  In the network data at the bottom of the network view, you can see the output_name showing what the network produced over the phonology output layer (note: version 4.0.14 and earlier have a bug that shows the wrong letters here).
<p>
</p><ul><li> Click on the <a href=\"ta:.T3Tab.TrialTestOutputData\">TrialTestOutputData</a> tab to see a record of the network's performance on this word.
</li></ul>
The group column shows whether this item is concrete (Con) or abstract (Abs), the trial_name column indicates the input pattern, and closest_name column shows the word that is closest to what the network produced, and the columns after that indicate what type of error the network makes, if any.  All of these should be 0, as the network is intact and well trained.
<p>
</p><ul><li> Switch back to the <a href=\"ta:.T3Tab.DyslexiaNet\">DyslexiaNet</a> view and continue to Step through the words, paying particular attention to the timing of when the Phonological layer gets active relative to the Semantic one (you can set the step_proc to LeabraCycleTest to see this more clearly).
</li></ul>
<hr>
<p>
 <b>Question 10.1 (a)</b>  <em> Do you think the initial phonological activation is caused by the \"direct\" input via orthography or the \"indirect\" input via semantics?   <b>(b)</b>  Check for any cases where this initial phonological pattern is subsequently altered when the later input arrives, and describe what you find.   <b>(c)</b>  Discuss what this might imply about the behavior of the network under damage to either of these pathways.</em>
</p><p>
</p><hr>
<p>
</p><h2> Reading with Complete Pathway Lesions </h2>
<p>
We next explore the network's ability to read with one of the two pathways to phonology removed from action.  This relatively simple manipulation provides some insight into the network's behavior, and can be mapped onto two of the three dyslexias.  Specifically, when we remove the semantic pathway, leaving an intact direct pathway, we reproduce the characteristics of surface dyslexia, where words can be read but access to semantic representations is impaired and visual errors are made.  When we remove the direct pathway, reading must go through the semantic pathway, and we reproduce the effects of deep dyslexia by finding both semantic and visual errors.  Note that phonological dyslexia is a milder form of deep dyslexia, which we explore when we perform incremental amounts of partial damage instead of lesioning entire pathways.
</p><p>
We begin by lesioning the semantic pathway.
</p><p>
</p><ul><li> Set lesion_type on the control panel to SEMANTICS_FULL (Apply), and do Test: Init, Step.
</li></ul>
This does not actually remove any units or other network structure; it just flips a \"lesion\" flag that (reversibly) deactivates an entire layer (its color frame changes from emerald to grey to indicate this inactive status).  Note that by removing an entire pathway, we make the network rely on the intact one.  This means that the errors one would expect are those associated with the properties of the  <i>intact</i>  pathway, not the lesioned one.  For example, lesioning the direct pathway makes the network rely on semantics, allowing for the possibility of semantic errors to the extent that the semantic pathway doesn't quite get things right without the assistance of the missing direct pathway.  Completely lesioning the semantic pathway itself does  <i>not</i>  lead to semantically related errors -- there is no semantic information left for such errors to be based on!
<p>
</p><ul><li> Do Run to test the network on all items, and look at the results in the <a href=\"ta:.T3Tab.TrialTestOutputData\">TrialTestOutputData</a> view.
</li></ul>
<hr>
<p>
 <b>Question 10.2 (a)</b>  <em>How many times did the network with only the direct pathway make a reading mistake overall (you can count the number of 1's in the various error columns, or look at the AllEpochTestOutputData view which has counted them for you)?  Notice that the network does not produce any blend outputs, indicating that the phonological output closely matched a known word.   <b>(b)</b>  What does the lack of blends say about the cleanup properties of the network? </em>
</p><p>
</p><hr>
<p>
For each of the errors, compare the word the network produced (closest_name) with the input word (trial_name).  If the produced word is very similar orthographically (and phonologically) to the input word, this is called a  <i>visual</i>  error, because the error is based on the visual properties instead of the semantic properties of the word.  The simulation automatically scores errors as visual if the input orthography and the response orthography (determined from the response phonology) overlap by two or more letters.  You should see this reflected in the vis column in the grid view.  (Figure 10.8 in the textbook shows data from the old PDP++ model, which is not the same as this one).
</p><p>
</p><hr>
<p>
 <b>Question 10.3</b>  <em>How many of the semantically lesioned network's errors were visual, broken down by concrete and abstract, and overall?</em>
</p><p>
</p><hr>
<p>
Now, let's try the direct pathway lesion and retest the network 
</p><p>
</p><ul><li> Set lesion_type to DIRECT_FULL, Apply, and do a Run.
</li></ul>
<hr>
<p>
 <b>Question 10.4 (a)</b>  <em>What was the total number of errors this time, and how many of these errors were visual?   <b>(b)</b>  For the remainder of the errors, use your \"common sense\" judgment and the cluster plot in Figure 10.7 (which usually agrees with common sense, but not always) to determine if there is a semantic similarity between the response and the input word (i.e., semantic errors) -- count the number of cases for which you  think this is true.</em>
</p><p>
</p><hr>
<p>
The simulation also does automatic coding of semantic errors, but they are somewhat more difficult to code because of the variable amount of activity in each pattern.  We use the criterion that if the input and response semantic representations overlap by .4 or more as measured by the  <i>cosine</i>  or  <i>normalized inner product</i>  between the patterns, then errors are scored as semantic.  The formula for the cosine is shown in the textbook on page 337 -- it goes from 0 for totally non-overlapping patterns to 1 for completely overlapping ones.  The value of .4 does a good job of including just the nearest neighbors in the cluster plot shown in Figure 10.7.  Nevertheless, because of the limited semantics, the automatically coded semantic errors do not always agree with our intuitions.
</p><p>
The text log also has columns for blend responses (when the distance to the closest valid output pattern is greater than 1), and a catch-all  <i>other</i>  column when none of these criteria apply (due to space constraints, neither of these are shown in the Figures in the textbook).
</p><p>
To summarize the results so far, we have seen that a lesion to the semantic pathway results in purely visual errors, while a lesion to the direct pathway results in a combination of visual and semantic errors.  To a first order of approximation, this pattern is observed in surface and deep dyslexia, respectively.  As simulated in the PMSP model, people with surface dyslexia are actually more likely to make errors on low-frequency irregular words, but we cannot examine this aspect of performance because frequency and regularity are not manipulated in our simple corpus of words.  Thus, the critical difference for our model is that surface dyslexia does not involve semantic errors, while the deep dyslexia does.  Visual errors are made in both cases.
</p><p>
</p><h2> Reading with Partial Pathway Lesions </h2>
<p>
We next explore the effects of more realistic types of lesions that involve partial, random damage to the units in the various pathways, where we systematically vary the percentage of units damaged.  There are six different lesion types, corresponding to damaging different layers in the semantic and direct pathways as shown in Table 10.4 in the textbook (and shown in the lesion_type chooser in the control panel).  For each type of lesion, one can specify the percent of units removed from the layer in question with the lesion_pct value.
</p><p>
The first two lesion types damage the semantic pathway hidden layers (OS_Hid and SP_Hid), to simulate the effects of surface dyslexia.  The next type damages the direct pathway (OP_Hid), to simulate the effects of phonological dyslexia, and at high levels, deep dyslexia.  The next two lesion types damage the semantic pathway hidden layers again (OS_Hid and SP_Hid) but with a simultaneous complete lesion of the direct pathway, which corresponds to the model of deep dyslexia explored by Plaut &amp; Shallice (1993).  Finally, the last lesion type damages the direct pathway hidden layer again (OP_Hid) but with a simultaneous complete lesion of the semantic pathway, which should produce something like an extreme form of surface dyslexia.  This last condition is included more for completeness than for any particular neuropsychological motivation.
</p><p>
</p><h3> Semantic Pathway Lesions </h3>
<p>
</p><ul><li> Set lesion_type to OS_HID and lesion_pct to .1 and do Run -- then play with different lesion pct values.
</li></ul>
You should observe that the network makes almost exclusively visual errors (like the network with a full semantic pathway lesion).  Results with 25 samples per lesion level from the PDP++ model are shown in Figure 10.10 in the text, and corresponding results from this model can be found in the BatchTestOutputData tab.
<p>
</p><ul><li> Click on <a href=\"ta:.T3Tab.BatchTestOutputData\">BatchTestOutputData</a> -- it should be showing results from OS_HID lesions as indicated by the labels in the graph.  This graph is configured to only show 10 data points at a time (view rows = 10 in the corresponding control panel), so to see the other data you have to use the scroll bar at the bottom of the graph -- drag that to the right to explore the full set of data, then return to the OS_HID case.
</li></ul>
Your results should also show this general pattern of purely visual errors (or perhaps some \"other\" errors at high lesion levels), which is generally consistent with surface dyslexia, as expected.  It is somewhat counterintuitive that semantic errors are not made when lesioning the semantic pathway, but remember that the intact direct pathway provides orthographic input directly to the phonological pathway.  This input generally constrains the phonological output to be something related to the orthographic input, and it prevents any visually unrelated semantic errors from creeping in.  In other words, any tendency toward semantic errors due to damage to the semantic pathway is preempted by the direct orthographic input.  We will see that when this direct input is removed, semantic errors are indeed made.
<p>
<!-- NOTE: this is no longer the case!
Interestingly, lesions of the semantic layer itself produce more errors for {\\em concrete} versus abstract words -- this is (also) somewhat counterintuitive.  This finding can be understood by considering the division of labor that develops when the semantic system is much better able to process concrete words compared with abstract ones.  The direct pathway will then have to take up more of the responsibility for processing abstract words.  The effects of damage can be understood in two complementary ways.  From the perspective of dependence on the damaged semantic pathway, concrete words suffer more because they depend more on this damaged pathway. From the perspective of dependence on the intact direct pathway, abstract words suffer less because they depend more on this intact pathway.  This result shows that there can be general effects of semantic variables even though the network does not make specific confusions among words with similar semantics (i.e., semantic errors). However, we are not aware of data from people with surface dyslexia that would substantiate the existence of this effect in humans, and it is possible that other factors such as frequency and regularity would swamp this effect.
-->
</p><p>
</p><ul><li> Do some SP_HID lesions at various lesion_pct levels, and then look at the <a href=\"ta:.T3Tab.BatchTestOutputData\">BatchTestOutputData</a> results for SP_HID lesions.
</li></ul>
You should observe lots of visual errors, but interestingly, the network also makes some semantic errors in this case.  This is due to being much closer to the phonological output, such that the damage can have a more direct effect where incorrect semantic information influences the output.
<p>
</p><ul><li> Next, skip ahead to the OP_HID_DIRECT_FULL and SP_HID_DIRECT_FULL cases, both for your lesion tests and in the batch output data.
</li></ul>
Figure 10.11 in the text shows these same semantic pathway lesions in conjunction with a complete lesion of the direct pathway.  This corresponds to the type of lesion studied by Plaut &amp; Shallice (1993) in their model of deep dyslexia.  For all levels of semantic pathway lesion, we now see semantic errors, together with visual errors and a relatively large number of \"other\" (uncategorizable) errors.  This pattern of errors is generally consistent with that of deep dyslexia, where all of these kinds of errors are observed.  Comparing Figure 10.11 with the previous figure, we see that the direct pathway was playing an important role in generating correct responses, particularly in overcoming the semantic confusions that the semantic pathway would have otherwise made.
<p>
</p><hr>
<p>
 <b>Question 10.5</b>  <em>Compare the first bar in each graph of Figure 10.11 (corresponding to the case with only a direct pathway lesion, and no damage to the semantic pathway) with the subsequent bars.   <b>(a)</b>  Does additional semantic pathway damage appear to be necessary to produce the semantic error symptoms of deep dyslexia?   <b>(b)</b>  Explain why the direct pathway lesion leads to semantic errors.</em>
</p><p>
</p><hr>
<p>
Figure 10.11 also shows the relative number of semantic errors for the concrete versus abstract words.  One characteristic of deep dyslexia is that patients make more semantic errors on abstract words relative to concrete words.
</p><p>
</p><hr>
<p>
 <b>Question 10.6 (a)</b>  <em>Is there evidence in the model for a difference between concrete and abstract words in the number of semantic errors made?  <b>(b)</b>  Explain why this occurs in terms of the nature of the semantic representations in the model for these two types of words (recall that concrete words have richer semantics with more overall units).</em>
</p><p>
</p><hr>
<p>
</p><h3> Direct Pathway Lesions </h3>
<p>
Figure 10.12 in the textbook shows the effects of direct pathway lesions, both with and without an intact semantic pathway.  Let's focus first on the case with the intact semantic pathway (the Full Sem graphs in the figure).
</p><p>
</p><ul><li> Set lesion_type to OP_HID and try some different lesion_pct lesions, and scroll to this data in the batch test graph view.
</li></ul>
Notice that for smaller levels of damage more of the errors are visual than semantic.  This pattern corresponds well with phonological dyslexia, especially assuming that this damage to the direct pathway interferes with the pronunciation of nonwords, which can presumably only be read via this direct orthography to phonology pathway. Unfortunately, we can't test this aspect of the model because the small number of training words provides an insufficient sampling of the regularities that underlie successful nonword generalization, but the large-scale model of the direct pathway described in the next section produces nonword pronunciation deficits with even relatively small amounts of damage.
<p>
Interestingly, as the level of damage increases, the model makes increasingly more semantic errors, such that the profile of performance at high levels of damage provides a good fit to deep dyslexia, which is characterized by the presence of semantic and visual errors, plus the inability to pronounce nonwords.  The semantic errors result from the learning-based division of labor effect as described previously (Section 10.3.2 in the text).  Furthermore, we see another aspect of deep dyslexia in this data, namely a greater proportion of semantic errors in the abstract words than in the concrete ones (especially when you add together semantic and visual + semantic errors).
</p><p>
</p><ul><li> Set lesion_type to OP_HID_SEMANTIC_FULL, and try some lesions for this case (and view the batch graph data).
</li></ul>
This case of partial direct pathway damage with a completely lesioned semantic pathway produces mostly visual and \"other\" errors.
<p>


</p></body></html>";
  };
  taDoc @[1] {
   name="ParameterNotes";
   desc=;
   auto_open=0;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
== Parameter Notes for dyslex.proj ==

* savg_cor = .4, dt.vm = .1 is too slow with direct path lesion to do anything, presumably due to weak weights
* savg_cor = .4, dt.vm = .2 doesn't show much effect of semantic pathway full lesion
* going back to orig defaults and hopefully orig results: div_gp_n (norm_con_n), dt.vm = .1, savg_cor = 1.0

</body>
</html>
";
   html_text="<html>
<head></head>
<body>
<h2> Parameter Notes for dyslex.proj </h2>
<P>
<ul><li> savg_cor = .4, dt.vm = .1 is too slow with direct path lesion to do anything, presumably due to weak weights
<li> savg_cor = .4, dt.vm = .2 doesn't show much effect of semantic pathway full lesion
<li> going back to orig defaults and hopefully orig results: div_gp_n (norm_con_n), dt.vm = .1, savg_cor = 1.0
</ul>
</body>
</html>
";
  };
  taDoc @[2] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Dyslexia";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Dyslexia";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Dyslexia,CECN1 Projects,Emergent,.PanelTab.ControlPanel,.T3Tab.TrialTestOutputData,.T3Tab.DyslexiaNet,.T3Tab.BatchTestOutputData\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Dyslexia - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Dyslexia\";
		var wgTitle = \"CECN1 Dyslexia\";
		var wgAction = \"view\";
		var wgArticleId = \"129\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 389;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Dyslexia skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Dyslexia</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Dyslexia:_Normal_and_Disordered_Reading\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Dyslexia: Normal and Disordered Reading</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Normal_Reading_Performance\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Normal Reading Performance</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Reading_with_Complete_Pathway_Lesions\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Reading with Complete Pathway Lesions</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Reading_with_Partial_Pathway_Lesions\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Reading with Partial Pathway Lesions</span></a>
<ul>
<li class=\"toclevel-3\"><a href=\"#Semantic_Pathway_Lesions\"><span class=\"tocnumber\">2.3.1</span> <span class=\"toctext\">Semantic Pathway Lesions</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Direct_Pathway_Lesions\"><span class=\"tocnumber\">2.3.2</span> <span class=\"toctext\">Direct Pathway Lesions</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Dyslexia:_Normal_and_Disordered_Reading\" id=\"Dyslexia:_Normal_and_Disordered_Reading\"></a><h1> <span class=\"mw-headline\"> Dyslexia: Normal and Disordered Reading </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/9/95/dyslex.proj\" class=\"internal\" title=\"dyslex.proj\">dyslex.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>
</li><li> Additional file for pretrained weights (required):
<ul><li> <a href=\"/mediawiki/sites/CompCogNeuro/images/d/d8/dyslex_trained.wts.gz\" class=\"internal\" title=\"dyslex trained.wts.gz\">dyslex_trained.wts.gz</a>
</li></ul>
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p><br>
</p>
<ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
<p>This model simulates normal and disordered (dyslexic) reading performance in terms of a distributed representation of word-level knowledge across Orthography, Semantics, and Phonology.  It is based on a model by Plaut and Shallice (1993).  Note that this form of dyslexia is <i>aquired</i> (via brain lesions such as stroke) and not the more prevalent developmental variety.
</p><p>Because the network takes some time to train (for 260 epochs), we will just load in a pre-trained network to begin with.
</p>
<ul><li> Do Load Weights in the overall <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>.
</li></ul>
<a name=\"Normal_Reading_Performance\" id=\"Normal_Reading_Performance\"></a><h2> <span class=\"mw-headline\"> Normal Reading Performance </span></h2>
<p>For our initial exploration, we will just observe the behavior of the network as it \"reads\" the words presented to the orthographic input layer.  Note that the letters in the input are ordered left-to-right, bottom to top.
</p>
<ul><li> Press Step in the control panel.
</li></ul>
<p>You will see the activation flow through the network, and it should settle into the correct pronunciation and semantics for the first word, \"tart\" (the bakery food).  In the network data at the bottom of the network view, you can see the output_name showing what the network produced over the phonology output layer (note: version 4.0.14 and earlier have a bug that shows the wrong letters here).
</p>
<ul><li> Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialTestOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialTestOutputData (page does not exist)\">.T3Tab.TrialTestOutputData</a> tab to see a record of the network's performance on this word.
</li></ul>
<p>The group column shows whether this item is concrete (Con) or abstract (Abs), the trial_name column indicates the input pattern, and closest_name column shows the word that is closest to what the network produced, and the columns after that indicate what type of error the network makes, if any.  All of these should be 0, as the network is intact and well trained.
</p>
<ul><li> Switch back to the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.DyslexiaNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.DyslexiaNet (page does not exist)\">.T3Tab.DyslexiaNet</a> view and continue to Step through the words, paying particular attention to the timing of when the Phonological layer gets active relative to the Semantic one (you can set the step_proc to LeabraCycleTest to see this more clearly).
</li></ul>
<hr>
<p><b>Question 10.1 (a)</b> <em> Do you think the initial phonological activation is caused by the \"direct\" input via orthography or the \"indirect\" input via semantics?  <b>(b)</b> Check for any cases where this initial phonological pattern is subsequently altered when the later input arrives, and describe what you find.  <b>(c)</b> Discuss what this might imply about the behavior of the network under damage to either of these pathways.</em>
</p>
<hr>
<a name=\"Reading_with_Complete_Pathway_Lesions\" id=\"Reading_with_Complete_Pathway_Lesions\"></a><h2> <span class=\"mw-headline\"> Reading with Complete Pathway Lesions </span></h2>
<p>We next explore the network's ability to read with one of the two pathways to phonology removed from action.  This relatively simple manipulation provides some insight into the network's behavior, and can be mapped onto two of the three dyslexias.  Specifically, when we remove the semantic pathway, leaving an intact direct pathway, we reproduce the characteristics of surface dyslexia, where words can be read but access to semantic representations is impaired and visual errors are made.  When we remove the direct pathway, reading must go through the semantic pathway, and we reproduce the effects of deep dyslexia by finding both semantic and visual errors.  Note that phonological dyslexia is a milder form of deep dyslexia, which we explore when we perform incremental amounts of partial damage instead of lesioning entire pathways.
</p><p>We begin by lesioning the semantic pathway.
</p>
<ul><li> Set lesion_type on the control panel to SEMANTICS_FULL (Apply), and do Test: Init, Step.
</li></ul>
<p>This does not actually remove any units or other network structure; it just flips a \"lesion\" flag that (reversibly) deactivates an entire layer (its color frame changes from emerald to grey to indicate this inactive status).  Note that by removing an entire pathway, we make the network rely on the intact one.  This means that the errors one would expect are those associated with the properties of the <i>intact</i> pathway, not the lesioned one.  For example, lesioning the direct pathway makes the network rely on semantics, allowing for the possibility of semantic errors to the extent that the semantic pathway doesn't quite get things right without the assistance of the missing direct pathway.  Completely lesioning the semantic pathway itself does <i>not</i> lead to semantically related errors -- there is no semantic information left for such errors to be based on!
</p>
<ul><li> Do Run to test the network on all items, and look at the results in the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialTestOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialTestOutputData (page does not exist)\">.T3Tab.TrialTestOutputData</a> view.
</li></ul>
<hr>
<p><b>Question 10.2 (a)</b> <em>How many times did the network with only the direct pathway make a reading mistake overall (you can count the number of 1's in the various error columns, or look at the AllEpochTestOutputData view which has counted them for you)?  Notice that the network does not produce any blend outputs, indicating that the phonological output closely matched a known word.  <b>(b)</b> What does the lack of blends say about the cleanup properties of the network? </em>
</p>
<hr>
<p>For each of the errors, compare the word the network produced (closest_name) with the input word (trial_name).  If the produced word is very similar orthographically (and phonologically) to the input word, this is called a <i>visual</i> error, because the error is based on the visual properties instead of the semantic properties of the word.  The simulation automatically scores errors as visual if the input orthography and the response orthography (determined from the response phonology) overlap by two or more letters.  You should see this reflected in the vis column in the grid view.  (Figure 10.8 in the textbook shows data from the old PDP++ model, which is not the same as this one).
</p>
<hr>
<p><b>Question 10.3</b> <em>How many of the semantically lesioned network's errors were visual, broken down by concrete and abstract, and overall?</em>
</p>
<hr>
<p>Now, let's try the direct pathway lesion and retest the network 
</p>
<ul><li> Set lesion_type to DIRECT_FULL, Apply, and do a Run.
</li></ul>
<hr>
<p><b>Question 10.4 (a)</b> <em>What was the total number of errors this time, and how many of these errors were visual?  <b>(b)</b> For the remainder of the errors, use your \"common sense\" judgment and the cluster plot in Figure 10.7 (which usually agrees with common sense, but not always) to determine if there is a semantic similarity between the response and the input word (i.e., semantic errors) -- count the number of cases for which you  think this is true.</em>
</p>
<hr>
<p>The simulation also does automatic coding of semantic errors, but they are somewhat more difficult to code because of the variable amount of activity in each pattern.  We use the criterion that if the input and response semantic representations overlap by .4 or more as measured by the <i>cosine</i> or <i>normalized inner product</i> between the patterns, then errors are scored as semantic.  The formula for the cosine is shown in the textbook on page 337 -- it goes from 0 for totally non-overlapping patterns to 1 for completely overlapping ones.  The value of .4 does a good job of including just the nearest neighbors in the cluster plot shown in Figure 10.7.  Nevertheless, because of the limited semantics, the automatically coded semantic errors do not always agree with our intuitions.
</p><p>The text log also has columns for blend responses (when the distance to the closest valid output pattern is greater than 1), and a catch-all <i>other</i> column when none of these criteria apply (due to space constraints, neither of these are shown in the Figures in the textbook).
</p><p>To summarize the results so far, we have seen that a lesion to the semantic pathway results in purely visual errors, while a lesion to the direct pathway results in a combination of visual and semantic errors.  To a first order of approximation, this pattern is observed in surface and deep dyslexia, respectively.  As simulated in the PMSP model, people with surface dyslexia are actually more likely to make errors on low-frequency irregular words, but we cannot examine this aspect of performance because frequency and regularity are not manipulated in our simple corpus of words.  Thus, the critical difference for our model is that surface dyslexia does not involve semantic errors, while the deep dyslexia does.  Visual errors are made in both cases.
</p>
<a name=\"Reading_with_Partial_Pathway_Lesions\" id=\"Reading_with_Partial_Pathway_Lesions\"></a><h2> <span class=\"mw-headline\"> Reading with Partial Pathway Lesions </span></h2>
<p>We next explore the effects of more realistic types of lesions that involve partial, random damage to the units in the various pathways, where we systematically vary the percentage of units damaged.  There are six different lesion types, corresponding to damaging different layers in the semantic and direct pathways as shown in Table 10.4 in the textbook (and shown in the lesion_type chooser in the control panel).  For each type of lesion, one can specify the percent of units removed from the layer in question with the lesion_pct value.
</p><p>The first two lesion types damage the semantic pathway hidden layers (OS_Hid and SP_Hid), to simulate the effects of surface dyslexia.  The next type damages the direct pathway (OP_Hid), to simulate the effects of phonological dyslexia, and at high levels, deep dyslexia.  The next two lesion types damage the semantic pathway hidden layers again (OS_Hid and SP_Hid) but with a simultaneous complete lesion of the direct pathway, which corresponds to the model of deep dyslexia explored by Plaut &amp; Shallice (1993).  Finally, the last lesion type damages the direct pathway hidden layer again (OP_Hid) but with a simultaneous complete lesion of the semantic pathway, which should produce something like an extreme form of surface dyslexia.  This last condition is included more for completeness than for any particular neuropsychological motivation.
</p>
<a name=\"Semantic_Pathway_Lesions\" id=\"Semantic_Pathway_Lesions\"></a><h3> <span class=\"mw-headline\"> Semantic Pathway Lesions </span></h3>
<ul><li> Set lesion_type to OS_HID and lesion_pct to .1 and do Run -- then play with different lesion pct values.
</li></ul>
<p>You should observe that the network makes almost exclusively visual errors (like the network with a full semantic pathway lesion).  Results with 25 samples per lesion level from the PDP++ model are shown in Figure 10.10 in the text, and corresponding results from this model can be found in the BatchTestOutputData tab.
</p>
<ul><li> Click on <a href=\"/CompCogNeuro/index.php?title=.T3Tab.BatchTestOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.BatchTestOutputData (page does not exist)\">.T3Tab.BatchTestOutputData</a> -- it should be showing results from OS_HID lesions as indicated by the labels in the graph.  This graph is configured to only show 10 data points at a time (view rows = 10 in the corresponding control panel), so to see the other data you have to use the scroll bar at the bottom of the graph -- drag that to the right to explore the full set of data, then return to the OS_HID case.
</li></ul>
<p>Your results should also show this general pattern of purely visual errors (or perhaps some \"other\" errors at high lesion levels), which is generally consistent with surface dyslexia, as expected.  It is somewhat counterintuitive that semantic errors are not made when lesioning the semantic pathway, but remember that the intact direct pathway provides orthographic input directly to the phonological pathway.  This input generally constrains the phonological output to be something related to the orthographic input, and it prevents any visually unrelated semantic errors from creeping in.  In other words, any tendency toward semantic errors due to damage to the semantic pathway is preempted by the direct orthographic input.  We will see that when this direct input is removed, semantic errors are indeed made.
</p><p><br>
</p>
<ul><li> Do some SP_HID lesions at various lesion_pct levels, and then look at the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.BatchTestOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.BatchTestOutputData (page does not exist)\">.T3Tab.BatchTestOutputData</a> results for SP_HID lesions.
</li></ul>
<p>You should observe lots of visual errors, but interestingly, the network also makes some semantic errors in this case.  This is due to being much closer to the phonological output, such that the damage can have a more direct effect where incorrect semantic information influences the output.
</p>
<ul><li> Next, skip ahead to the OP_HID_DIRECT_FULL and SP_HID_DIRECT_FULL cases, both for your lesion tests and in the batch output data.
</li></ul>
<p>Figure 10.11 in the text shows these same semantic pathway lesions in conjunction with a complete lesion of the direct pathway.  This corresponds to the type of lesion studied by Plaut &amp; Shallice (1993) in their model of deep dyslexia.  For all levels of semantic pathway lesion, we now see semantic errors, together with visual errors and a relatively large number of \"other\" (uncategorizable) errors.  This pattern of errors is generally consistent with that of deep dyslexia, where all of these kinds of errors are observed.  Comparing Figure 10.11 with the previous figure, we see that the direct pathway was playing an important role in generating correct responses, particularly in overcoming the semantic confusions that the semantic pathway would have otherwise made.
</p>
<hr>
<p><b>Question 10.5</b> <em>Compare the first bar in each graph of Figure 10.11 (corresponding to the case with only a direct pathway lesion, and no damage to the semantic pathway) with the subsequent bars.  <b>(a)</b> Does additional semantic pathway damage appear to be necessary to produce the semantic error symptoms of deep dyslexia?  <b>(b)</b> Explain why the direct pathway lesion leads to semantic errors.</em>
</p>
<hr>
<p>Figure 10.11 also shows the relative number of semantic errors for the concrete versus abstract words.  One characteristic of deep dyslexia is that patients make more semantic errors on abstract words relative to concrete words.
</p>
<hr>
<p><b>Question 10.6 (a)</b> <em>Is there evidence in the model for a difference between concrete and abstract words in the number of semantic errors made? <b>(b)</b> Explain why this occurs in terms of the nature of the semantic representations in the model for these two types of words (recall that concrete words have richer semantics with more overall units).</em>
</p>
<hr>
<a name=\"Direct_Pathway_Lesions\" id=\"Direct_Pathway_Lesions\"></a><h3> <span class=\"mw-headline\"> Direct Pathway Lesions </span></h3>
<p>Figure 10.12 in the textbook shows the effects of direct pathway lesions, both with and without an intact semantic pathway.  Let's focus first on the case with the intact semantic pathway (the Full Sem graphs in the figure).
</p>
<ul><li> Set lesion_type to OP_HID and try some different lesion_pct lesions, and scroll to this data in the batch test graph view.
</li></ul>
<p>Notice that for smaller levels of damage more of the errors are visual than semantic.  This pattern corresponds well with phonological dyslexia, especially assuming that this damage to the direct pathway interferes with the pronunciation of nonwords, which can presumably only be read via this direct orthography to phonology pathway. Unfortunately, we can't test this aspect of the model because the small number of training words provides an insufficient sampling of the regularities that underlie successful nonword generalization, but the large-scale model of the direct pathway described in the next section produces nonword pronunciation deficits with even relatively small amounts of damage.
</p><p>Interestingly, as the level of damage increases, the model makes increasingly more semantic errors, such that the profile of performance at high levels of damage provides a good fit to deep dyslexia, which is characterized by the presence of semantic and visual errors, plus the inability to pronounce nonwords.  The semantic errors result from the learning-based division of labor effect as described previously (Section 10.3.2 in the text).  Furthermore, we see another aspect of deep dyslexia in this data, namely a greater proportion of semantic errors in the abstract words than in the concrete ones (especially when you add together semantic and visual + semantic errors).
</p>
<ul><li> Set lesion_type to OP_HID_SEMANTIC_FULL, and try some lesions for this case (and view the batch graph data).
</li></ul>
<p>This case of partial direct pathway damage with a completely lesioned semantic pathway produces mostly visual and \"other\" errors.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 8/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:129-0!1!0!!en!2!edit=0 and timestamp 20090907215800 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Dyslexia\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Dyslexia</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Dyslexia\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Dyslexia&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Dyslexia&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Dyslexia&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Dyslexia\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Dyslexia\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Dyslexia\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Dyslexia&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Dyslexia&amp;oldid=389\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Dyslexia&amp;oldid=389&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Dyslexia&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 7 January 2009, at 09:04.</li>
					<li id=\"viewcount\">This page has been accessed 871 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.245 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="Control panel for dyslexia simulation";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="lesion_type";
     desc=" current value, which for normal mutually-exclusive options is index into list of enums (-1 = not set), and for bits is the bit values";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0].args[2].dyn_enum_val$$;
     mbr=DynEnum::value;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1;
     };
    };
    EditMbrItem @[1] {
     label="lesion_pct";
     desc=" real value";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0].args[3]$$;
     mbr=ProgVar::real_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="les_all_pct_step";
     desc=" real value";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0].vars[0]$$;
     mbr=ProgVar::real_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="les_all_nrep";
     desc=" integer value (also for enum types)";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0].vars[2]$$;
     mbr=ProgVar::int_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[4] {
     label="Test step prog";
     desc=" this is just here for loading prior versions and is no longer used in any fashion";
     cust_desc=0;
     base=.projects[0].programs.gp[1]$$;
     mbr=Program_Group::step_prog;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[5] {
     label="cycle updt net view";
     desc=" boolean value";
     cust_desc=0;
     base=.projects[0].programs.gp[1][4].vars[0]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="DyslexiaNet phase";
      desc=" type of settling phase<br>  MINUS PHASE:  minus phase<br>  PLUS PHASE:  plus phase";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=LeabraNetwork::phase;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="DyslexiaNet trial";
      desc=" trial counter: number of external input patterns that have been presented in the current epoch (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="DyslexiaNet trial name";
      desc=" name associated with the current trial (e.g., name of input pattern, typically set by a LayerWriter)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="DyslexiaNet sse";
      desc=" sum squared error over the network, for the current external input pattern";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::sse;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="DyslexiaNet minus output name";
      desc=" output_name in the minus phase -- for recording in logs as network's response (output_name in plus phase is clamped target value)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=LeabraNetwork::minus_output_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="DyslexiaNet minus cycles";
      desc=" cycles to settle in the minus phase -- this is the typical settling time statistic to record";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=LeabraNetwork::minus_cycles;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[6] {
      label="DyslexiaNet epoch";
      desc=" epoch counter: number of times a complete set of training patterns has been presented (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::epoch;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="LoadWeights";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[4]$$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[1] {
     label="Test: Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[2] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[3] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[4] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][0]$;
     mth=Program::Stop;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrainEnv";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [40] "tart_tttartt";"tent_tttentt";"face_fffAsss";"deer_dddErrr";"coat_kkkOttt";"grin_grrinnn";"lock_lllakkk";"rope_rrrOppp";"hare_hhhArrr";"lass_lll@sss";
"flan_fllonnn";"hind_hhhIndd";"wave_wwwAvvv";"flea_fllE---";"star_sttarrr";"reed_rrrEddd";"loon_lllUnnn";"case_kkkAsss";"flag_fll@ggg";"post_pppOstt";
"tact_ttt@ktt";"rent_rrrentt";"fact_fff@ktt";"deed_dddEddd";"cost_kkkostt";"gain_gggAnnn";"lack_lll@kkk";"role_rrrOlll";"hire_hhhIrrr";"loss_lllosss";
"plan_pll@nnn";"hint_hhhintt";"wage_wwwAjjj";"plea_pllE---";"stay_sttA---";"need_nnnEddd";"loan_lllOnnn";"ease_---Ezzz";"flaw_fllo---";"past_ppp@stt";
      };
     };
     float_Data @[1] {
      name="Orthography";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 8;6;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [8 6 40] 0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;1;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;1;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Semantics";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 14;5;1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [4] ;;;;      };
      ar {
       name=;
	    [14 5 1 2 40] 1;0;0;0;1;0;1;1;1;0;
0;0;0;1;0;0;1;0;1;1;
0;1;1;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;1;0;1;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;1;0;0;1;0;
0;0;0;0;0;1;0;0;1;0;
0;0;0;1;0;0;0;1;1;0;
1;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;1;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;1;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;1;0;0;0;
0;0;0;0;1;0;0;0;1;0;
1;1;0;0;0;1;1;1;0;0;
0;0;0;0;0;0;1;1;1;1;
1;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;1;0;1;0;1;
0;1;0;1;0;0;1;0;1;0;
1;0;0;1;0;0;0;1;1;0;
1;1;0;0;0;0;0;0;1;1;
0;1;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;1;0;0;0;
1;1;0;0;0;1;1;0;1;0;
0;0;0;0;0;1;1;1;0;0;
0;0;0;0;0;0;1;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;1;1;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;1;0;
0;0;0;0;1;0;0;0;1;0;
1;1;0;0;0;1;1;1;0;0;
0;0;0;0;0;0;1;1;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;1;0;0;0;
0;0;0;0;1;0;0;1;0;0;
0;1;0;0;0;1;1;0;0;0;
0;0;0;1;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
1;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;1;0;0;
0;0;1;1;0;0;0;1;0;0;
0;0;0;0;0;1;1;0;0;0;
0;0;1;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;0;0;0;0;1;0;0;0;
1;0;0;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;1;0;1;
0;0;0;1;0;0;1;0;1;0;
1;0;0;1;0;0;0;1;0;0;
0;1;1;0;0;0;0;0;1;1;
0;1;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;1;0;0;1;
0;0;0;0;1;0;0;0;1;0;
1;1;0;1;0;0;1;1;0;0;
0;0;0;0;0;0;0;0;1;1;
0;0;0;1;1;1;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;1;0;0;1;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;1;0;
0;0;0;0;0;1;0;0;1;1;
0;1;1;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;1;0;1;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;1;0;1;
0;1;0;1;0;0;1;0;1;0;
1;0;0;1;0;0;0;1;1;0;
1;1;0;0;0;0;0;0;1;1;
0;1;0;0;1;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;1;0;0;1;0;
0;0;0;0;1;0;1;0;1;0;
1;0;0;0;0;1;0;1;0;1;
0;0;0;0;0;0;0;0;1;0;
0;1;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;1;1;
0;0;0;0;0;0;0;0;1;0;
1;1;0;1;1;0;1;0;0;0;
0;0;1;0;0;0;1;0;1;0;
0;1;1;0;0;1;1;0;0;0;
0;0;0;0;1;1;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;1;
0;0;0;0;0;1;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;1;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;1;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;1;0;
1;0;0;1;0;0;0;1;0;1;
1;0;0;0;0;0;0;0;1;0;
0;1;0;0;0;1;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;0;1;0;0;
0;1;0;0;1;0;1;0;1;0;
1;0;0;0;0;1;0;1;0;0;
1;1;0;0;0;0;0;0;1;0;
1;1;1;1;0;1;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;1;1;0;0;0;
0;0;0;0;0;1;0;1;0;0;
0;1;0;1;0;0;1;0;0;0;
0;0;0;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;1;1;0;0;
1;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;1;0;0;0;
0;0;0;0;0;1;0;0;1;0;
1;0;0;0;0;1;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;0;1;0;0;1;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;1;0;0;1;1;0;0;
0;0;0;0;0;1;0;1;0;0;
0;0;0;1;0;0;1;0;0;0;
0;0;1;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
1;1;0;0;0;0;1;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;1;1;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;0;0;1;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;1;0;1;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;1;0;1;0;0;0;0;0;
0;0;0;0;0;1;1;1;0;0;
0;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;0;0;0;1;0;0;0;
1;1;1;1;1;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;1;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;1;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;1;
1;0;0;0;0;0;1;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;1;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;1;0;0;0;0;0;
1;0;0;0;0;0;1;1;1;1;
0;0;0;1;0;1;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;1;1;0;0;0;0;1;0;
0;0;0;1;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;1;0;0;1;
1;1;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
1;1;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[3] {
      name="Phonology";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;7;7;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [4] ;;;;      };
      ar {
       name=;
	    [2 7 7 1 40] 0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Orthography";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 8;6;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [8 6 1] "c";"d";"e";"f";"g";"h";"l";"n";"p";"r";
"s";"t";"w";"a";"e";"i";"l";"o";"r";"t";
"a";"c";"e";"g";"i";"l";"n";"o";"p";"r";
"s";"v";"a";"d";"e";"g";"k";"n";"r";"s";
"t";"w";"y";;;;;;      };
     };
     String_Data @[1] {
      name="Semantics";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 14;5;1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [4] ;;;;      };
      ar {
       name=;
	    [14 5 1 2 1] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
      };
     };
     String_Data @[2] {
      name="Phonology";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;7;7;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [4] ;;;;      };
      ar {
       name=;
	    [2 7 7 1 1] "-";"d";"f";"g";"h";"k";"l";"n";"p";"r";
"s";"t";"w";;"-";"d";"f";"g";"h";"k";
"l";"n";"p";"r";"t";"w";;;"-";"d";
"f";"g";"h";"k";"l";"n";"p";"r";"t";"w";
" ";" ";"@";"A";"E";"I";"O";"U";"a";"e";
"i";"o";;;;;"-";"d";"g";"i";
"k";"l";"n";"p";"r";"s";"t";"v";"z";;
"-";"d";"g";"i";"k";"l";"n";"p";"r";"s";
"t";"v";"z";;"-";"d";"g";"i";"k";"l";
"n";"p";"r";"s";"t";"v";"z";;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="TrialTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[2] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[5] {
      name="closest_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="vis";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      name="visem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[10] {
      name="sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      name="blend";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[12] {
      name="other";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    name="EpochTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cur_les_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="cur_lesion";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="cur_les_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="con_vis";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      name="con_visem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[10] {
      name="con_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      name="con_blend";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[12] {
      name="con_other";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[13] {
      name="abs_vis";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[14] {
      name="abs_visem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[15] {
      name="abs_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[16] {
      name="abs_blend";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[17] {
      name="abs_other";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[4] {
    name="AllEpochTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cur_les_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="cur_lesion";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="cur_les_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="con_vis";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      name="con_visem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[10] {
      name="con_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      name="con_blend";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[12] {
      name="con_other";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[13] {
      name="abs_vis";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[14] {
      name="abs_visem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[15] {
      name="abs_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[16] {
      name="abs_blend";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
     float_Data @[17] {
      name="abs_other";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[5] {
    name="BatchTestOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="cur_les_no_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 3;3;3;3;3;3;3;3;3;3;
4;4;4;4;4;4;4;4;4;4;
5;5;5;5;5;5;5;5;5;5;
6;6;6;6;6;6;6;6;6;6;
7;7;7;7;7;7;7;7;7;7;
8;8;8;8;8;8;8;8;8;8;
      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="cur_lesion_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] "OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";"OS_HID";
"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";"SP_HID";
"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";"OP_HID";
"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";"OS_HID_DIRECT_FULL";
"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";"SP_HID_DIRECT_FULL";
"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";"OP_HID_SEMANTICS_FULL";
      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="cur_les_pct_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
0.1;0.2;0.30000001;0.40000001;0.5;0.60000002;0.69999999;0.80000001;0.89999998;1;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_vis_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 4.2800002;3.8800001;2.8;2.4000001;3.1600001;2.5999999;3.8399999;3.4400001;2.8399999;5;
4.8400002;6.8800001;7.48;8.3199997;6.6399999;5.6399999;4.1999998;3.3599999;2.9200001;3;
4.9200001;3.8;3.28;2.72;3.28;2.9200001;1.72;1.72;1.3200001;2;
2.6400001;2;1.36;1.4400001;1.08;1.48;1.12;1.08;1.2;0;
2.04;2.8399999;2.1199999;2.8;2.9200001;1.84;1.88;2.2;1.48;0;
5.2399998;3.72;3.2;2.4000001;2.72;2.1199999;2.2;2;1.92;0;
      };
     };
     float_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_visem_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0.12;0.28;0.40000001;0.36000001;0.23999999;0.40000001;0;
0.60000002;0.039999999;0.079999998;0;0.039999999;0.16;0.16;0.23999999;0.2;0;
0;0;0;0.039999999;0.039999999;0.039999999;0;0;0.079999998;0;
0;0.16;0.079999998;0.16;0.2;0.12;0.23999999;0.2;0.12;0;
0.31999999;0.2;0.28;0.23999999;0.079999998;0.12;0.079999998;0.2;0.16;0;
      };
     };
     float_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_sem_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0;0;0.039999999;0.23999999;0.83999997;1.28;1.64;1.52;2.1199999;0;
2.48;1.5599999;2.24;2.1199999;2;2.76;2.6800001;3.1199999;2.6400001;3;
2.4400001;2.76;2.5599999;3.52;3.28;3;2.5999999;2.9200001;2.6800001;0;
2.52;2.3199999;1.16;1.6799999;1.28;2.1199999;1.6799999;2.04;1.6799999;0;
1.24;1.48;1.36;2.2;1.28;1.6;1.48;2.72;2.4400001;0;
      };
     };
     float_Data @[6] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_blend_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0.039999999;0;0;0;0;
0.16;0.75999999;1.24;2.24;2.3599999;3.8;5.04;6.8400002;6.1199999;1;
0.28;0.36000001;0.47999999;0.16;0.12;0.31999999;0.2;0.44;1.3200001;0;
0.2;0.88;1.76;0.51999998;1.12;0.80000001;0.83999997;1;1.12;20;
1.72;3.8399999;4.5999999;4.48;5.2800002;5.3600001;7;5.3600001;8;20;
0.68000001;0.63999999;0.28;0.2;0.2;0.079999998;0.75999999;0.72000003;1.36;20;
      };
     };
     float_Data @[7] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_other_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0.039999999;0;0.039999999;0.039999999;0.12;0.079999998;0.039999999;0;
0.16;0.12;0.83999997;1.36;3.5599999;5.1599998;5.52;6.1599998;6.7600002;0;
9.1599998;11.12;12.24;13.72;13.4;12.84;14.24;13.88;13.88;7;
12.04;13.04;13.08;13.52;13.6;13.76;14.72;14.04;14.2;0;
11.96;10.36;11.8;10.76;10.52;10.24;9.3199997;10.32;8.6000004;0;
10.24;13.52;14.84;14.84;15.6;15.84;15.08;14.28;14;0;
      };
     };
     float_Data @[8] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_vis_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 5.8800001;5.6399999;6.04;6.1999998;6.0799999;6.0799999;7.0799999;5.6799998;6.5599999;4;
6.04;6.5599999;7.2800002;6.8400002;6.8400002;5.52;5.1999998;4.1199999;4.4000001;5;
3;2;1.64;1.5599999;1.84;2.0799999;2.1600001;2.28;1.48;1;
1.24;1.4400001;1.36;1.6;1.5599999;1.76;2.5599999;2.1199999;2.1199999;0;
1.28;1.4400001;1.48;1.16;1.52;1.28;1.36;1.4400001;1.4400001;0;
4.3600001;2.3599999;2.3199999;2.1199999;1.28;1.76;2.0799999;2.0799999;1.64;0;
      };
     };
     float_Data @[9] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_visem_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0.079999998;0.2;0.079999998;0.31999999;0.51999998;0.36000001;0.2;0.23999999;0.12;0;
0.079999998;0.079999998;0.079999998;0.039999999;0.039999999;0.12;0.039999999;0.12;0.039999999;0;
0.039999999;0;0.039999999;0;0;0;0;0;0.039999999;0;
0.079999998;0;0;0.12;0.12;0.079999998;0.039999999;0.28;0.079999998;0;
0.079999998;0;0;0;0.039999999;0.079999998;0.039999999;0.079999998;0.039999999;0;
      };
     };
     float_Data @[10] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_sem_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0.039999999;0.079999998;0.039999999;0;0;0.039999999;0;0;
0.16;0.23999999;0.2;0.72000003;0.92000002;0.88;0.68000001;0.68000001;0.51999998;0;
2.2;2.52;3.3199999;3.2;2.8399999;2.8800001;3;2.9200001;2.4000001;1;
1.76;1.2;1.5599999;1;0.80000001;0.72000003;1.28;0.92000002;0.75999999;0;
1.76;2.48;2.8800001;2.8399999;2.8;0.75999999;1.04;1.2;0.75999999;0;
1.36;1.48;1.96;2.04;2.24;1.08;1.52;1.36;1.52;0;
      };
     };
     float_Data @[11] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_blend_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.039999999;0.039999999;0;0.039999999;0;0;0;0;0;0;
0.2;0.31999999;1;1.84;2.28;3.24;4.5599999;6.6399999;5.7600002;0;
0.079999998;0.079999998;0.079999998;0.16;0.12;0;0.079999998;0.16;1.48;0;
0;0;0;0;0.12;0.079999998;0.079999998;0.16;0.60000002;20;
1.6799999;1.04;1.6;1.28;0.92000002;5.04;6.5599999;4.8800001;7.7199998;20;
0.83999997;0.68000001;0.2;0.16;0.23999999;0.2;0.80000001;0.68000001;1.24;20;
      };
     };
     float_Data @[12] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_other_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.079999998;0.079999998;0.23999999;0.12;0.31999999;0.23999999;0.44;0.51999998;0.16;0;
0.36000001;0.60000002;1.2;2.8;5.7600002;7.3600001;7.0799999;7.04;7.5599999;0;
7.7600002;10.64;11.36;12.44;12.6;12.64;13.04;13.2;13.68;6;
15.4;16.879999;16.719999;16.76;17.360001;16.879999;15.88;16.48;16.24;0;
14.68;14.32;13.28;14.08;14.12;12.72;10.8;12.4;9.9200001;0;
9.5600004;14.28;14.76;15.04;15.44;16.559999;14.96;15.36;15.16;0;
      };
     };
     float_Data @[13] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_vis_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.33714089;0.42074221;0.2884441;0.33466399;0.34724054;0.23323807;0.42210898;0.29437393;0.35633689;0;
0.32829255;0.36362618;0.37146196;0.46206498;0.39549464;0.3143501;0.30463094;0.387319;0.39967987;0;
0.36186188;0.29393873;0.2857691;0.29675579;0.24344198;0.33428138;0.23677835;0.18347752;0.17636326;0;
0.23241341;0.19595918;0.20301723;0.22683914;0.20333223;0.21256526;0.25499803;0.21105449;0.21908903;0;
0.26820886;0.24449134;0.14221109;0.21908903;0.24605688;0.25724697;0.27896953;0.33466402;0.28910896;0;
0.45705146;0.36008888;0.30463094;0.32984847;0.29675579;0.2902137;0.30463094;0.29393879;0.28238985;0;
      };
     };
     float_Data @[14] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_visem_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0.064992309;0.089799777;0.09797959;0.096000001;0.08541663;0.097979598;0;
0.09797959;0.039191846;0.054258637;0;0.039191842;0.073321208;0.073321208;0.08541663;0.079999998;0;
0;0;0;0.039191838;0.039191835;0.039191842;0;0;0.054258637;0;
0;0.073321208;0.054258637;0.073321208;0.079999998;0.064992309;0.08541663;0.079999998;0.064992301;0;
0.10910545;0.079999998;0.089799777;0.08541663;0.054258637;0.064992301;0.054258637;0.079999998;0.073321208;0;
      };
     };
     float_Data @[15] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_sem_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0;0;0.039191838;0.08541663;0.18486753;0.22285421;0.29328483;0.29459125;0.321596;0;
0.33523721;0.20458737;0.27293953;0.3165817;0.30463094;0.44282722;0.42977208;0.46067771;0.47625208;0;
0.27758962;0.30082551;0.32535523;0.32555187;0.38995382;0.35327044;0.35777086;0.38748419;0.41845432;0;
0.32059944;0.31353474;0.24449134;0.32358;0.29675579;0.36362618;0.4146131;0.47826356;0.45858917;0;
0.27293956;0.26605266;0.27058455;0.36660609;0.32751185;0.37094477;0.34926206;0.55286884;0.56591165;0;
      };
     };
     float_Data @[16] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_blend_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0.039191838;0;0;0;0;
0.073321208;0.1982322;0.25474691;0.37215051;0.35272652;0.47665501;0.54985082;1.0082539;1.0140139;0;
0.089799777;0.11142711;0.12800001;0.073321208;0.064992309;0.10910545;0.11313708;0.17959955;0.67104691;0;
0.097979583;0.21406543;0.3806521;0.17995553;0.24212393;0.32984847;0.31839603;0.3622154;0.56091344;0;
0.26241949;0.48556772;0.3878144;0.46344799;0.59200001;1.1010976;1.3157507;1.4049968;1.6723636;0;
0.14664242;0.19497691;0.10613201;0.079999998;0.1264911;0.054258637;0.40508762;0.44728518;0.82729453;0;
      };
     };
     float_Data @[17] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="con_other_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0.039191835;0;0.039191835;0.039191835;0.064992301;0.054258637;0.039191838;0;
0.073321208;0.064992309;0.19332874;0.21821091;0.37128964;0.41058007;0.40445518;0.71033514;0.80851471;0;
0.65159494;0.56658977;0.49728864;0.44369364;0.45956498;0.44427013;0.39305979;0.54646504;0.68426895;0;
0.53510368;0.38149181;0.44513369;0.40047973;0.51224995;0.47759399;0.53222549;0.56421268;0.60663003;0;
0.62859845;0.4660643;0.35327041;0.30082551;0.53998518;0.83576071;0.95451766;1.1408348;1.3458084;0;
0.96379244;0.54880232;0.41445866;0.41830125;0.4233202;0.39871791;0.59308004;0.6132406;0.80796039;0;
      };
     };
     float_Data @[18] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_vis_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.43568796;0.27643445;0.32731634;0.32984844;0.4192183;0.28800002;0.31455371;0.36538202;0.4492839;0;
0.34166652;0.29437393;0.44728512;0.39871791;0.40666443;0.42753249;0.35777086;0.50062358;0.44181442;0;
0.24657655;0.2828427;0.21075103;0.25972292;0.29761723;0.23946607;0.24449131;0.2857691;0.18863723;0;
0.18998948;0.18829763;0.25848794;0.2116601;0.17045818;0.26095206;0.25348765;0.22852573;0.32653332;0;
0.20799999;0.18829763;0.17083326;0.12237648;0.18863718;0.20015991;0.18659045;0.17959955;0.30505079;0;
0.39951974;0.32926583;0.24475293;0.32653332;0.20015994;0.26701313;0.25873536;0.21105447;0.16857044;0;
      };
     };
     float_Data @[19] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_visem_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0;0;0;0;0;0;0;0;
0.054258637;0.079999998;0.054258637;0.10910545;0.099919982;0.11142711;0.079999998;0.10244999;0.064992309;0;
0.054258637;0.054258637;0.054258637;0.039191842;0.039191838;0.064992301;0.039191842;0.064992309;0.039191846;0;
0.039191838;0;0.039191846;0;0;0;0;0;0.03919185;0;
0.054258637;0;0;0.064992309;0.064992309;0.054258637;0.039191838;0.12026638;0.054258637;0;
0.054258637;0;0;0;0.039191846;0.078383699;0.03919185;0.054258637;0.03919185;0;
      };
     };
     float_Data @[20] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_sem_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0;0;0.039191842;0.054258637;0.039191846;0;0;0.039191842;0;0;
0.073321208;0.10244999;0.079999998;0.12026638;0.11200001;0.17269626;0.14664242;0.16704491;0.15094371;0;
0.24657655;0.22712111;0.24475297;0.29393876;0.29219171;0.27896953;0.39597982;0.41151428;0.45956501;0;
0.23515101;0.19595918;0.28329492;0.20396078;0.17888543;0.17453939;0.28011423;0.20333222;0.24838679;0;
0.24185947;0.27782008;0.33139703;0.32338211;0.33941129;0.2729395;0.32731634;0.34409302;0.2729395;0;
0.21075103;0.20489995;0.23650792;0.27410945;0.27873999;0.218504;0.23405981;0.32437015;0.44224888;0;
      };
     };
     float_Data @[21] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_blend_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.039191838;0.03919185;0;0.039191842;0;0;0;0;0;0;
0.09797959;0.093295224;0.17888543;0.3133305;0.32258949;0.5720979;0.6250248;1.065653;0.88594359;0;
0.054258637;0.054258637;0.054258637;0.073321208;0.064992309;0;0.054258637;0.092606701;0.76340288;0;
0;0;0;0;0.086162642;0.054258637;0.054258637;0.12237646;0.40792155;0;
0.28688675;0.25599998;0.33941126;0.48832774;0.35741287;1.3734394;1.6386141;1.3318498;1.7604727;0;
0.18486753;0.17636327;0.1264911;0.073321208;0.16277592;0.09797959;0.40398017;0.4689393;0.8085146;0;
      };
     };
     float_Data @[22] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="abs_other_sem";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [60] 0.054258637;0.054258637;0.08541663;0.064992309;0.093295217;0.08541663;0.12749901;0.11482161;0.073321208;0;
0.096000001;0.14966628;0.24657655;0.3794733;0.46053886;0.5625087;0.56828159;0.7766183;0.89098597;0;
0.63316345;0.62194532;0.40745062;0.4198285;0.4233202;0.2986905;0.40587682;0.34871191;0.69217336;0;
0.6669333;0.32653332;0.49483743;0.35453627;0.28216308;0.28464717;0.38499865;0.25996926;0.51312375;0;
0.26963678;0.23812604;0.39403555;0.46275693;0.35017705;1.1723753;1.3705473;1.114271;1.4354595;0;
0.84110403;0.53522336;0.44999552;0.34631771;0.38814431;0.2888875;0.45424223;0.48622626;0.80732661;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="RotateTrainingLayers";
   short_nm="RtTrnL";
   tags=;
   desc="rotate which layers have input vs. targets";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="network to train";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_lay_id";
     var_type=T_Int;
     int_val=2;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="InputLayer";
     var_type=T_String;
     string_val="Phonology";
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="name of the current input layer";
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=UserScript;
    el_def=0;
    MemberAssign @[0] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].args[0]$$;
     path="layers.Orthography.layer_type";
     expr {
      expr="Layer::TARGET";
     };
     update_after=0;
    };
    MemberAssign @[1] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].args[0]$;
     path="layers.Semantics.layer_type";
     expr {
      expr="Layer::TARGET";
     };
     update_after=0;
    };
    MemberAssign @[2] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].args[0]$;
     path="layers.Phonology.layer_type";
     expr {
      expr="Layer::TARGET";
     };
     update_after=0;
    };
    RandomCall @[3] {
     desc=;
     flags=;
     result_var=.projects[0].programs[0].vars[0]$$;
     object_type=Random;
     method=Random::IntZeroN;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="n";
       required=1;
       def_val=;
       expr {
	expr="3";
       };
      };
     };
    };
    Switch @[4] {
     desc=;
     flags=;
     switch_var=$.projects[0].programs[0].vars[0]$;
     cases {
      name=;
      el_typ=CaseBlock;
      el_def=0;
      CaseBlock @[0] {
       desc="Orthography";
       flags=;
       prog_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MemberAssign @[0] {
	 desc=;
	 flags=;
	 obj=$.projects[0].programs[0].args[0]$;
	 path="layers.Orthography.layer_type";
	 expr {
	  expr="Layer::INPUT";
	 };
	 update_after=0;
	};
	AssignExpr @[1] {
	 desc=;
	 flags=;
	 result_var=.projects[0].programs[0].vars[1]$$;
	 expr {
	  expr="\"Orthography\"";
	 };
	};
       };
       case_val {
	expr="0";
       };
      };
      CaseBlock @[1] {
       desc="Semantics";
       flags=;
       prog_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MemberAssign @[0] {
	 desc=;
	 flags=;
	 obj=$.projects[0].programs[0].args[0]$;
	 path="layers.Semantics.layer_type";
	 expr {
	  expr="Layer::INPUT";
	 };
	 update_after=0;
	};
	AssignExpr @[1] {
	 desc=;
	 flags=;
	 result_var=$.projects[0].programs[0].vars[1]$;
	 expr {
	  expr="\"Semantics\"";
	 };
	};
       };
       case_val {
	expr="1";
       };
      };
      CaseBlock @[2] {
       desc="Phonology";
       flags=;
       prog_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MemberAssign @[0] {
	 desc=;
	 flags=;
	 obj=$.projects[0].programs[0].args[0]$;
	 path="layers.Phonology.layer_type";
	 expr {
	  expr="Layer::INPUT";
	 };
	 update_after=0;
	};
	AssignExpr @[1] {
	 desc=;
	 flags=;
	 result_var=$.projects[0].programs[0].vars[1]$;
	 expr {
	  expr="\"Phonology\"";
	 };
	};
       };
       case_val {
	expr="2";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="ReadingTestLayers";
   short_nm="RdnTsL";
   tags=;
   desc="rotate which layers have input vs. targets: Ortho is input, others are targets";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="network to train";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_lay_id";
     var_type=T_Int;
     int_val=1;
     objs_ptr=0;
     flags=NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="InputLayer";
     var_type=T_String;
     string_val="Orthography";
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="name of the current input layer";
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=UserScript;
    el_def=0;
    MemberAssign @[0] {
     desc="input";
     flags=;
     obj=.projects[0].programs[1].args[0]$$;
     path="layers.Orthography.layer_type";
     expr {
      expr="Layer::INPUT";
     };
     update_after=0;
    };
    MemberAssign @[1] {
     desc=;
     flags=;
     obj=$.projects[0].programs[1].args[0]$;
     path="layers.Semantics.layer_type";
     expr {
      expr="Layer::TARGET";
     };
     update_after=0;
    };
    MemberAssign @[2] {
     desc=;
     flags=;
     obj=$.projects[0].programs[1].args[0]$;
     path="layers.Phonology.layer_type";
     expr {
      expr="Layer::TARGET";
     };
     update_after=0;
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[2] {
   name="DyslexErrs";
   short_nm="Dyslxr";
   tags=;
   desc="categorizes types of dyslexia errors";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=Network;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="the network to get activation values from";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="vis";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="visual err";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="visem";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="visual + semantic err";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="sem";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="semantic err";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="blend";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="blend err";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="other";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="other err";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="OrthoClosePats";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].programs[5].objs[1]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="from GetSimilarPatterns";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="SemClosePats";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].programs[5].objs[2]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="from GetSimilarPatterns";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="table of patterns to present to the network, one row at a time";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="closest_name";
     var_type=T_String;
     string_val="past_ppp@stt";
     objs_ptr=0;
     flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="result: name of input pattern with closest distance";
     init_from=NULL;
    };
    ProgVar @[9] {
     name="min_dist";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="result: minimum distance between current output pattern and any of the target patterns";
     init_from=NULL;
    };
    ProgVar @[10] {
     name="trial_no";
     var_type=T_Int;
     int_val=39;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[11] {
     name="name_err";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="error value for whether the full trial names match: 0 = they match, 1 = they don't match";
     init_from=NULL;
    };
    ProgVar @[12] {
     name="vis_err";
     var_type=T_Bool;
     bool_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="is there a visual error";
     init_from=NULL;
    };
    ProgVar @[13] {
     name="sem_err";
     var_type=T_Bool;
     bool_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="is there a semantic error";
     init_from=NULL;
    };
    ProgVar @[14] {
     name="blend_err";
     var_type=T_Bool;
     bool_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="is there a blend error";
     init_from=NULL;
    };
    ProgVar @[15] {
     name="i";
     var_type=T_Int;
     int_val=8;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
    Function @[0] {
     desc="see if network's response (closest_name) matches a close pattern to current input trial_no";
     flags=;
     name="CheckClosePats";
     return_type=T_Bool;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="close_pats";
       var_type=T_Object;
       object_type=DataTable;
       object_val=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ProgVars @[0] {
       desc=;
       flags=;
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="clp_nm";
	 var_type=T_String;
	 string_val=;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
       };
      };
      ForLoop @[1] {
       desc=;
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=;
	 result_var=.projects[0].programs[2].functions[0].fun_code[0].local_vars[0]$$;
	 obj=.projects[0].programs[2].functions[0].args[0]$$;
	 method=DataTable::GetVal;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Variant;
	   type="Variant";
	   name="col";
	   required=1;
	   def_val=;
	   expr {
	    expr="trial_no";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   expr {
	    expr="i";
	   };
	  };
	 };
	};
	If @[1] {
	 desc="a match";
	 flags=;
	 cond {
	  expr="clp_nm ==  closest_name";
	 };
	 true_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  ReturnExpr @[0] {
	   desc=;
	   flags=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < close_pats.rows";
       };
       iter {
	expr="i++";
       };
      };
      ReturnExpr @[2] {
       desc="nothing found";
       flags=;
       expr {
	expr="false";
       };
      };
     };
    };
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    ProgramCall @[0] {
     desc=;
     flags=;
     prog_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=Network;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       expr {
	expr="network";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="output_lay_name";
       required=1;
       def_val=;
       expr {
	expr="\"Phonology\"";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="variable";
       required=1;
       def_val=;
       expr {
	expr="\"act_m\"";
       };
      };
      ProgArg @[3] {
       arg_type=DataTable;
       type="DataTable*";
       name="target_input_data";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
      ProgArg @[4] {
       arg_type=taString;
       type="String";
       name="target_col_name";
       required=1;
       def_val=;
       expr {
	expr="\"Phonology\"";
       };
      };
     };
     target=.projects[0].programs[3]$$;
     targ_ld_init="*FindClosestEventFmNet*";
    };
    OtherProgramVar @[1] {
     desc=;
     flags=;
     other_prog=$.projects[0].programs[3]$;
     set_other=0;
     var_1=.projects[0].programs[2].vars[9]$$;
     var_2=.projects[0].programs[2].vars[8]$$;
     var_3=.projects[0].programs[2].vars[11]$$;
     var_4=NULL;
    };
    AssignExpr @[2] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[10]$$;
     expr {
      expr="network.trial";
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[12]$$;
     expr {
      expr="false";
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[13]$$;
     expr {
      expr="false";
     };
    };
    AssignExpr @[5] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[14]$$;
     expr {
      expr="false";
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[3]$$;
     expr {
      expr="0";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[4]$$;
     expr {
      expr="0";
     };
    };
    AssignExpr @[8] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[2]$$;
     expr {
      expr="0";
     };
    };
    AssignExpr @[9] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[0]$$;
     expr {
      expr="0";
     };
    };
    AssignExpr @[10] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[1]$$;
     expr {
      expr="0";
     };
    };
    IfElse @[11] {
     desc="not close to any given pronunciation -- blend error";
     flags=;
     cond {
      expr="min_dist > 1.0";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[14]$;
       expr {
	expr="true";
       };
      };
     };
     false_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      IfReturn @[0] {
       desc="if same name and not a blend, then no error -- bail!";
       flags=;
       cond {
	expr="name_err == 0";
       };
      };
      FunctionCall @[1] {
       desc="vis err if response is close to ortho input";
       flags=;
       result_var=$.projects[0].programs[2].vars[12]$;
       fun=.projects[0].programs[2].functions[0]$$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="close_pats";
	 required=1;
	 def_val=;
	 expr {
	  expr="OrthoClosePats";
	 };
	};
       };
      };
      FunctionCall @[2] {
       desc="sem err if response is close to sem input";
       flags=;
       result_var=$.projects[0].programs[2].vars[13]$;
       fun=$.projects[0].programs[2].functions[0]$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="close_pats";
	 required=1;
	 def_val=;
	 expr {
	  expr="SemClosePats";
	 };
	};
       };
      };
     };
    };
    If @[12] {
     desc=;
     flags=;
     cond {
      expr="vis_err";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[0]$;
       expr {
	expr="1";
       };
      };
     };
    };
    If @[13] {
     desc=;
     flags=;
     cond {
      expr="sem_err";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[2]$;
       expr {
	expr="1";
       };
      };
     };
    };
    If @[14] {
     desc=;
     flags=;
     cond {
      expr="vis_err && sem_err";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[1]$;
       expr {
	expr="1";
       };
      };
     };
    };
    If @[15] {
     desc=;
     flags=;
     cond {
      expr="blend_err";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[3]$;
       expr {
	expr="1";
       };
      };
     };
    };
    If @[16] {
     desc="must be other";
     flags=;
     cond {
      expr="!vis_err && !sem_err && !blend_err";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[2].vars[4]$;
       expr {
	expr="1";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[3] {
   name="FindClosestEventFmNet";
   short_nm="FnClsF";
   tags="Statistic, Error ";
   desc="find closest event from list of input data compared to layer activation on network -- replaces ClosestEventStat from PDP++";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=float_Matrix;
    el_def=0;
    float_Matrix @[0] {
     name="OutputTargetDistMatrix";
	[40 1] 9.2611952;9.2611952;11.158558;13.073642;9.1207619;13.073642;13.072677;12.932946;13.073642;9.4438572;
13.07303;13.073642;13.073642;13.07303;13.073642;13.073642;13.073642;11.177233;11.339277;1.5929246;
7.5268536;9.2612123;7.5081959;13.073642;7.3648038;13.073642;11.339301;12.93319;13.073642;11.177233;
9.4390926;9.2612123;13.073642;11.172469;13.073642;13.073642;12.933191;13.073643;13.07303;0;
    };
    DataTable @[1] {
     name="CurTrialData";
     desc=;
     data {
      name="data";
      el_typ=int_Data;
      el_def=0;
      float_Data @[0] {
       name="Phonology_act_m";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;7;7;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [4] ;;;;       };
       ar {
	name=;
	      [2 7 7 1 1] 0;0;0.00030589956;0;0;0;0;0;0.94930112;0;
0;8.9085588e-06;0;0;0;0;0.0043400545;0;0;0;
0;0;0.93046361;0;0;0;0;0;0;0;
0.0047124224;0;0;0;0;0;0.92978108;0;0;0;
0;0;0.85637343;0;0;0;0.072881237;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0.00048294623;0;0;0;0;0.94678891;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0.95346791;0;0;6.9475616e-05;0;0;0.00018908762;0;0;0;
0;0.00012205431;0;0;0.95043558;0;0;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=Network;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="the network to get activation values from";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="output_lay_name";
     var_type=T_String;
     string_val="Phonology";
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="name of the layer in the network that contains the activations to compare";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="variable";
     var_type=T_String;
     string_val="act_m";
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="variable name on network to get activation values from (typically act)";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="target_input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].data.gp[0][0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="target input data with full list of events to compare output data pattern to";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="target_col_name";
     var_type=T_String;
     string_val="Phonology";
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="name of the column in the target_input_data that contains the activations to compare";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="output_layer";
     var_type=T_Object;
     object_type=Layer;
     object_val=.projects[0].networks[0].layers[5]$$;
     objs_ptr=0;
     flags=CTRL_READ_ONLY|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="OutputTargetDistMatrix";
     var_type=T_Object;
     object_type=float_Matrix;
     object_val=.projects[0].programs[3].objs[0]$$;
     objs_ptr=1;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="computed distances between output and targets";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="CurTrialData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].programs[3].objs[1]$$;
     objs_ptr=1;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="pointer for holding the data from the current trial";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="dist_metric";
     var_type=T_HardEnum;
     int_val=0;
     hard_enum_type=taMath::DistMetric;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="parameter: distance metric to use in computing distances";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="dist_norm";
     var_type=T_Bool;
     bool_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="parameter: whether to normalize distance value";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="dist_tol";
     var_type=T_Real;
     real_val=0.5;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="parameter: tolerance to use for computing distances -- values < this count as zero";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="min_dist";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="result: minimum distance between current output pattern and any of the target patterns";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="min_idx";
     var_type=T_Int;
     int_val=39;
     objs_ptr=0;
     flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="row index of what produced the min val";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="Name";
     var_type=T_String;
     string_val="past_ppp@stt";
     objs_ptr=0;
     flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="name of the minimum input/output pair that produced the minimum value";
     init_from=NULL;
    };
    ProgVar @[9] {
     name="closest_name";
     var_type=T_String;
     string_val="past_ppp@stt";
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="result: name of input pattern with closest distance";
     init_from=NULL;
    };
    ProgVar @[10] {
     name="trial_name";
     var_type=T_String;
     string_val="past_ppp@stt";
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="the current trial name";
     init_from=NULL;
    };
    ProgVar @[11] {
     name="name_err";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="error value for whether the full trial names match: 0 = they match, 1 = they don't match";
     init_from=NULL;
    };
    ProgVar @[12] {
     name="row_zero";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="always 0";
     init_from=NULL;
    };
    ProgVar @[13] {
     name="last_row";
     var_type=T_Int;
     int_val=-1;
     objs_ptr=0;
     flags=EDIT_VAL;
     reference=0;
     desc="always -1";
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    MethodCall @[0] {
     desc="get layer";
     flags=;
     result_var=.projects[0].programs[3].vars[0]$$;
     obj=.projects[0].programs[3].args[0]$$;
     method=Network::FindLayer;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="nm";
       required=1;
       def_val=;
       expr {
	expr="output_lay_name";
       };
      };
     };
    };
    ResetDataRows @[1] {
     desc=;
     flags=;
     data_var=.projects[0].programs[3].vars[2]$$;
    };
    MethodCall @[2] {
     desc="get data to table";
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[3].vars[0]$;
     method=LeabraLayer::VarToTable;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dt";
       required=1;
       def_val=;
       expr {
	expr="CurTrialData";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="variable";
       required=1;
       def_val="\"\"";
       expr {
	expr="variable";
       };
      };
     };
    };
    DataAnalCall @[3] {
     desc="compute the appropriate distances";
     flags=;
     result_var=NULL;
     object_type=taDataAnal;
     method=taDataAnal::CrossDistMatrix;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="dist_mat";
       required=1;
       def_val=;
       expr {
	expr="OutputTargetDistMatrix";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src_data_a";
       required=1;
       def_val=;
       expr {
	expr="CurTrialData";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="data_col_nm_a";
       required=1;
       def_val=;
       expr {
	expr="CurTrialData.data[0].name";
       };
      };
      ProgArg @[3] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src_data_b";
       required=1;
       def_val=;
       expr {
	expr="target_input_data";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="data_col_nm_b";
       required=1;
       def_val=;
       expr {
	expr="target_col_name";
       };
      };
      ProgArg @[5] {
       arg_type=taMath::DistMetric;
       type="taMath::DistMetric";
       name="metric";
       required=1;
       def_val=;
       expr {
	expr="dist_metric";
       };
      };
      ProgArg @[6] {
       arg_type=bool;
       type="bool";
       name="norm";
       required=0;
       def_val="false";
       expr {
	expr="dist_norm";
       };
      };
      ProgArg @[7] {
       arg_type=float;
       type="float";
       name="tol";
       required=0;
       def_val="0.0f";
       expr {
	expr="dist_tol";
       };
      };
      ProgArg @[8] {
       arg_type=bool;
       type="bool";
       name="incl_scalars";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MathCall @[4] {
     desc="find min dist val and index";
     flags=;
     result_var=.projects[0].programs[3].vars[6]$$;
     object_type=taMath_float;
     method=taMath_float::vec_min;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_float_Matrix_ptr;
       type="const float_Matrix*";
       name="vec";
       required=1;
       def_val=;
       expr {
	expr="OutputTargetDistMatrix";
       };
      };
      ProgArg @[1] {
       arg_type=int_ref;
       type="int&";
       name="idx";
       required=1;
       def_val=;
       expr {
	expr="min_idx";
       };
      };
     };
    };
    DataVarProg @[5] {
     desc="get name of the minimum input/output pair";
     flags=;
     data_var=.projects[0].programs[3].args[3]$$;
     set_data=0;
     row_spec=ROW_NUM;
     row_var=.projects[0].programs[3].vars[7]$$;
     quiet=1;
     var_1=.projects[0].programs[3].vars[8]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    AssignExpr @[6] {
     desc="actually gets the input part of the name";
     flags=;
     result_var=.projects[0].programs[3].vars[9]$$;
     expr {
      expr="Name";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=;
     result_var=.projects[0].programs[3].vars[10]$$;
     expr {
      expr="network.trial_name";
     };
    };
    IfElse @[8] {
     desc="computes err based on whether it was the same or not";
     flags=;
     cond {
      expr="trial_name == closest_name";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=.projects[0].programs[3].vars[11]$$;
       expr {
	expr="0.0";
       };
      };
     };
     false_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=;
       result_var=$.projects[0].programs[3].vars[11]$;
       expr {
	expr="1.0";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[4] {
   name="NameUnitsLoadWeights";
   short_nm="NmnLWg";
   tags=;
   desc="name the units in the network and load weights";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="network to train";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].data.gp[0][0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="datatable with training patterns";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="unit_names";
     var_type=T_Object;
     object_type=taOBase;
     object_val=.projects[0].data.gp[0][1]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    InitNamedUnits @[0] {
     desc=;
     flags=;
     input_data_var=.projects[0].programs[4].args[1]$$;
     unit_names_var=.projects[0].programs[4].vars[0]$$;
     network_var=.projects[0].programs[4].args[0]$$;
     n_lay_name_chars=1;
     max_unit_chars=-1;
    };
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    MethodCall @[0] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[4].args[0]$;
     method=Network::LoadWeights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       expr {
	expr="\"dyslex_trained.wts.gz\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="quiet";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[4].args[0]$;
     method=taBase::StructUpdate;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       expr {
	expr="true";
       };
      };
     };
    };
    MethodCall @[2] {
     desc="triggers update of view to show the unit names";
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[4].args[0]$;
     method=taBase::StructUpdate;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       expr {
	expr="false";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[5] {
   name="GetSimilarPatterns";
   short_nm="GSmlPt";
   tags=;
   desc="compute the paterns that have above-threshold similarity to each other in Phonology and Semantics";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=DataTable;
    el_def=0;
    DataTable @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="N_ROWS";
       value 2 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="AUTO_SCALE";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="DistMatrix";
     desc="phonological distance matrix";
     data {
      name="data";
      el_typ=float_Data;
      el_def=0;
      float_Data @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItemBase;
	el_def=0;
	UserDataItem @[0] {
	 name="TOP_ZERO";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="TrainEnv_DistMatrix";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 40;40;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
      };
     };
     data_flags=AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[1] {
     name="OrthoClosePats";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="tart_tttartt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tent_tttentt";"hare_hhhArrr";"tact_ttt@ktt";"fact_fff@ktt";"past_ppp@stt";;;;       };
      };
      String_Data @[1] {
       name="tent_tttentt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";"tact_ttt@ktt";"rent_rrrentt";"hint_hhhintt";;;;;       };
      };
      String_Data @[2] {
       name="face_fffAsss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "hare_hhhArrr";"wave_wwwAvvv";"case_kkkAsss";"tact_ttt@ktt";"fact_fff@ktt";"lack_lll@kkk";"wage_wwwAjjj";"ease_---Ezzz";       };
      };
      String_Data @[3] {
       name="deer_dddErrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "reed_rrrEddd";"deed_dddEddd";"need_nnnEddd";;;;;;       };
      };
      String_Data @[4] {
       name="coat_kkkOttt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "post_pppOstt";"cost_kkkostt";"loan_lllOnnn";;;;;;       };
      };
      String_Data @[5] {
       name="grin_grrinnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "gain_gggAnnn";;;;;;;;       };
      };
      String_Data @[6] {
       name="lock_lllakkk";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "loon_lllUnnn";"lack_lll@kkk";"loss_lllosss";"loan_lllOnnn";;;;;       };
      };
      String_Data @[7] {
       name="rope_rrrOppp";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "role_rrrOlll";;;;;;;;       };
      };
      String_Data @[8] {
       name="hare_hhhArrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";"face_fffAsss";"wave_wwwAvvv";"case_kkkAsss";"hire_hhhIrrr";"wage_wwwAjjj";"ease_---Ezzz";;       };
      };
      String_Data @[9] {
       name="lass_lll_sss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "case_kkkAsss";"lack_lll@kkk";"loss_lllosss";"ease_---Ezzz";"past_ppp@stt";;;;       };
      };
      String_Data @[10] {
       name="flan_fllonnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flea_fllE---";"flag_fll@ggg";"plan_pll@nnn";"loan_lllOnnn";"flaw_fllo---";;;;       };
      };
      String_Data @[11] {
       name="hind_hhhIndd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "hire_hhhIrrr";"hint_hhhintt";;;;;;;       };
      };
      String_Data @[12] {
       name="wave_wwwAvvv";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"hare_hhhArrr";"case_kkkAsss";"wage_wwwAjjj";"ease_---Ezzz";;;;       };
      };
      String_Data @[13] {
       name="flea_fllE_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flan_fllonnn";"flag_fll@ggg";"plea_pllE---";"flaw_fllo---";;;;;       };
      };
      String_Data @[14] {
       name="star_sttarrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "stay_sttA---";;;;;;;;       };
      };
      String_Data @[15] {
       name="reed_rrrEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"rent_rrrentt";"deed_dddEddd";"need_nnnEddd";;;;;       };
      };
      String_Data @[16] {
       name="loon_lllUnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lock_lllakkk";"loss_lllosss";"loan_lllOnnn";;;;;;       };
      };
      String_Data @[17] {
       name="case_kkkAsss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"hare_hhhArrr";"lass_lll@sss";"wave_wwwAvvv";"cost_kkkostt";"wage_wwwAjjj";"ease_---Ezzz";"past_ppp@stt";       };
      };
      String_Data @[18] {
       name="flag_fll_ggg";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flan_fllonnn";"flea_fllE---";"plan_pll@nnn";"flaw_fllo---";;;;;       };
      };
      String_Data @[19] {
       name="post_pppOstt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "coat_kkkOttt";"cost_kkkostt";"loss_lllosss";"past_ppp@stt";;;;;       };
      };
      String_Data @[20] {
       name="tact_ttt_ktt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";"tent_tttentt";"face_fffAsss";"fact_fff@ktt";"lack_lll@kkk";"past_ppp@stt";;;       };
      };
      String_Data @[21] {
       name="rent_rrrentt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tent_tttentt";"reed_rrrEddd";"hint_hhhintt";;;;;;       };
      };
      String_Data @[22] {
       name="fact_fff_ktt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";"face_fffAsss";"tact_ttt@ktt";"lack_lll@kkk";"past_ppp@stt";;;;       };
      };
      String_Data @[23] {
       name="deed_dddEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"reed_rrrEddd";"need_nnnEddd";;;;;;       };
      };
      String_Data @[24] {
       name="cost_kkkostt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "coat_kkkOttt";"case_kkkAsss";"post_pppOstt";"loss_lllosss";"past_ppp@stt";;;;       };
      };
      String_Data @[25] {
       name="gain_gggAnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "grin_grrinnn";;;;;;;;       };
      };
      String_Data @[26] {
       name="lack_lll_kkk";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"lock_lllakkk";"lass_lll@sss";"tact_ttt@ktt";"fact_fff@ktt";;;;       };
      };
      String_Data @[27] {
       name="role_rrrOlll";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rope_rrrOppp";;;;;;;;       };
      };
      String_Data @[28] {
       name="hire_hhhIrrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "hare_hhhArrr";"hind_hhhIndd";"hint_hhhintt";;;;;;       };
      };
      String_Data @[29] {
       name="loss_lllosss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lock_lllakkk";"lass_lll@sss";"loon_lllUnnn";"post_pppOstt";"cost_kkkostt";"loan_lllOnnn";;;       };
      };
      String_Data @[30] {
       name="plan_pll_nnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flan_fllonnn";"flag_fll@ggg";"plea_pllE---";"loan_lllOnnn";"flaw_fllo---";;;;       };
      };
      String_Data @[31] {
       name="hint_hhhintt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tent_tttentt";"hind_hhhIndd";"rent_rrrentt";"hire_hhhIrrr";;;;;       };
      };
      String_Data @[32] {
       name="wage_wwwAjjj";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"hare_hhhArrr";"wave_wwwAvvv";"case_kkkAsss";"ease_---Ezzz";;;;       };
      };
      String_Data @[33] {
       name="plea_pllE_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flea_fllE---";"plan_pll@nnn";;;;;;;       };
      };
      String_Data @[34] {
       name="stay_sttA_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "star_sttarrr";;;;;;;;       };
      };
      String_Data @[35] {
       name="need_nnnEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"reed_rrrEddd";"deed_dddEddd";;;;;;       };
      };
      String_Data @[36] {
       name="loan_lllOnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "coat_kkkOttt";"lock_lllakkk";"flan_fllonnn";"loon_lllUnnn";"loss_lllosss";"plan_pll@nnn";;;       };
      };
      String_Data @[37] {
       name="ease_Ezzz";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"hare_hhhArrr";"lass_lll@sss";"wave_wwwAvvv";"case_kkkAsss";"wage_wwwAjjj";"past_ppp@stt";;       };
      };
      String_Data @[38] {
       name="flaw_fllo_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flan_fllonnn";"flea_fllE---";"flag_fll@ggg";"plan_pll@nnn";;;;;       };
      };
      String_Data @[39] {
       name="past_ppp_stt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";"lass_lll@sss";"case_kkkAsss";"post_pppOstt";"tact_ttt@ktt";"fact_fff@ktt";"cost_kkkostt";"ease_---Ezzz";       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[2] {
     name="SemClosePats";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="tart_tttartt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flan_fllonnn";;;;;;;;       };
      };
      String_Data @[1] {
       name="tent_tttentt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"hind_hhhIndd";;;;;;;       };
      };
      String_Data @[2] {
       name="face_fffAsss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "coat_kkkOttt";"grin_grrinnn";"lass_lll@sss";"flea_fllE---";"reed_rrrEddd";"loon_lllUnnn";"flag_fll@ggg";;       };
      };
      String_Data @[3] {
       name="deer_dddErrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tent_tttentt";"hare_hhhArrr";"lass_lll@sss";"hind_hhhIndd";"wave_wwwAvvv";"reed_rrrEddd";"loon_lllUnnn";;       };
      };
      String_Data @[4] {
       name="coat_kkkOttt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"grin_grrinnn";"flag_fll@ggg";;;;;;       };
      };
      String_Data @[5] {
       name="grin_grrinnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"coat_kkkOttt";"lass_lll@sss";"wave_wwwAvvv";"flea_fllE---";;;;       };
      };
      String_Data @[6] {
       name="lock_lllakkk";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rope_rrrOppp";"case_kkkAsss";"post_pppOstt";;;;;;       };
      };
      String_Data @[7] {
       name="rope_rrrOppp";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lock_lllakkk";"case_kkkAsss";"flag_fll@ggg";"post_pppOstt";;;;;       };
      };
      String_Data @[8] {
       name="hare_hhhArrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"lass_lll@sss";"hind_hhhIndd";"wave_wwwAvvv";"flea_fllE---";"reed_rrrEddd";"loon_lllUnnn";;       };
      };
      String_Data @[9] {
       name="lass_lll_sss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"deer_dddErrr";"grin_grrinnn";"hare_hhhArrr";"hind_hhhIndd";"flea_fllE---";"reed_rrrEddd";"loon_lllUnnn";       };
      };
      String_Data @[10] {
       name="flan_fllonnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tart_tttartt";;;;;;;;       };
      };
      String_Data @[11] {
       name="hind_hhhIndd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tent_tttentt";"deer_dddErrr";"hare_hhhArrr";"lass_lll@sss";"wave_wwwAvvv";"reed_rrrEddd";"loon_lllUnnn";;       };
      };
      String_Data @[12] {
       name="wave_wwwAvvv";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deer_dddErrr";"grin_grrinnn";"hare_hhhArrr";"hind_hhhIndd";"reed_rrrEddd";"loon_lllUnnn";;;       };
      };
      String_Data @[13] {
       name="flea_fllE_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"grin_grrinnn";"hare_hhhArrr";"lass_lll@sss";;;;;       };
      };
      String_Data @[14] {
       name="star_sttarrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "flag_fll@ggg";;;;;;;;       };
      };
      String_Data @[15] {
       name="reed_rrrEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"deer_dddErrr";"hare_hhhArrr";"lass_lll@sss";"hind_hhhIndd";"wave_wwwAvvv";"loon_lllUnnn";;       };
      };
      String_Data @[16] {
       name="loon_lllUnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"deer_dddErrr";"hare_hhhArrr";"lass_lll@sss";"hind_hhhIndd";"wave_wwwAvvv";"reed_rrrEddd";;       };
      };
      String_Data @[17] {
       name="case_kkkAsss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lock_lllakkk";"rope_rrrOppp";"flag_fll@ggg";"post_pppOstt";;;;;       };
      };
      String_Data @[18] {
       name="flag_fll_ggg";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "face_fffAsss";"coat_kkkOttt";"rope_rrrOppp";"star_sttarrr";"case_kkkAsss";"post_pppOstt";;;       };
      };
      String_Data @[19] {
       name="post_pppOstt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lock_lllakkk";"rope_rrrOppp";"case_kkkAsss";"flag_fll@ggg";;;;;       };
      };
      String_Data @[20] {
       name="tact_ttt_ktt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rent_rrrentt";"ease_---Ezzz";;;;;;;       };
      };
      String_Data @[21] {
       name="rent_rrrentt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tact_ttt@ktt";"cost_kkkostt";"hire_hhhIrrr";"wage_wwwAjjj";"loan_lllOnnn";;;;       };
      };
      String_Data @[22] {
       name="fact_fff_ktt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] ;;;;;;;;       };
      };
      String_Data @[23] {
       name="deed_dddEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "gain_gggAnnn";"ease_---Ezzz";;;;;;;       };
      };
      String_Data @[24] {
       name="cost_kkkostt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rent_rrrentt";"loss_lllosss";"wage_wwwAjjj";"loan_lllOnnn";;;;;       };
      };
      String_Data @[25] {
       name="gain_gggAnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "deed_dddEddd";"loss_lllosss";;;;;;;       };
      };
      String_Data @[26] {
       name="lack_lll_kkk";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "plan_pll@nnn";"hint_hhhintt";"plea_pllE---";"need_nnnEddd";"loan_lllOnnn";"flaw_fllo---";;;       };
      };
      String_Data @[27] {
       name="role_rrrOlll";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] ;;;;;;;;       };
      };
      String_Data @[28] {
       name="hire_hhhIrrr";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rent_rrrentt";"wage_wwwAjjj";"stay_sttA---";"loan_lllOnnn";;;;;       };
      };
      String_Data @[29] {
       name="loss_lllosss";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "cost_kkkostt";"gain_gggAnnn";;;;;;;       };
      };
      String_Data @[30] {
       name="plan_pll_nnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lack_lll@kkk";"hint_hhhintt";"need_nnnEddd";"loan_lllOnnn";"flaw_fllo---";;;;       };
      };
      String_Data @[31] {
       name="hint_hhhintt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lack_lll@kkk";"plan_pll@nnn";"plea_pllE---";"need_nnnEddd";"loan_lllOnnn";;;;       };
      };
      String_Data @[32] {
       name="wage_wwwAjjj";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rent_rrrentt";"cost_kkkostt";"hire_hhhIrrr";"loan_lllOnnn";;;;;       };
      };
      String_Data @[33] {
       name="plea_pllE_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lack_lll@kkk";"hint_hhhintt";"need_nnnEddd";"flaw_fllo---";;;;;       };
      };
      String_Data @[34] {
       name="stay_sttA_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "hire_hhhIrrr";;;;;;;;       };
      };
      String_Data @[35] {
       name="need_nnnEddd";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lack_lll@kkk";"plan_pll@nnn";"hint_hhhintt";"plea_pllE---";"loan_lllOnnn";"flaw_fllo---";;;       };
      };
      String_Data @[36] {
       name="loan_lllOnnn";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "rent_rrrentt";"cost_kkkostt";"lack_lll@kkk";"hire_hhhIrrr";"plan_pll@nnn";"hint_hhhintt";"wage_wwwAjjj";"need_nnnEddd";       };
      };
      String_Data @[37] {
       name="ease_Ezzz";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "tact_ttt@ktt";"deed_dddEddd";;;;;;;       };
      };
      String_Data @[38] {
       name="flaw_fllo_";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] "lack_lll@kkk";"plan_pll@nnn";"plea_pllE---";"need_nnnEddd";;;;;       };
      };
      String_Data @[39] {
       name="past_ppp_stt";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [8] ;;;;;;;;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].data.gp[0][0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="table of patterns to present to the network, one row at a time";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="DistMatrix";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].programs[5].objs[0]$$;
     objs_ptr=1;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="OrthoClosePats";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].programs[5].objs[1]$;
     objs_ptr=1;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="ortho_dist_thr";
     var_type=T_Real;
     real_val=4;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="distance threshold (in HAMMING distance units) for considering something to be close";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="sem_dist_thr";
     var_type=T_Real;
     real_val=0.4;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="distance threshold (in normalized inner product distance units) for considering something to be close";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="id_row";
     var_type=T_Int;
     int_val=40;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="dst_row";
     var_type=T_Int;
     int_val=40;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="trg_row";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[7] {
     name="dst_val";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[8] {
     name="Name";
     var_type=T_String;
     string_val="past_ppp_stt";
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[9] {
     name="SemClosePats";
     var_type=T_Object;
     object_type=DataTable;
     object_val=$.projects[0].programs[5].objs[2]$;
     objs_ptr=1;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
    Function @[0] {
     desc=;
     flags=;
     name="GetSimPats";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="close_pats";
       var_type=T_Object;
       object_type=DataTable;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="dist_thr";
       var_type=T_Real;
       real_val=0;
       objs_ptr=0;
       flags=LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="distance threshold for considering something to be close";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="larger_further";
       var_type=T_Bool;
       bool_val=0;
       objs_ptr=0;
       flags=LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="which way does value go relative to distance";
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=;
       result_var=NULL;
       obj=.projects[0].programs[5].functions[0].args[0]$$;
       method=DataTable::RemoveAllCols;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
      };
      ForLoop @[1] {
       desc="loop over input data items (columns of resulting table)";
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	DataVarProg @[0] {
	 desc=;
	 flags=;
	 data_var=.projects[0].programs[5].args[0]$$;
	 set_data=0;
	 row_spec=ROW_NUM;
	 row_var=.projects[0].programs[5].vars[4]$$;
	 quiet=0;
	 var_1=.projects[0].programs[5].vars[8]$$;
	 var_2=NULL;
	 var_3=NULL;
	 var_4=NULL;
	};
	MiscCall @[1] {
	 desc="make name legal col name";
	 flags=;
	 result_var=$.projects[0].programs[5].vars[8]$;
	 object_type=taMisc;
	 method=taMisc::StringCVar;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="str";
	   required=1;
	   def_val="\"\"";
	   expr {
	    expr="Name";
	   };
	  };
	 };
	};
	MethodCall @[2] {
	 desc="make column name";
	 flags=;
	 result_var=NULL;
	 obj=$.projects[0].programs[5].functions[0].args[0]$;
	 method=DataTable::FindMakeCol;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="col_nm";
	   required=1;
	   def_val=;
	   expr {
	    expr="Name";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=taBase::ValType;
	   type="taBase::ValType";
	   name="val_type";
	   required=1;
	   def_val="taBase::VT_FLOAT";
	   expr {
	    expr="taBase::VT_STRING";
	   };
	  };
	 };
	};
	AssignExpr @[3] {
	 desc=;
	 flags=;
	 result_var=.projects[0].programs[5].vars[6]$$;
	 expr {
	  expr="0";
	 };
	};
	ForLoop @[4] {
	 desc="loop over other patterns to find closest items";
	 flags=;
	 loop_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=;
	   result_var=.projects[0].programs[5].vars[7]$$;
	   obj=.projects[0].programs[5].vars[0]$$;
	   method=DataTable::GetMatrixVal;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Variant;
	     type="Variant";
	     name="col";
	     required=1;
	     def_val=;
	     expr {
	      expr="0";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     expr {
	      expr="0";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="d0";
	     required=1;
	     def_val=;
	     expr {
	      expr="id_row";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=int;
	     type="int";
	     name="d1";
	     required=0;
	     def_val="0";
	     expr {
	      expr="dst_row";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=int;
	     type="int";
	     name="d2";
	     required=0;
	     def_val="0";
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=int;
	     type="int";
	     name="d3";
	     required=0;
	     def_val="0";
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	  IfContinue @[1] {
	   desc=;
	   flags=;
	   cond {
	    expr="id_row == dst_row";
	   };
	  };
	  IfContinue @[2] {
	   desc=;
	   flags=;
	   cond {
	    expr="(larger_further && (dst_val >  dist_thr)) || (!larger_further && (dst_val < dist_thr))";
	   };
	  };
	  If @[3] {
	   desc=;
	   flags=;
	   cond {
	    expr="close_pats.rows <= trg_row";
	   };
	   true_code {
	    name=;
	    el_typ=ProgEl;
	    el_def=0;
	    AddNewDataRow @[0] {
	     desc=;
	     flags=;
	     data_var=$.projects[0].programs[5].functions[0].args[0]$;
	    };
	   };
	  };
	  DataVarProg @[4] {
	   desc=;
	   flags=;
	   data_var=$.projects[0].programs[5].args[0]$;
	   set_data=0;
	   row_spec=ROW_NUM;
	   row_var=.projects[0].programs[5].vars[5]$$;
	   quiet=0;
	   var_1=$.projects[0].programs[5].vars[8]$;
	   var_2=NULL;
	   var_3=NULL;
	   var_4=NULL;
	  };
	  MethodCall @[5] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   obj=$.projects[0].programs[5].functions[0].args[0]$;
	   method=DataTable::SetVal;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="const Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     expr {
	      expr="Name";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=Variant;
	     type="Variant";
	     name="col";
	     required=1;
	     def_val=;
	     expr {
	      expr="id_row";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     expr {
	      expr="trg_row";
	     };
	    };
	   };
	  };
	  VarIncr @[6] {
	   desc=;
	   flags=;
	   var=$.projects[0].programs[5].vars[6]$;
	   expr {
	    expr="1";
	   };
	  };
	 };
	 init {
	  expr="dst_row = 0";
	 };
	 test {
	  expr="dst_row < input_data.rows";
	 };
	 iter {
	  expr="dst_row++";
	 };
	};
       };
       init {
	expr="id_row = 0";
       };
       test {
	expr="id_row < input_data.rows";
       };
       iter {
	expr="id_row++";
       };
      };
     };
    };
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    DataAnalCall @[0] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataAnal;
     method=taDataAnal::DistMatrixTable;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dist_mat";
       required=1;
       def_val=;
       expr {
	expr="DistMatrix";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="view";
       required=1;
       def_val=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src_data";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="data_col_nm";
       required=1;
       def_val=;
       expr {
	expr="\"Orthography\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="name_col_nm";
       required=1;
       def_val=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[5] {
       arg_type=taMath::DistMetric;
       type="taMath::DistMetric";
       name="metric";
       required=1;
       def_val=;
       expr {
	expr="taMath::HAMMING";
       };
      };
      ProgArg @[6] {
       arg_type=bool;
       type="bool";
       name="norm";
       required=0;
       def_val="false";
       expr {
	expr="false";
       };
      };
      ProgArg @[7] {
       arg_type=float;
       type="float";
       name="tol";
       required=0;
       def_val="0.0f";
       expr {
	expr="0.5";
       };
      };
      ProgArg @[8] {
       arg_type=bool;
       type="bool";
       name="incl_scalars";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=;
     result_var=NULL;
     fun=.projects[0].programs[5].functions[0]$$;
     fun_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="close_pats";
       required=1;
       def_val=;
       expr {
	expr="OrthoClosePats";
       };
      };
      ProgArg @[1] {
       arg_type=double;
       type="double";
       name="dist_thr";
       required=1;
       def_val=;
       expr {
	expr="ortho_dist_thr";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="larger_further";
       required=1;
       def_val=;
       expr {
	expr="true";
       };
      };
     };
    };
    DataAnalCall @[2] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taDataAnal;
     method=taDataAnal::DistMatrixTable;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dist_mat";
       required=1;
       def_val=;
       expr {
	expr="DistMatrix";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="view";
       required=1;
       def_val=;
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src_data";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="data_col_nm";
       required=1;
       def_val=;
       expr {
	expr="\"Semantics\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="name_col_nm";
       required=1;
       def_val=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[5] {
       arg_type=taMath::DistMetric;
       type="taMath::DistMetric";
       name="metric";
       required=1;
       def_val=;
       expr {
	expr="taMath::INNER_PROD";
       };
      };
      ProgArg @[6] {
       arg_type=bool;
       type="bool";
       name="norm";
       required=0;
       def_val="false";
       expr {
	expr="true";
       };
      };
      ProgArg @[7] {
       arg_type=float;
       type="float";
       name="tol";
       required=0;
       def_val="0.0f";
       expr {
	expr="0.5";
       };
      };
      ProgArg @[8] {
       arg_type=bool;
       type="bool";
       name="incl_scalars";
       required=0;
       def_val="false";
       expr {
	expr=;
       };
      };
     };
    };
    FunctionCall @[3] {
     desc=;
     flags=;
     result_var=NULL;
     fun=$.projects[0].programs[5].functions[0]$;
     fun_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="close_pats";
       required=1;
       def_val=;
       expr {
	expr="SemClosePats";
       };
      };
      ProgArg @[1] {
       arg_type=double;
       type="double";
       name="dist_thr";
       required=1;
       def_val=;
       expr {
	expr="sem_dist_thr";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="larger_further";
       required=1;
       def_val=;
       expr {
	expr="false";
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=260;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=77;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][1].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=-1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][1].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[6]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     If @[3] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
     AssignExpr @[4] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[5] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=1;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[6] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=37;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][2].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][2].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[4] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraTrial*";
       };
      };
      data_var=.projects[0].programs.gp[0][2].args[1]$$;
      index_var=.projects[0].programs.gp[0][2].vars[4]$$;
      order_var=.projects[0].programs.gp[0][2].vars[0]$$;
      order=PERMUTED;
      item_idx_list{ 30;25;3;20;12;7;35;11;32;15;19;8;33;18;27;16;24;13;9;29;36;2;21;4;23;28;39;6;22;10;31;37;5;0;1;38;34;14;17;26;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[8] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     ProgramCall @[1] {
      desc=;
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs[0]$$;
      targ_ld_init="*RotateTrainingLayers*";
     };
     MethodCall @[2] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[3] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][4]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[4] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[5] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=;
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values based on changes computed by trial program";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     ProgramCall @[6] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[7] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][4].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][4].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][5]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     If @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][5].args[0]$;
      update_var=.projects[0].programs.gp[0][5].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Orthography";
	net_target=LAYER;
	layer_name="Orthography";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Semantics";
	net_target=LAYER;
	layer_name="Semantics";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Phonology";
	net_target=LAYER;
	layer_name="Phonology";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][1]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][8].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$.projects[0].programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[2]$$;
      obj=.projects[0].programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[1] {
   name="LeabraAll_Test";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All, Test";
   desc="The full set of programs for testing a standard Leabra network (starting with Epoch)";
   Program @[0] {
    name="LesionTest";
    short_nm="LsnTst";
    tags=;
    desc="runs various lesion tests";
    flags=;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="LesionType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="NO_LESION";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="SEMANTICS_FULL";
	value=1;
	desc="lesion entire semantic pathway";
       };
       DynEnumItem @[2] {
	name="DIRECT_FULL";
	value=2;
	desc="lesion entire direct pathway = OP_HID_FULL";
       };
       DynEnumItem @[3] {
	name="OS_HID";
	value=3;
	desc="partial amounts of Othro -> Semantics hidden";
       };
       DynEnumItem @[4] {
	name="SP_HID";
	value=4;
	desc="partial amounts of Semantics -> Phonology hidden";
       };
       DynEnumItem @[5] {
	name="OP_HID";
	value=5;
	desc="partial amounts of Orthography -> Phonology hidden (= DIRECT_PARTIAL)";
       };
       DynEnumItem @[6] {
	name="OS_HID_DIRECT_FULL";
	value=6;
	desc="partial amounts of Othro -> Semantics hidden + complete OP_HID (DIRECT_FULL)";
       };
       DynEnumItem @[7] {
	name="SP_HID_DIRECT_FULL";
	value=7;
	desc="partial amounts of Semantics -> Phonology hidden + complete OP_HID (DIRECT_FULL)";
       };
       DynEnumItem @[8] {
	name="OP_HID_SEMANTICS_FULL";
	value=8;
	desc="partial amounts of Orthography -> Phonology hidden (= DIRECT_PARTIAL) + SEMANTICS_FULL";
       };
       DynEnumItem @[9] {
	name="ALL_PARTIAL";
	value=9;
	desc="perform all partial lesions in sequence";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="lesion_type";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="lesion_pct";
      var_type=T_Real;
      real_val=0.1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="proportion of units in the layer (between 0-1) to lesion";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="les_all_pct_step";
      var_type=T_Real;
      real_val=0.1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="increments in lesion_pct amount to make for the ALL_PARTIAL case";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="les_all_cur_pct";
      var_type=T_Real;
      real_val=1.1;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current lesion_pct for the ALL_PARTIAL case";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="les_all_nrep";
      var_type=T_Int;
      int_val=25;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="number of repetitions at a given lesion level for the ALL_PARTIAL case";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="les_all_cur_type";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=$.projects[0].programs.gp[1][0].types[0]$;
       value=9;
      };
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current lesion type for the ALL_PARTIAL case";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="OS_Hid";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=.projects[0].networks[0].layers[1]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="Semantics";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=.projects[0].networks[0].layers[2]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="SP_Hid";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=.projects[0].networks[0].layers[3]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="OP_Hid";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=.projects[0].networks[0].layers[4]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="cur_lesion";
      var_type=T_String;
      string_val="NO_LESION";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- name of current lesion";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="cur_les_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- number of current lesion";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="cur_les_pct";
      var_type=T_Real;
      real_val=0.1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- pct of current lesion";
      init_from=NULL;
     };
     ProgVar @[11] {
      name="LeabraEpochMonitorTest";
      var_type=T_Object;
      object_type=Program;
      object_val=.projects[0].programs.gp[1][7]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[12] {
      name="LeabraTrialMonitorTest";
      var_type=T_Object;
      object_type=Program;
      object_val=.projects[0].programs.gp[1][6]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[13] {
      name="i";
      var_type=T_Int;
      int_val=25;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[14] {
      name="AllEpochTestOutputData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][4]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
     Function @[0] {
      desc="un lesion the network";
      flags=;
      name="UnLesionNet";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name=;
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[7]$$;
	method=LeabraLayer::ClearLayerFlag;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Layer::LayerFlags;
	  type="Layer::LayerFlags";
	  name="flg";
	  required=1;
	  def_val=;
	  expr {
	   expr="Layer::LESIONED";
	  };
	 };
	};
       };
       MethodCall @[1] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[4]$$;
	method=LeabraLayer::ClearLayerFlag;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Layer::LayerFlags;
	  type="Layer::LayerFlags";
	  name="flg";
	  required=1;
	  def_val=;
	  expr {
	   expr="Layer::LESIONED";
	  };
	 };
	};
       };
       MethodCall @[2] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[6]$$;
	method=LeabraLayer::ClearLayerFlag;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Layer::LayerFlags;
	  type="Layer::LayerFlags";
	  name="flg";
	  required=1;
	  def_val=;
	  expr {
	   expr="Layer::LESIONED";
	  };
	 };
	};
       };
       MethodCall @[3] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[5]$$;
	method=LeabraLayer::ClearLayerFlag;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Layer::LayerFlags;
	  type="Layer::LayerFlags";
	  name="flg";
	  required=1;
	  def_val=;
	  expr {
	   expr="Layer::LESIONED";
	  };
	 };
	};
       };
       MethodCall @[4] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].args[0]$$;
	method=Network::Build;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       MethodCall @[5] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][0].args[0]$;
	method=Network::Init_Acts;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       ProgramCall @[6] {
	desc=;
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.projects[0].programs[4]$;
	targ_ld_init="*NameUnitsLoadWeights*";
       };
       MethodCall @[7] {
	desc="need to call init on this guy because the Build resets the monitors!";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[11]$$;
	method=Program::Init;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       MethodCall @[8] {
	desc="need to call init on this guy because the Build resets the monitors!";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].vars[12]$$;
	method=Program::Init;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     Function @[1] {
      desc="lesion the network according to lesion type (all cases except ALL_PARTIAL)";
      flags=;
      name="LesionNet";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name=;
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="les_type";
	var_type=T_DynEnum;
	dyn_enum_val {
	 enum_type=$.projects[0].programs.gp[1][0].types[0]$;
	 value=0;
	};
	objs_ptr=0;
	flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="les_pct";
	var_type=T_Real;
	real_val=0;
	objs_ptr=0;
	flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
	reference=0;
	desc="proportion of units in the layer (between 0-1) to lesion";
	init_from=NULL;
       };
      };
      fun_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       Switch @[0] {
	desc=;
	flags=;
	switch_var=.projects[0].programs.gp[1][0].functions[1].args[0]$$;
	cases {
	 name=;
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	  };
	  case_val {
	   expr="NO_LESION";
	  };
	 };
	 CaseBlock @[1] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   MethodCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[4]$;
	    method=LeabraLayer::SetLayerFlag;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Layer::LayerFlags;
	      type="Layer::LayerFlags";
	      name="flg";
	      required=1;
	      def_val=;
	      expr {
	       expr="Layer::LESIONED";
	      };
	     };
	    };
	   };
	   MethodCall @[1] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[5]$;
	    method=LeabraLayer::SetLayerFlag;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Layer::LayerFlags;
	      type="Layer::LayerFlags";
	      name="flg";
	      required=1;
	      def_val=;
	      expr {
	       expr="Layer::LESIONED";
	      };
	     };
	    };
	   };
	   MethodCall @[2] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[6]$;
	    method=LeabraLayer::SetLayerFlag;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Layer::LayerFlags;
	      type="Layer::LayerFlags";
	      name="flg";
	      required=1;
	      def_val=;
	      expr {
	       expr="Layer::LESIONED";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="SEMANTICS_FULL";
	  };
	 };
	 CaseBlock @[2] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   MethodCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[7]$;
	    method=LeabraLayer::SetLayerFlag;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=Layer::LayerFlags;
	      type="Layer::LayerFlags";
	      name="flg";
	      required=1;
	      def_val=;
	      expr {
	       expr="Layer::LESIONED";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="DIRECT_FULL";
	  };
	 };
	 CaseBlock @[3] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   MethodCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[4]$;
	    method=LeabraLayer::LesionUnits;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=float;
	      type="float";
	      name="p_lesion";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=bool;
	      type="bool";
	      name="permute";
	      required=0;
	      def_val="true";
	      expr {
	       expr="true";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="OS_HID";
	  };
	 };
	 CaseBlock @[4] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   MethodCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[6]$;
	    method=LeabraLayer::LesionUnits;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=float;
	      type="float";
	      name="p_lesion";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=bool;
	      type="bool";
	      name="permute";
	      required=0;
	      def_val="true";
	      expr {
	       expr="true";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="SP_HID";
	  };
	 };
	 CaseBlock @[5] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   MethodCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    obj=$.projects[0].programs.gp[1][0].vars[7]$;
	    method=LeabraLayer::LesionUnits;
	    meth_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=float;
	      type="float";
	      name="p_lesion";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=bool;
	      type="bool";
	      name="permute";
	      required=0;
	      def_val="true";
	      expr {
	       expr="true";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="OP_HID";
	  };
	 };
	 CaseBlock @[6] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   FunctionCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=.projects[0].programs.gp[1][0].functions[1]$$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="OS_HID";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	   FunctionCall @[1] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=$.projects[0].programs.gp[1][0].functions[1]$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="DIRECT_FULL";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="OS_HID_DIRECT_FULL";
	  };
	 };
	 CaseBlock @[7] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   FunctionCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=$.projects[0].programs.gp[1][0].functions[1]$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="SP_HID";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	   FunctionCall @[1] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=$.projects[0].programs.gp[1][0].functions[1]$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="DIRECT_FULL";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="SP_HID_DIRECT_FULL";
	  };
	 };
	 CaseBlock @[8] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   FunctionCall @[0] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=$.projects[0].programs.gp[1][0].functions[1]$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="OP_HID";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	   FunctionCall @[1] {
	    desc=;
	    flags=;
	    result_var=NULL;
	    fun=$.projects[0].programs.gp[1][0].functions[1]$;
	    fun_args {
	     name=;
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=DynEnum;
	      type="LesionType";
	      name="les_type";
	      required=1;
	      def_val=;
	      expr {
	       expr="SEMANTICS_FULL";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=double;
	      type="double";
	      name="les_pct";
	      required=1;
	      def_val=;
	      expr {
	       expr="les_pct";
	      };
	     };
	    };
	   };
	  };
	  case_val {
	   expr="OP_HID_SEMANTICS_FULL";
	  };
	 };
	 CaseBlock @[9] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   PrintExpr @[0] {
	    desc=;
	    flags=;
	    expr {
	     expr="\"ERROR: should not call ALL_PARTIAL here!\"";
	    };
	   };
	  };
	  case_val {
	   expr="ALL_PARTIAL";
	  };
	 };
	};
       };
       MethodCall @[1] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][0].args[0]$;
	method=taBase::StructUpdate;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=bool;
	  type="bool";
	  name="begin";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
       };
       MethodCall @[2] {
	desc="triggers update of view to show the unit names";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][0].args[0]$;
	method=taBase::StructUpdate;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=bool;
	  type="bool";
	  name="begin";
	  required=1;
	  def_val=;
	  expr {
	   expr="false";
	  };
	 };
	};
       };
      };
     };
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     FunctionCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      fun=.projects[0].programs.gp[1][0].functions[0]$$;
      fun_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ResetDataRows @[1] {
      desc=;
      flags=;
      data_var=.projects[0].programs.gp[1][0].vars[14]$$;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[1][0].vars[4]$;
      expr {
       expr="network.layers.OS_Hid";
      };
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[1][0].vars[5]$;
      expr {
       expr="network.layers.Semantics";
      };
     };
     AssignExpr @[2] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[1][0].vars[6]$;
      expr {
       expr="network.layers.SP_Hid";
      };
     };
     AssignExpr @[3] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[1][0].vars[7]$;
      expr {
       expr="network.layers.OP_Hid";
      };
     };
     Comment @[4] {
      desc="FIRST reset network to unlesioned state";
      flags=;
     };
     FunctionCall @[5] {
      desc=;
      flags=;
      result_var=NULL;
      fun=$.projects[0].programs.gp[1][0].functions[0]$;
      fun_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[6] {
      desc=;
      flags=;
      cond {
       expr="lesion_type ==  ALL_PARTIAL";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ResetDataRows @[0] {
	desc=;
	flags=;
	data_var=$.projects[0].programs.gp[1][0].vars[14]$;
       };
       ForLoop @[1] {
	desc="loop over lesion type";
	flags=;
	loop_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=;
	  result_var=.projects[0].programs.gp[1][0].vars[8]$$;
	  expr {
	   expr="les_all_cur_type";
	  };
	 };
	 AssignExpr @[1] {
	  desc=;
	  flags=;
	  result_var=.projects[0].programs.gp[1][0].vars[9]$$;
	  expr {
	   expr="les_all_cur_type";
	  };
	 };
	 ForLoop @[2] {
	  desc="loop over pct lesion";
	  flags=;
	  loop_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   AssignExpr @[0] {
	    desc=;
	    flags=;
	    result_var=.projects[0].programs.gp[1][0].vars[10]$$;
	    expr {
	     expr="les_all_cur_pct";
	    };
	   };
	   ForLoop @[1] {
	    desc="loop over repetitions";
	    flags=;
	    loop_code {
	     name=;
	     el_typ=ProgEl;
	     el_def=0;
	     FunctionCall @[0] {
	      desc=;
	      flags=;
	      result_var=NULL;
	      fun=$.projects[0].programs.gp[1][0].functions[0]$;
	      fun_args {
	       name=;
	       el_typ=ProgArg;
	       el_def=0;
	      };
	     };
	     FunctionCall @[1] {
	      desc=;
	      flags=;
	      result_var=NULL;
	      fun=$.projects[0].programs.gp[1][0].functions[1]$;
	      fun_args {
	       name=;
	       el_typ=ProgArg;
	       el_def=0;
	       ProgArg @[0] {
		arg_type=DynEnum;
		type="LesionType";
		name="les_type";
		required=1;
		def_val=;
		expr {
		 expr="les_all_cur_type";
		};
	       };
	       ProgArg @[1] {
		arg_type=double;
		type="double";
		name="les_pct";
		required=1;
		def_val=;
		expr {
		 expr="les_all_cur_pct";
		};
	       };
	      };
	     };
	     ProgramCall @[2] {
	      desc=;
	      flags=;
	      prog_args {
	       name=;
	       el_typ=ProgArg;
	       el_def=0;
	       ProgArg @[0] {
		arg_type=LeabraNetwork;
		type="LeabraNetwork*";
		name="network";
		required=1;
		def_val=;
		expr {
		 expr="network";
		};
	       };
	       ProgArg @[1] {
		arg_type=DataTable;
		type="DataTable*";
		name="input_data";
		required=1;
		def_val=;
		expr {
		 expr="input_data";
		};
	       };
	      };
	      target=.projects[0].programs.gp[1][1]$$;
	      targ_ld_init="*LeabraEpochTest*";
	     };
	    };
	    init {
	     expr="i = 0";
	    };
	    test {
	     expr="i < les_all_nrep";
	    };
	    iter {
	     expr="i++";
	    };
	   };
	  };
	  init {
	   expr="les_all_cur_pct = les_all_pct_step";
	  };
	  test {
	   expr="les_all_cur_pct < 1.0";
	  };
	  iter {
	   expr="les_all_cur_pct += les_all_pct_step";
	  };
	 };
	};
	init {
	 expr="les_all_cur_type = OS_HID";
	};
	test {
	 expr="les_all_cur_type < ALL_PARTIAL";
	};
	iter {
	 expr="les_all_cur_type++";
	};
       };
       ProgramCall @[2] {
	desc=;
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][8]$$;
	targ_ld_init="*LeabraBatchMonitorTest*";
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc=;
	flags=;
	result_var=$.projects[0].programs.gp[1][0].vars[8]$;
	expr {
	 expr="lesion_type";
	};
       };
       AssignExpr @[1] {
	desc=;
	flags=;
	result_var=$.projects[0].programs.gp[1][0].vars[9]$;
	expr {
	 expr="lesion_type";
	};
       };
       AssignExpr @[2] {
	desc=;
	flags=;
	result_var=$.projects[0].programs.gp[1][0].vars[10]$;
	expr {
	 expr="lesion_pct";
	};
       };
       FunctionCall @[3] {
	desc=;
	flags=;
	result_var=NULL;
	fun=$.projects[0].programs.gp[1][0].functions[1]$;
	fun_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=DynEnum;
	  type="LesionType";
	  name="les_type";
	  required=1;
	  def_val=;
	  expr {
	   expr="lesion_type";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=double;
	  type="double";
	  name="les_pct";
	  required=1;
	  def_val=;
	  expr {
	   expr="lesion_pct";
	  };
	 };
	};
       };
       ProgramCall @[4] {
	desc=;
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.projects[0].programs.gp[1][1]$;
	targ_ld_init="*LeabraEpochTest*";
       };
      };
     };
     ReturnExpr @[7] {
      desc="The function call below are NEVER reached -- they are here due to a bug (since fixed) in Init'ing the programs called only within a Function";
      flags=;
      expr {
       expr=;
      };
     };
     ProgramCall @[8] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.projects[0].programs[4]$;
      targ_ld_init="*NameUnitsLoadWeights*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraEpochTest";
    short_nm="EpcTst";
    tags="Leabra, Std, Test";
    desc="sets testing flag, iterates over all of the items in a data table and calls LeabraTestTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][2]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=40;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[1][1].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][1].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[1][1].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[1][1].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][1].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     MemberAssign @[1] {
      desc="set to testing mode";
      flags=NEW_EL;
      obj=$.projects[0].programs.gp[1][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TEST";
      };
      update_after=0;
     };
     ProgramCall @[2] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs[1]$$;
      targ_ld_init="*ReadingTestLayers*";
     };
     AssignExpr @[3] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[1][1].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[4] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][1].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[6] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][2]$$;
	targ_ld_init="*LeabraTrial*";
       };
      };
      data_var=.projects[0].programs.gp[1][1].args[1]$$;
      index_var=.projects[0].programs.gp[1][1].vars[4]$$;
      order_var=.projects[0].programs.gp[1][1].vars[0]$$;
      order=SEQUENTIAL;
      item_idx_list{ 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[7] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][1].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[9] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[10] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.projects[0].programs.gp[1][7]$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     MemberAssign @[11] {
      desc="set back to training mode";
      flags=NEW_EL;
      obj=$.projects[0].programs.gp[1][1].args[0]$;
      path="train_mode";
      expr {
       expr="Network::TRAIN";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraTrialTest";
    short_nm="TrlTst";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[1][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][2].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[1][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][2].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=1;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][3]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[1][2].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[1][2].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=1;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][2].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[4] {
      desc=;
      flags=;
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values based on changes computed by trial program";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     ProgramCall @[5] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.projects[0].programs.gp[1][6]$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[1][2].args[0]$;
      update_var=.projects[0].programs.gp[1][2].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraSettleTest";
    short_nm="StlTst";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[1][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][3].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[1][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][3].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[1][5]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[1][3].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[1][3].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][4]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[1][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[1][3].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][3].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     If @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][3].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[1][3].args[0]$;
      update_var=.projects[0].programs.gp[1][3].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraCycleTest";
    short_nm="CycTst";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][4].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[1][4].args[0]$;
      update_var=$.projects[0].programs.gp[1][4].vars[0]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="ApplyInputsTest";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Orthography";
	net_target=LAYER;
	layer_name="Orthography";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Semantics";
	net_target=LAYER;
	layer_name="Semantics";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Phonology";
	net_target=LAYER;
	layer_name="Phonology";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[1][5].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][5].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="LeabraTrialMonitorTest";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="group_name";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_STRING;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="closest_name";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_STRING;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="vis";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="visem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="sem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="blend";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="other";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][2]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][2]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[1][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="group_name";
      var_type=T_String;
      string_val="Abs";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="closest_name";
      var_type=T_String;
      string_val="past_ppp@stt";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="result: name of input pattern with closest distance";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="vis";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="visual";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="visem";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="visual + semantic";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="sem";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="semantic";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="blend";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="blend";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="other";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="other";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][6].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][6].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][6].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][6].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][6].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[2] {
      desc=;
      flags=;
      cond {
       expr="network.trial < 20 ";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc=;
	flags=;
	result_var=.projects[0].programs.gp[1][6].vars[2]$$;
	expr {
	 expr="\"Con\"";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc=;
	flags=;
	result_var=$.projects[0].programs.gp[1][6].vars[2]$;
	expr {
	 expr="\"Abs\"";
	};
       };
      };
     };
     ProgramCall @[3] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs[2]$$;
      targ_ld_init="*DyslexErrs*";
     };
     OtherProgramVar @[4] {
      desc=;
      flags=;
      other_prog=$.projects[0].programs[2]$;
      set_other=0;
      var_1=.projects[0].programs.gp[1][6].vars[7]$$;
      var_2=.projects[0].programs.gp[1][6].vars[8]$$;
      var_3=.projects[0].programs.gp[1][6].vars[6]$$;
      var_4=.projects[0].programs.gp[1][6].vars[4]$$;
     };
     OtherProgramVar @[5] {
      desc=;
      flags=;
      other_prog=$.projects[0].programs[2]$;
      set_other=0;
      var_1=.projects[0].programs.gp[1][6].vars[5]$$;
      var_2=.projects[0].programs.gp[1][6].vars[3]$$;
      var_3=NULL;
      var_4=NULL;
     };
     DataVarProg @[6] {
      desc=;
      flags=;
      data_var=$.projects[0].programs.gp[1][6].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=0;
      var_1=$.projects[0].programs.gp[1][6].vars[7]$;
      var_2=$.projects[0].programs.gp[1][6].vars[8]$;
      var_3=$.projects[0].programs.gp[1][6].vars[6]$;
      var_4=$.projects[0].programs.gp[1][6].vars[4]$;
     };
     DataVarProg @[7] {
      desc=;
      flags=;
      data_var=$.projects[0].programs.gp[1][6].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=0;
      var_1=$.projects[0].programs.gp[1][6].vars[5]$;
      var_2=$.projects[0].programs.gp[1][6].vars[2]$;
      var_3=$.projects[0].programs.gp[1][6].vars[3]$;
      var_4=NULL;
     };
     MethodCall @[8] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][6].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[9] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][6].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraEpochMonitorTest";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="cur_les_no";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cur_lesion";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_STRING;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="cur_les_pct";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="con_vis";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=.projects[0].programs.gp[1][7].objs[2]$$;
	agg_col {
	 col_name="vis_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Con\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="con_visem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[2]$;
	agg_col {
	 col_name="visem_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Con\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="con_sem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[2]$;
	agg_col {
	 col_name="sem_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Con\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="con_blend";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[2]$;
	agg_col {
	 col_name="blend_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Con\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="con_other";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[2]$;
	agg_col {
	 col_name="other_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Con\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[13] {
	name="abs_vis";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=.projects[0].programs.gp[1][7].objs[3]$$;
	agg_col {
	 col_name="vis_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Abs\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[14] {
	name="abs_visem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[3]$;
	agg_col {
	 col_name="visem_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Abs\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[15] {
	name="abs_sem";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[3]$;
	agg_col {
	 col_name="sem_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Abs\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[16] {
	name="abs_blend";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[3]$;
	agg_col {
	 col_name="blend_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Abs\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[17] {
	name="abs_other";
	computed=1;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=1;
	data_src=$.projects[0].programs.gp[1][7].objs[3]$;
	agg_col {
	 col_name="other_sum";
	};
	agg {name="": op=SUM: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="\"Abs\"";
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][3]$$;
      rmv_orphan_cols=1;
     };
     DataTable @[1] {
      name="GpTrialData";
      desc=;
      data {
       name="data";
       el_typ=DataColTp;
       el_def=0;
       String_Data @[0] {
	name="group_name_group";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[1] {
	name="vis_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[2] {
	name="visem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[3] {
	name="sem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[4] {
	name="blend_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[5] {
	name="other_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
      };
      data_flags=AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
     DataTable @[2] {
      name="ConTrialData";
      desc=;
      data {
       name="data";
       el_typ=DataColTp;
       el_def=0;
       String_Data @[0] {
	name="group_name_group";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[1] {
	name="vis_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[2] {
	name="visem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[3] {
	name="sem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[4] {
	name="blend_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[5] {
	name="other_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
      };
      data_flags=AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
     DataTable @[3] {
      name="AbsTrialData";
      desc=;
      data {
       name="data";
       el_typ=DataColTp;
       el_def=0;
       String_Data @[0] {
	name="group_name_group";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[1] {
	name="vis_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[2] {
	name="visem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[3] {
	name="sem_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[4] {
	name="blend_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
       float_Data @[5] {
	name="other_sum";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
       };
      };
      data_flags=AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][3]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[1][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="GpTrialData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].programs.gp[1][7].objs[1]$$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][2]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="ConTrialData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].programs.gp[1][7].objs[2]$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="AbsTrialData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].programs.gp[1][7].objs[3]$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="cur_lesion";
      var_type=T_String;
      string_val="NO_LESION";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- name of current lesion";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="cur_les_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- number of current lesion";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="cur_les_pct";
      var_type=T_Real;
      real_val=0.1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="for stats programs to access -- pct of current lesion";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="AllEpochTestOutputData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][4]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="don't do this all the time because it nukes the display -- only if mon changes!";
      flags=OFF;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][7].vars[9]$$;
      method=DataTable::Copy_NoData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_DataTable_ref;
	type="const DataTable&";
	name="cp";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     DataGroupProg @[0] {
      desc=;
      flags=;
      src_data_var=.projects[0].programs.gp[1][7].vars[3]$$;
      dest_data_var=.projects[0].programs.gp[1][7].vars[2]$$;
      group_spec {
       name="group_spec";
       ops {
	name=;
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="group_name";
	 agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[1] {
	 col_name="vis";
	 agg {name="Aggregate": op=SUM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[2] {
	 col_name="visem";
	 agg {name="Aggregate": op=SUM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[3] {
	 col_name="sem";
	 agg {name="Aggregate": op=SUM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[4] {
	 col_name="blend";
	 agg {name="Aggregate": op=SUM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[5] {
	 col_name="other";
	 agg {name="Aggregate": op=SUM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
     DataSelectRowsProg @[1] {
      desc=;
      flags=;
      src_data_var=$.projects[0].programs.gp[1][7].vars[2]$;
      dest_data_var=.projects[0].programs.gp[1][7].vars[4]$$;
      select_spec {
       name="select_spec";
       ops {
	name=;
	el_typ=DataSelectEl;
	el_def=0;
	DataSelectEl @[0] {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="Con";
	 var=NULL;
	 enable_var=NULL;
	};
       };
       comb_op=AND;
      };
     };
     DataSelectRowsProg @[2] {
      desc=;
      flags=;
      src_data_var=$.projects[0].programs.gp[1][7].vars[2]$;
      dest_data_var=.projects[0].programs.gp[1][7].vars[5]$$;
      select_spec {
       name="select_spec";
       ops {
	name=;
	el_typ=DataSelectEl;
	el_def=0;
	DataSelectEl @[0] {
	 col_name="group_name_group";
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 9 0="Abs";
	 var=NULL;
	 enable_var=NULL;
	};
       };
       comb_op=AND;
      };
     };
     MethodCall @[3] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[4] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     OtherProgramVar @[5] {
      desc=;
      flags=;
      other_prog=$.projects[0].programs.gp[1][0]$;
      set_other=0;
      var_1=.projects[0].programs.gp[1][7].vars[6]$$;
      var_2=.projects[0].programs.gp[1][7].vars[8]$$;
      var_3=.projects[0].programs.gp[1][7].vars[7]$$;
      var_4=NULL;
     };
     DataVarProg @[6] {
      desc=;
      flags=;
      data_var=$.projects[0].programs.gp[1][7].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=0;
      var_1=$.projects[0].programs.gp[1][7].vars[6]$;
      var_2=$.projects[0].programs.gp[1][7].vars[8]$;
      var_3=$.projects[0].programs.gp[1][7].vars[7]$;
      var_4=NULL;
     };
     MethodCall @[7] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     DataProcCall @[8] {
      desc="copy to all data";
      flags=;
      result_var=NULL;
      object_type=taDataProc;
      method=taDataProc::AppendRows;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dest";
	required=1;
	def_val=;
	expr {
	 expr="AllEpochTestOutputData";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="src";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraBatchMonitorTest";
    short_nm="BtcMnt";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][4]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="batch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][5]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     DataGroupProg @[0] {
      desc=;
      flags=;
      src_data_var=.projects[0].programs.gp[1][8].vars[0]$$;
      dest_data_var=.projects[0].programs.gp[1][8].vars[1]$$;
      group_spec {
       name="group_spec";
       ops {
	name=;
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="cur_les_no";
	 agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[1] {
	 col_name="cur_lesion";
	 agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[2] {
	 col_name="cur_les_pct";
	 agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[3] {
	 col_name="con_vis";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[4] {
	 col_name="con_visem";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[5] {
	 col_name="con_sem";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[6] {
	 col_name="con_blend";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[7] {
	 col_name="con_other";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[8] {
	 col_name="abs_vis";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[9] {
	 col_name="abs_visem";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[10] {
	 col_name="abs_sem";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[11] {
	 col_name="abs_blend";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[12] {
	 col_name="abs_other";
	 agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[13] {
	 col_name="con_vis";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[14] {
	 col_name="con_visem";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[15] {
	 col_name="con_sem";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[16] {
	 col_name="con_blend";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[17] {
	 col_name="con_other";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[18] {
	 col_name="abs_vis";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[19] {
	 col_name="abs_visem";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[20] {
	 col_name="abs_sem";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[21] {
	 col_name="abs_blend";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[22] {
	 col_name="abs_other";
	 agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAA1QAAAmwAAAMOAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="DyslexiaNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=1;
	  net_text_xform {scale={x=0.7000002: y=0.7000012: z=0.7000011: }: rotate={x=1: y=6.184517e-09: z=6.184522e-09: rot=1.680124: }: translate={x=0.8721693: y=0.1148174: z=-1.121007: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[5].units.gp[0][0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=39: y=12: z=2.333333: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.03;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Orthography=0;OS_Hid=0;Semantics=0;SP_Hid=0;OP_Hid=0;Phonology=0;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5420001: y=0.652592: z=1.314178: };
	 orient {x=-1.000005: y=0: z=0: rot=0.1299993: };
	 focal_dist=1.665653;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="EpochOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][1]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=17: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="avg_sse";
	    m_data=.projects[0].data.gp[1][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=14.552: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="cnt_err";
	    m_data=.projects[0].data.gp[1][1].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=40: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="avg_ext_rew";
	    m_data=.projects[0].data.gp[1][1].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="avg_cycles";
	    m_data=.projects[0].data.gp[1][1].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=70: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="epoch_time_tot";
	    m_data=.projects[0].data.gp[1][1].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="epoch_time_usr";
	    m_data=.projects[0].data.gp[1][1].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=76: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=76: };
	   range {min=0: max=76: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="cnt_err";
	   fixed_range {fix_min=1: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="avg_sse";
	   fixed_range {fix_min=1: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="avg_cycles";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.4449999: z=1.775217: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.787717;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="TrainEnv";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Orthography";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Semantics";
	    m_data=.projects[0].data.gp[0][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=14;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Phonology";
	    m_data=.projects[0].data.gp[0][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=5;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[3] {
       name="TrialTestOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][2]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][2].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][2].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="group_name";
	    m_data=.projects[0].data.gp[1][2].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="trial";
	    m_data=.projects[0].data.gp[1][2].data[3]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[1][2].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[5] {
	    name="closest_name";
	    m_data=.projects[0].data.gp[1][2].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[6] {
	    name="minus_cycles";
	    m_data=.projects[0].data.gp[1][2].data[6]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[7] {
	    name="sse";
	    m_data=.projects[0].data.gp[1][2].data[7]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[8] {
	    name="vis";
	    m_data=.projects[0].data.gp[1][2].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[9] {
	    name="visem";
	    m_data=.projects[0].data.gp[1][2].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[10] {
	    name="sem";
	    m_data=.projects[0].data.gp[1][2].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[11] {
	    name="blend";
	    m_data=.projects[0].data.gp[1][2].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[12] {
	    name="other";
	    m_data=.projects[0].data.gp[1][2].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=20;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=8;
	  col_range {min=2: max=9: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5175: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[4] {
       name="AllEpochTestOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][4]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][4].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][4].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="cur_les_no";
	    m_data=.projects[0].data.gp[1][4].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="cur_lesion";
	    m_data=.projects[0].data.gp[1][4].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=10;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="cur_les_pct";
	    m_data=.projects[0].data.gp[1][4].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[5] {
	    name="avg_sse";
	    m_data=.projects[0].data.gp[1][4].data[5]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[6] {
	    name="cnt_err";
	    m_data=.projects[0].data.gp[1][4].data[6]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[7] {
	    name="avg_cycles";
	    m_data=.projects[0].data.gp[1][4].data[7]$$;
	    m_transform=NULL;
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[8] {
	    name="con_vis";
	    m_data=.projects[0].data.gp[1][4].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[9] {
	    name="con_visem";
	    m_data=.projects[0].data.gp[1][4].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[10] {
	    name="con_sem";
	    m_data=.projects[0].data.gp[1][4].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[11] {
	    name="con_blend";
	    m_data=.projects[0].data.gp[1][4].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[12] {
	    name="con_other";
	    m_data=.projects[0].data.gp[1][4].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[13] {
	    name="abs_vis";
	    m_data=.projects[0].data.gp[1][4].data[13]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[14] {
	    name="abs_visem";
	    m_data=.projects[0].data.gp[1][4].data[14]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[15] {
	    name="abs_sem";
	    m_data=.projects[0].data.gp[1][4].data[15]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[16] {
	    name="abs_blend";
	    m_data=.projects[0].data.gp[1][4].data[16]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[17] {
	    name="abs_other";
	    m_data=.projects[0].data.gp[1][4].data[17]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=12;
	  col_range {min=3: max=14: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.022: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5175: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[5] {
       name="BatchTestOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][5]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="cur_les_no_group";
	    m_data=.projects[0].data.gp[1][5].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=3: fix_max=0: max=8: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="cur_lesion_group";
	    m_data=.projects[0].data.gp[1][5].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="cur_les_pct_group";
	    m_data=.projects[0].data.gp[1][5].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="con_vis_mean";
	    m_data=.projects[0].data.gp[1][5].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=8.32: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="con_visem_mean";
	    m_data=.projects[0].data.gp[1][5].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="con_sem_mean";
	    m_data=.projects[0].data.gp[1][5].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=3.52: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="con_blend_mean";
	    m_data=.projects[0].data.gp[1][5].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="con_other_mean";
	    m_data=.projects[0].data.gp[1][5].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="abs_vis_mean";
	    m_data=.projects[0].data.gp[1][5].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=7.28: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="abs_visem_mean";
	    m_data=.projects[0].data.gp[1][5].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="abs_sem_mean";
	    m_data=.projects[0].data.gp[1][5].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=3.32: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="abs_blend_mean";
	    m_data=.projects[0].data.gp[1][5].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="abs_other_mean";
	    m_data=.projects[0].data.gp[1][5].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[13] {
	    name="con_vis_sem";
	    m_data=.projects[0].data.gp[1][5].data[13]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[14] {
	    name="con_visem_sem";
	    m_data=.projects[0].data.gp[1][5].data[14]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[15] {
	    name="con_sem_sem";
	    m_data=.projects[0].data.gp[1][5].data[15]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[16] {
	    name="con_blend_sem";
	    m_data=.projects[0].data.gp[1][5].data[16]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[17] {
	    name="con_other_sem";
	    m_data=.projects[0].data.gp[1][5].data[17]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[18] {
	    name="abs_vis_sem";
	    m_data=.projects[0].data.gp[1][5].data[18]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[19] {
	    name="abs_visem_sem";
	    m_data=.projects[0].data.gp[1][5].data[19]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[20] {
	    name="abs_sem_sem";
	    m_data=.projects[0].data.gp[1][5].data[20]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[21] {
	    name="abs_blend_sem";
	    m_data=.projects[0].data.gp[1][5].data[21]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[22] {
	    name="abs_other_sem";
	    m_data=.projects[0].data.gp[1][5].data[22]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="cur_les_pct_group";
	   fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="cur_les_no_group";
	   fixed_range {fix_min=0: min=3: fix_max=0: max=8: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=3: max=8: };
	   range {min=3: max=8: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="con_vis_mean";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=8.32: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=8.32: };
	   range {min=0: max=8.32: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="con_sem_mean";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=3.52: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=3.52: };
	   range {min=0: max=3.52: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="abs_vis_mean";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=7.28: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=7.28: };
	   range {min=0: max=7.28: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="abs_sem_mean";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=3.32: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=3.32: };
	   range {min=0: max=3.32: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="cur_lesion_group";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="con_vis_sem";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="con_sem_sem";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="abs_vis_sem";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="abs_sem_sem";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.488047: y=0.445: z=1.695271: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.707771;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7285992503166199;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="DyslexiaNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnit";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=1: decay=0.05: g_gain=4: window=20: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.1: i=1: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="LeabraCon";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBias";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=260;
	default_val=1;
	interpolate=0;
	cur_val=1;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=100;
	 step=0;
	};
	SchedItem @[1] {
	 start_ctr=100;
	 start_val=1;
	 duration=1;
	 step=1;
	};
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.001: norm_con_n=1: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
      LeabraConSpec @[1] {
       name="SplitHiddens";
       desc=;
       unique{        };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=260;
	default_val=1;
	interpolate=0;
	cur_val=1;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=100;
	 step=0;
	};
	SchedItem @[1] {
	 start_ctr=100;
	 start_val=1;
	 duration=1;
	 step=1;
	};
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.001: norm_con_n=1: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=260;
      default_val=1;
      interpolate=0;
      cur_val=1;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=100;
       step=0;
      };
      SchedItem @[1] {
       start_ctr=100;
       start_val=1;
       duration=1;
       step=1;
      };
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.001: norm_con_n=1: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="HiddenLayer";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Orthography";
       desc=;
       unique{ kwta;compute_i;i_kwta_pt;inhib;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_PAT_K: k=4: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[1] {
       name="Semantics";
       desc=;
       unique{ kwta;compute_i;i_kwta_pt;inhib;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_PAT_K: k=18: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[2] {
       name="Phonology";
       desc=;
       unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;layer_link;inhib;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=UNIT_GROUPS;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=7: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[3] {
       name="SplitHidden";
       desc=;
       unique{ kwta;gp_kwta;inhib_group;layer_link;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=UNIT_GROUPS;
       inhib {
	type=KWTA_AVG_INHIB;
	kwta_pt=0.6;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=6: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=4: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_AVG_INHIB;
      kwta_pt=0.6;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjn";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    GpOneToOnePrjnSpec @[4] {
     name="GpOneToOne";
     desc=;
     unique{ self_con;     };
     children {
      name=;
      el_typ=GpOneToOnePrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
     n_conns=-1;
     recv_start=0;
     send_start=0;
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=39: y=12: z=3: };
    LeabraLayer @[0] {
     name="Orthography";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=8: y=6: n_not_xy=0: n=48: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=8: y=6: n_not_xy=0: n=48: };
     scaled_act_geom {x=8: y=6: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_OS_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[1]$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1]$$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_OP_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Orthography";
       from_type=SELF;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=2;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[0].projections[2];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[4].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=8: y=6: n_not_xy=0: n=48: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs[0]$$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="p";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [8 6] "c";"d";"e";"f";"g";"h";"l";"n";"p";"r";
"s";"t";"w";"a";"e";"i";"l";"o";"r";"t";
"a";"c";"e";"g";"i";"l";"n";"o";"p";"r";
"s";"v";"a";"d";"e";"g";"k";"n";"r";"s";
"t";"w";"y";;;;;;     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.07916667: max=0.95: max_i=8: };
     acts_m {cmpt=1: avg=0.07916667: max=0.95: max_i=8: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=4: pct=0.08333334: pct_c=0.9166667: adth_k=2: k_ithr=4.608634: k1_ithr=4.054872: ithr_r=0.1280126: ithr_diff=0.1201577: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.08333334: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[0]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="OS_Hid";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=5: y=1: z=1: };
     disp_scale=1;
     un_geom {x=7: y=5: n_not_xy=0: n=35: };
     unit_groups=1;
     gp_geom {x=1: y=2: n_not_xy=0: n=2: };
     gp_spc {x=0: y=1: };
     act_geom {x=7: y=11: n_not_xy=0: n=1: };
     scaled_act_geom {x=7: y=11: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Orthography";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Semantics";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=GpOneToOnePrjnSpec: spec=.projects[0].networks[0].specs[4]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1].children[1]$$: };
       recv_idx=1;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[0].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=5: n_not_xy=0: n=1: };
      units_lesioned=1;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=7: y=5: n_not_xy=0: n=35: };
       units_lesioned=0;
       output_name="n/a";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.2399942: max=0.9475082: max_i=8: };
       acts_m {cmpt=1: avg=0.2399942: max=0.9475082: max_i=8: };
       phase_dif_ratio=0.9989067;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=8: pct=0.2285714: pct_c=0.7714286: adth_k=4: k_ithr=3.195702: k1_ithr=1.529475: ithr_r=0.7368823: ithr_diff=0.5213963: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=6: z=0: };
       unique_geom=0;
       geom {x=7: y=5: n_not_xy=0: n=35: };
       units_lesioned=0;
       output_name="n/a";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.2360239: max=0.9372094: max_i=20: };
       acts_m {cmpt=1: avg=0.2360239: max=0.9372094: max_i=20: };
       phase_dif_ratio=1.000758;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=8: pct=0.2285714: pct_c=0.7714286: adth_k=2: k_ithr=6.695287: k1_ithr=3.296709: ithr_r=0.708479: ithr_diff=0.5076075: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2380091: max=0.9475082: max_i=0: };
     acts_m {cmpt=1: avg=0.2380091: max=0.9475082: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=16: pct=0.2285714: pct_c=0.7714286: adth_k=3: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[3]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Semantics";
     desc=;
     flags=;
     layer_type=TARGET;
     pos {x=12: y=0: z=2: };
     disp_scale=1;
     un_geom {x=14: y=5: n_not_xy=0: n=70: };
     unit_groups=1;
     gp_geom {x=1: y=2: n_not_xy=0: n=2: };
     gp_spc {x=0: y=1: };
     act_geom {x=14: y=11: n_not_xy=0: n=1: };
     scaled_act_geom {x=14: y=11: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_OS_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[1]$;
       spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs[4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_SP_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs[4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Semantics";
       from_type=SELF;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs[4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=2;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[2];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=16: y=4: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=14: y=5: n_not_xy=0: n=70: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1.071081;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=6: z=0: };
       unique_geom=0;
       geom {x=14: y=5: n_not_xy=0: n=70: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.02676853: max=0.9114168: max_i=15: };
       acts_m {cmpt=1: avg=0.02676853: max=0.9114168: max_i=15: };
       phase_dif_ratio=0.8708534;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [14 5] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.01338426: max=0.9114168: max_i=1: };
     acts_m {cmpt=1: avg=0.01338426: max=0.9114168: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=18: pct=0.1285714: pct_c=0.8714285: adth_k=9: k_ithr=3.975691: k1_ithr=3.52511: ithr_r=0.1202871: ithr_diff=0.1133341: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1285714: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[1]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[3] {
     name="SP_Hid";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=23: y=1: z=1: };
     disp_scale=1;
     un_geom {x=7: y=5: n_not_xy=0: n=35: };
     unit_groups=1;
     gp_geom {x=1: y=2: n_not_xy=0: n=2: };
     gp_spc {x=0: y=1: };
     act_geom {x=7: y=11: n_not_xy=0: n=1: };
     scaled_act_geom {x=7: y=11: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Semantics";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs[4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Phonology";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[5]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=1;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[5].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=5: n_not_xy=0: n=1: };
      units_lesioned=1;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=7: y=5: n_not_xy=0: n=35: };
       units_lesioned=0;
       output_name="n/a";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.2095549: max=0.9595065: max_i=23: };
       acts_m {cmpt=1: avg=0.2095549: max=0.9595065: max_i=23: };
       phase_dif_ratio=1.00007;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=8: pct=0.2285714: pct_c=0.7714286: adth_k=4: k_ithr=2.899417: k1_ithr=1.281082: ithr_r=0.8168048: ithr_diff=0.5581589: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=6: z=0: };
       unique_geom=0;
       geom {x=7: y=5: n_not_xy=0: n=35: };
       units_lesioned=0;
       output_name="n/a";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.2076982: max=0.9450992: max_i=4: };
       acts_m {cmpt=1: avg=0.2076982: max=0.9450992: max_i=4: };
       phase_dif_ratio=1.001517;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=8: pct=0.2285714: pct_c=0.7714286: adth_k=2: k_ithr=6.304874: k1_ithr=3.114794: ithr_r=0.7051598: ithr_diff=0.5059704: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2086265: max=0.9595065: max_i=0: };
     acts_m {cmpt=1: avg=0.2086265: max=0.9595065: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=16: pct=0.2285714: pct_c=0.7714286: adth_k=3: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2285714: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2].children[3]$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[4] {
     name="OP_Hid";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=10: y=0: z=0: };
     disp_scale=1;
     un_geom {x=7: y=7: n_not_xy=0: n=49: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=7: y=7: n_not_xy=0: n=49: };
     scaled_act_geom {x=7: y=7: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Phonology";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[5]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Orthography";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[0]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[0].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[5].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=7: n_not_xy=0: n=49: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="n/a";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2166877: max=0.9498661: max_i=29: };
     acts_m {cmpt=1: avg=0.2166877: max=0.9498661: max_i=29: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=12: pct=0.244898: pct_c=0.755102: adth_k=6: k_ithr=6.510625: k1_ithr=2.766778: ithr_r=0.8557522: ithr_diff=0.5750366: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.244898: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[5] {
     name="Phonology";
     desc=;
     flags=;
     layer_type=TARGET;
     pos {x=19: y=0: z=0: };
     disp_scale=1;
     un_geom {x=2: y=7: n_not_xy=0: n=14: };
     unit_groups=1;
     gp_geom {x=7: y=1: n_not_xy=0: n=7: };
     gp_spc {x=1: y=0: };
     act_geom {x=20: y=7: n_not_xy=0: n=1: };
     scaled_act_geom {x=20: y=7: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_SP_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_OP_Hid";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Phonology";
       from_type=SELF;
       from=$.projects[0].networks[0].layers[5]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[3]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[5].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=9: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="p";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06782971: max=0.9493011: max_i=8: };
       acts_m {cmpt=1: avg=0.06782971: max=0.9493011: max_i=8: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.42862: k1_ithr=3.439035: ithr_r=0.4564939: ithr_diff=0.3664991: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=3: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="p";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06677169: max=0.9304636: max_i=8: };
       acts_m {cmpt=1: avg=0.06677169: max=0.9304636: max_i=8: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.611392: k1_ithr=4.011949: ithr_r=0.3355216: ithr_diff=0.2850349: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=6: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="p";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06674954: max=0.9297811: max_i=8: };
       acts_m {cmpt=1: avg=0.06674954: max=0.9297811: max_i=8: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.581572: k1_ithr=4.004317: ithr_r=0.3320973: ithr_diff=0.2825825: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[3] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=9: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="@";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06637533: max=0.8563734: max_i=0: };
       acts_m {cmpt=1: avg=0.06637533: max=0.8563734: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=4.857337: k1_ithr=4.120387: ithr_r=0.1645433: ithr_diff=0.1517189: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[4] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=12: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="s";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06766228: max=0.9467889: max_i=9: };
       acts_m {cmpt=1: avg=0.06766228: max=0.9467889: max_i=9: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.379697: k1_ithr=3.471993: ithr_r=0.4379032: ithr_diff=0.3546118: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[5] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=15: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="t";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06810982: max=0.9534679: max_i=10: };
       acts_m {cmpt=1: avg=0.06810982: max=0.9534679: max_i=10: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.244991: k1_ithr=3.178447: ithr_r=0.5008808: ithr_diff=0.3940034: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
      LeabraUnit_Group @.gp[6] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=18: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=7: n_not_xy=0: n=14: };
       units_lesioned=0;
       output_name="t";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.06791048: max=0.9504356: max_i=10: };
       acts_m {cmpt=1: avg=0.06791048: max=0.9504356: max_i=10: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=5.295803: k1_ithr=3.307913: ithr_r=0.4705972: ithr_diff=0.3753709: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="p_p_p_@_s_t_t";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 7 7 1] "-";"d";"f";"g";"h";"k";"l";"n";"p";"r";
"s";"t";"w";;"-";"d";"f";"g";"h";"k";
"l";"n";"p";"r";"t";"w";;;"-";"d";
"f";"g";"h";"k";"l";"n";"p";"r";"t";"w";
" ";" ";"@";"A";"E";"I";"O";"U";"a";"e";
"i";"o";;;;;"-";"d";"g";"i";
"k";"l";"n";"p";"r";"s";"t";"v";"z";;
"-";"d";"g";"i";"k";"l";"n";"p";"r";"s";
"t";"v";"z";;"-";"d";"g";"i";"k";"l";
"n";"p";"r";"s";"t";"v";"z";;     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.06734412: max=0.9534679: max_i=5: };
     acts_m {cmpt=1: avg=0.06734412: max=0.9534679: max_i=5: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=7: pct=0.07142857: pct_c=0.9285714: adth_k=3: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.07142857: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[2]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name=;
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="": start={usr=759: sys=167: tot=128893841327: }: end={usr=97433: sys=10643: tot=383640755: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="": start={usr=10074: sys=1025: tot=128893874907: }: end={usr=10316: sys=1031: tot=128893875221: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=6.967420653343599e+252;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=JUST_WEIGHTS;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=475;
   n_cons=75770;
   max_size {x=39: y=12: z=3: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=40;
   time_inc=1;
   cycle_max=70;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=0;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=0;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=0;
   avg_cycles=0;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=0;
   avg_send_pct=0;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=0.005;
   maxda=0;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=1;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
