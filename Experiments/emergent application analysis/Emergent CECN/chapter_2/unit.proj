// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [3] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserData_DocLink @[0] { };
   };

      EditMbrItem_Group @.mbrs = [4] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem_Group @.gp[0] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
	EditMbrItem_Group @.gp[1] { 
	};
      };

      EditMthItem_Group @.mths = [5] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [2] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp[1] = [1] { 
      DataTable @[0] { 
    UserDataItem_List @*(.user_data_) {
	  UserData_DocLink @[0] { };
    };

	DataTableCols @.data = [6] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [1] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [12] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
	ProgVar @[10] { };
	ProgVar @[11] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [10] {
	MemberAssign @[0] { };
	MemberAssign @[1] { };
	MemberAssign @[2] { };
	MemberAssign @[3] { };
	MemberAssign @[4] { };
	MemberAssign @[5] { };
	MethodCall @[6] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[7] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[8] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[9] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
      };

      ProgEl_List @.prog_code = [0] {
      };
    };
    Program_Group @.gp[0] = [3] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetCounterInit @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [8] {
	      IfElse @[0] { 
		ProgEl_List @.true_code = [1] {
		  AssignExpr @[0] { };
		};

		ProgEl_List @.false_code = [1] {
		  AssignExpr @[0] { };
		};
	      };
	      MemberAssign @[1] { };
	      ProgramCall @[2] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      MemberAssign @[3] { };
	      NetUpdateView @[4] { };
	      NetCounterIncr @[5] { };
	      IfContinue @[6] { };
	      IfBreak @[7] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [4] {
	  PrintExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[2] { };
	  ProgramCall @[3] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [6] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [2] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [1] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [5] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		    ScaleRange @[4] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [6] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
	UserDataItem @[19] { };
	UserDataItem @[20] { };
	UserDataItem @[21] { };
	UserDataItem @[22] { };
   };

      BaseSpec_Group @.specs = [5] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraBiasSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	FullPrjnSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraUnitSpec @[4] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
      };

      Layer_Group @.layers = [2] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [1] {
	    LeabraUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [1] {
	    LeabraUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [1]		};
	      };

	      SendCons_List @.send = [0] {
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>

= Single Unit (Neuron) =

This simulation illustrates the basic properties of neural unit activation, reflecting a balance of excitatory and inhibitory influences (including leak and synaptic inhibition).

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

== Orientation to the Software (ControlPanel and Views) ==

As this is the first simulation project in the textbook, we begin with some introductory orientation.  All of the major controls and parameters for the simulation are contained within the [[.edits.ControlPanel]] object located in the middle of the 3 panels visible in the main project window (you can access it from the tab at the top of this middle panel).  The right panel contains various 3D graphical displays of simulation data, including the network (NetView or Network View) and various graphs and grid-like displays (Graph view, Grid view).

In this simulation, there are two different ways to view the results, selectable by the tabs at the top of the right side of the window:
* The [[.T3Tab.Network]] tab shows the (very simple) network that is being simulated, with a single sending (input) unit (at the bottom) that sends activation to the receiving unit (at the top).  We are primarily concerned with how the receiving unit responds to the activation input from the sending unit.
* The [[.T3Tab.CycleOutputData]] tab shows a graph of the receiving unit's main variables (see below for details) over time, in response to the sending activation.

We will see this single input being turned on and then off again, and observe the response of the receiving unit.  To see this, we can run
the simulation.

At the bottom of the [[.edits.ControlPanel]] are 4 buttons: Init, Run, Step, Stop:
# [[.programs.LeabraSettle.Init()|Init]] -- initializes the graph display and starts the simulation over from wherever it might have left off.
# [[.programs.LeabraSettle.Run()|Run]] -- runs the full set of cycles of activation updating (updating of the equations that govern the behavior of the neural unit), displaying the results in the Network and CycleOutputData frames on the right hand side of the window.
# <code>Step Cycle</code> -- runs one single cycle of activation updating (in more complex models, multiple levels of stepping will be available)
# [[.programs.LeabraSettle.Stop()|Stop]] -- if running, this will stop running.

* Text like this that is indented with a bullet all by itself (not part of a list) indicates actions to take.  In this case, hit [[.programs.LeabraSettle.Init()|Init]] and [[.programs.LeabraSettle.Run()|Run]], and look at the [[.T3Tab.Network]] display.

You should see that very shortly after the input unit comes on (indicated by the yellow color), the receiving unit is activated by this input.  To get a better idea of the precise trajectory of this activation, it is much more convenient to use the '''Graph View''', which displays the information graphically over time, allows multiple variables to be viewed at the same time, and even allows multiple runs (e.g., with different parameters) to be compared with each other.

== The Graph View ==

* Press the [[.T3Tab.CycleOutputData]] tab in the right panel to display the graph view display.

The plots produced by this simulation are much like that shown in Figure 2.9 in the textbook. Only the excitatory and leak currents are
operating here, with their conductances (<code>g_bar.e, g_bar.l</code>) and reversal potentials (<code>e_rev.e, e_rev.l</code>) as shown in the control panel.

* Press the [[.programs.LeabraSettle.Init()|Init]] button and then the [[.programs.LeabraSettle.Run()|Run]] button on the control panel to display a new graph.

This produces a plot using the current parameters (figure 2.17 in textbook).  You should see various lines plotted over 200 time steps (''cycles'') on the X axis.  Note that the standard 0-1 normalized parameters are used by default.

Here is a quick overview of each of the variables -- we'll go through them individually next
(see [[.docs.GraphHelp]] for more details on how to determine what is being graphed, and how to configure it):
* '''net''' (red line) = net input, which is the total excitatory input to the neuron (net = g_e(t) * g_bar_e).  g_e(t) is the proportion of excitatory ion channels open, and it goes from 0 prior to cycle 10, to 1 from 10-160, and back to 0 thereafter.  Because g_bar_e = .4, the net value goes up to .4 from cycle 10-160.  The timing of when the input comes on and goes off is in the ControlPanel, on_cycle and off_cycle.
* '''I_net''' (orange line) = net current (sum of individual excitation and leak currents), which is excitatory (upward) when the excitatory input comes on, and then returns to zero with constant input.  When the excitatation goes off, the net current is negative as the constant leak current takes over and pushes the membrane potential down back to rest.
* '''v_m''' (yellow line) = membrane potential.  This starts out at the resting potential of .15 (-70mV in biological units), and then increases with the excitatory input. As you can see, the net current (I_net) shows the <i>rate of change</i> of the membrane potential.
* '''act''' (green line) = activation.  This shows the amount of activation sent to other units -- by default it is a rate code using the NOISY_XX1 function -- to see discrete spiking, switch the act_fun in the control panel to SPIKE instead of NOISY_XX1.
* '''act_eq''' (blue line) = rate-code equivalent activation -- this always shows a rate code equivalent for whatever activation function is being used (if a rate code like NOISY_XX1 is being used, then it is the same as act).

First, let's focus on the <code>net</code> line (it's the red one, displayed as a solid line in figure 2.17 in text).  This shows the ''net input'' to the unit, which starts out at 0, and then rapidly jumps to .4, remaining there until around 160 time steps, where it goes back to 0 again.  Recall that this net input is just another name for the total excitatory input to the neuron (i.e., net = g_e * g_bar_e).  In this simulation, the sending unit always sends a g_e value of 1 when it's on, and a 0 when off.  Later, we will manipulate the value of g_bar_e in the control panel to control the magnitude of the net input (it is .4 because the default value of g_bar.e is .4).  The timing of the input is controlled by the parameters <code>on_cycle</code> and <code>off_cycle</code> (the total number of cycles is controlled by <code>n_cycles</code>).

The second line, <code>I_net</code> (in orange/dashed), shows the ''net current'' in the unit, reflecting the overall balance between the excitatory net input and the constant leak current (plus inhibition in general, but this is not present in this simulation).  As expected, this shows an excitatory (upward) current when the input comes on, and an inhibitory (downward) one when the input goes off.  Because it reflects ''changes'' in the unit, it goes back to zero after the unit adapts to the steady excitatory input.

The third line, <code>v_m</code> (in yellow/dotted), shows the ''membrane potential'', which starts at the resting potential of .15, then increases with the excitation, and decreases back to rest when the input goes off.  This integrates the changes reflected in the I_net variable, and represents the overall integration of all the information coming into the unit.

The fourth line, <code>act</code> (in green/dash-dot), shows the ''activation'' value (using the NOISY_XX1 rate-coded activation function) that results from the membrane potential.  It goes from 0 up to roughly .72 and back down again.  Note that the activation rise trails the net input by several cycles -- this is due to the time it takes for the membrane potential to reach the firing threshold for the neuron.

'''Software Tip:''' You can click on any line in the graph log display using the red-arrow tool (click on the red arrow button in the upper-right corner of the 3d view window to see the exact values at the point where you clicked (as displayed in the graph caption at the bottom).  You can also click on the light green outer frame, and then do the context menu (right mouse button or Ctrl + left mouse on mac) and select DataTable/Edit Dialog to obtain a spreadsheet view of all the data being plotted in the graph.   You can then scroll through this data to find any value you might want to find.

* Click with the mouse on the v_m line on the graph to verify that the activation rise does indeed occur right around the threshold value for the membrane potential (.25).

The fifth line, <code>act_eq</code> (blue) is not turned on to begin with.  To turn it on, click the on! button next to it on the graph view control panel that shows up in the middle panel when you click on the [[.T3Tab.CycleOutputData]] tab (see the wiki [[.Wiki.Graph_View]] and local docs [[.docs.GraphHelp]] for more info).  You will initially see just  the label key turn on,  but won't actually see the blue line because it is superimposed perfectly on the act value (green line). (You can reveal it by toggling the on! button off for the act variable.) This value shows the rate-code equivalent activation value for discrete spiking units.  When an actual rate-code activation function (noisy XX1) is used, act_eq is just equivalent to act.  We will see the value of this variable later when we switch to spiking units.

== Manipulating Parameters ==

Now we will use some of the parameters in the control panel to explore the properties of the point neuron activation function.  

* Click on the [[.PanelTab.ControlPanel]] and take a moment to familiarize yourself with the parameters (you can hover the mouse over the label for each parameter to view a brief description of what it is).

'''Software Tip:'' All ''edit dialogs'' like the control panel have at least two buttons across the bottom: <code>Apply</code> (which applies any changes you have made to actually set the parameters) and <code>Revert</code> (which reverts to the previously applied values, which is useful if you have accidentally typed in a value that you didn't want).  See the wiki [[.Wiki.Edit_dialog]] for more information.

=== Excitatory ===

First, we will focus on <code>g_bar.e</code>, which controls the amount of excitatory conductance as described earlier.  In general, we are interested in seeing how the unit membrane potential reflects a balance of the different inputs coming into it (here just excitation and leak), and how the output activation responds to the resulting membrane potential.

* Increase g_bar.e from .4 to .5 (and press the Apply and Run buttons to see the effects).  Then observe the effects of decreasing g_bar.e to .3.

<hr>

'''Question 2.1 (a)''' ''Describe the effects on the neural response of increasing g_bar.e to .5, and of decreasing it to .3.'' '''(b)''' ''Is there a qualitative difference in the unit activation (act) between these two changes of magnitude .1 away from the initial .4 value?'' '''(c)''' ''What important aspect of the point neuron activation function does this reveal?''

<hr>

'''Software tip:''' It is often useful to overlay different Runs on top of each other in the graph log, which will happen naturally.  When you want to clear the log, press the Init button in the [[.PanelTab.ControlPanel]]. 

By systematically searching the parameter range for g_bar.e between .3 and .4, you should be able to locate the point at which the membrane potential just reaches threshold (recall that this is at V_m= .25 in the normalized units).  To make it easier to locate the threshold, we will switch from the noisy XX1 activation function (which has a ''soft'' threshold due to the effects of the convolved noise) to the XX1 activation function (which has a hard threshold due to the absence of noise).

* In the [[.PanelTab.ControlPanel]], switch the act_fun setting from NOISY_XX1 to XX1 (and press Apply).

<hr>

'''Question 2.2 (a)''' ''To 3 decimal places, what value of g_bar.e puts the unit just over threshold?  Can you think of a better way of finding this value (Hint: Do you remember an equation for the equilibrium membrane potential given a particular set of inputs?)''  '''(b)''' ''Compute the exact value of excitatory input required to just reach threshold, showing your math (note that: g_l is always 1 because the leak channels are always open; g_e is 1 when the input is on; inhibition is not present here and can be ignored).  Does this agree with your empirically determined value?  (Hint: It should!)''

<hr>

=== Leak ===

You can also play around with the value of the leak conductance, g_bar.l, which controls the size of the leak current.  

* Press the <code>Defaults</code> button on the control panel to restore the default parameters, and then see what happens when you increase or decrease the leak.

<hr>

'''Question 2.3 (a)''' ''How does the response of the unit change when you change g_bar.l?  Why?'' '''(b)''' ''How does this differ from changes to g_bar.e?'' '''(c)''' ''Use the same technique you used in the previous question to compute the exact amount of leak current necessary to put the membrane potential exactly at threshold when the g_bar.e value is at the default of .4 (show your math).''

<hr>

* Press Defaults to restore the default parameters.

Now that we have a sense of how the unit responds to different currents, and computes a resulting membrane potential that reflects the balance of these currents, we can explore the role of the reversal potentials (e_rev.e and e_rev.l).

<hr>

'''Question 2.4 (a)''' ''What happens to the unit's activity if you change the leak reversal potential e_rev.l from .15 to 0?'' '''(b)''' ''What about when you increase it to .2?  For both questions, explain the results, taking note of what happens before the input goes on as well as what happens while it is on.'' '''(c)''' ''What can you conclude about the relationship between the resting potential and the leak reversal potential?''

<hr>

* Press Defaults to restore the default parameters.

<hr>

'''Question 2.5 (a)''' ''What happens to the unit's activity if you change the excitatory reversal potential e_rev.e from 1 to .5?  Why does this happen?'' '''(b)''' ''Can you compensate for this by changing the value of g_bar.e?  To two decimal places, use the simulator to find the value of g_bar.e that gives essentially the same activation value as the default parameters.'' '''(c)''' ''Then use the same approach as in question 2.2 to solve for the exact value of g_bar.e that will compensate for this change in e_rev.e (use .256 for the membrane potential under the default parameters, and show your math).''

<hr>

== The Activation Output ==

In this section, we explore the way in which the unit computes its activation output.  The main objective is to understand the relationship between the spiking and rate-code activation functions.
We will use the same project as the previous section. 

* Press Defaults to start out with default parameters.

From the previous section, we know that changing the level of excitatory input will affect the membrane potential, and the resulting rate coded activation value.  Now let's explore this relationship in the spiking activation function.  

* Set act_fun to SPIKE, and press Apply and then Run.

Instead of the steady values during the input presentation period, you now see the oscillations caused by the spiking mechanism (as we saw previously in figure 2.12 in the textbook).  Thus, as soon as the membrane potential crosses the threshold, the activation spikes, and the membrane potential is reset (to a sub-resting potential of 0, reflecting the overshoot of the spiking mechanism).  Then, the potential climbs back up, and the process repeats itself.

The spacing between the spikes is inversely proportional to the firing rate, but it can be hard to eyeball this from the graph.  Let's look at act_eq, the rate-code equivalent spike-rate value as a function of the spike train (see equation 2.18 in the textbook).

* If it is not already toggled on, in the [[.PanelTab.CycleOutputData]] graph control panel, click the <code>on!</code> button for the Y5 act_eq value, which will now show up in blue in your graph.

* Next, observe the effects of changing g_bar.e from .4, first to .38 and then to .42.

<hr>

'''Question 2.6'''  ''Describe and explain the effects on the spike rate of decreasing g_bar.e  to .38, and of increasing it to .42.''

<hr>

The empirically-measured rate-code equivalent for the spiking activation function (act_eq) compares fairly closely with the rate-code value computed directly as a function of the membrane potential (act for NOISY_XX1), as we saw in figure 2.15 in the textbook.

* To explore this relationship in the simulation, you can switch between SPIKE and NOISY_XX1 for different values of g_bar.e.

You should observe a reasonably close fit between the final values of act_eq for SPIKE with that of NOISY_XX1.  However, with smaller g_bar.e values (e.g., .38), the NOISY_XX1 is somewhat below the spiking act_eq.  Achieving a much closer fit between spiking and rate coded activations such as that displayed in figure 2.15 requires different parameter values that are not otherwise appropriate for this
exploration.  This is due to the ''aliasing'' effects of discrete-time updating (i.e., coarse-grained digitization effects, like when trying to display a photograph on a low-resolution display), which the spiking model is very sensitive to.

* Change g_bar.e back to its default value of .4., and make sure act_fun is set to SPIKE.

An important aspect of spiking in real neurons is that the timing and intervals between spikes can be quite random, although the overall rate of firing remains predictable.  This is obviously not evident with the single constant input used so far, which results in regular firing.  However, if we introduce noise by adding small randomly generated values to the membrane potential, then we can see some of
this kind of effect, although it is still not as dramatic as it would be with multiple spiking inputs coming into the cell.  Note that this additional noise plays a similar role as the convolution of noise with the XX1 function in the noisy XX1 function, but in the case of the noisy XX1 we have a deterministic function that incorporates the averaged effects of noise, while here we are actually adding in the random values themselves, making the behavior stochastic.

* Change the variance of the noise generator (<code>noise_var</code>) in the control panel) from 0 to .005, and press Apply and then Run.

It can be difficult to tell from a single run whether the spike timing is random -- the unit still fires with some regularity.

* Do many Runs on top of each other in the graph view.

Now you should see that the spike timing was actually so random that there is essentially a uniform distribution of spike times across these different runs (i.e., a spike could occur at any time step), but the rate code equivalent activation (act_eq) nevertheless remained relatively constant (i.e., it had only a few different values at the end of a run).  This happens because the precise time at which a spike fires depends greatly on whether the noise happens to move the membrane potential up or down when it approaches the threshold, which can delay or advance the spike timing in a random fashion.  Thus, the threshold greatly magnifies small differences in membrane potential by making a large distinction between subthreshold and superthreshold potentials.  On average, however, the spikes are equally likely to be early or late, so these random timing differences end up canceling out in the rate code average.  This ''robustness'' of the rate code in the face of random noise (relative to the detailed spike timing) is one important argument for why it is reasonable to think that neurons rely primarily on rate code information (see section 2.8 in the textbook for more discussion).

Now, let's explore some of the properties of the noisy XX1 rate-code activation function, compared to other possible such functions.  We will compare XX1 (equation 2.20 in the text), which is the non-noisy version of noisy XX1, and LINEAR, which is just a threshold-linear function of the difference between the membrane potential and the threshold:
*  y_j = \\gamma [V_m - \\Theta]_+  

where [x]_+ is again the positive component of x or 0 if x is negative (i.e., if the membrane potential is below threshold).

* Press Defaults.  Then, change the excitatory input g_bar.e from .4 to .375, and press Apply and then Run.  Then, run XX1 with the same parameters (under act_fun, select XX1, press Apply and then
Run).  Next run LINEAR in the same way.

Notice that NOISY_XX1 starts earlier than XX1 or LINEAR, because it has a soft threshold.  This results from convolving the XX1 function with noise, such that even at sub-threshold values, there is a certain chance of getting above threshold, as reflected in a small positive activation value in the rate code.

* Change the excitatory input g_bar.e from .375 to .42, and press Apply and then Run.  Then, as in the
previous procedure, run the other two activation functions with the same parameters.

Notice that LINEAR goes up to ceiling (where it is clipped at a maximum of 1), while XX1 and NOISY_XX1 increase but stay below their maximum values.  Thus, the two XX1 based functions have a saturating nonlinearity that allows them to gradually approach a maximal value, instead of just being clipped off at this maximum. However, these XX1 functions approximate the threshold-linear function
for lower levels of excitation.

You should also notice that XX1 and NOISY_XX1 get closer to each other as g_e gets larger.  The noise convolution has much less of an effect when the function gets flatter, as it does in the saturating nonlinearity region.  Convolving noise with a linear function gives you back the linear function itself, so wherever the function is approximately linear, noise has much less of an effect.

When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.

</body>
</html>";
   html_text="<html><head></head><body>
<p>
</p><h1> Single Unit (Neuron) </h1>
<p>
This simulation illustrates the basic properties of neural unit activation, reflecting a balance of excitatory and inhibitory influences (including leak and synaptic inhibition).
</p><p>
</p><ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
<h2> Orientation to the Software (ControlPanel and Views) </h2>
<p>
As this is the first simulation project in the textbook, we begin with some introductory orientation.  All of the major controls and parameters for the simulation are contained within the <a href=\"ta:.edits.ControlPanel\">ControlPanel</a> object located in the middle of the 3 panels visible in the main project window (you can access it from the tab at the top of this middle panel).  The right panel contains various 3D graphical displays of simulation data, including the network (NetView or Network View) and various graphs and grid-like displays (Graph view, Grid view).
</p><p>
In this simulation, there are two different ways to view the results, selectable by the tabs at the top of the right side of the window:
</p><ul><li> The <a href=\"ta:.T3Tab.Network\">Network</a> tab shows the (very simple) network that is being simulated, with a single sending (input) unit (at the bottom) that sends activation to the receiving unit (at the top).  We are primarily concerned with how the receiving unit responds to the activation input from the sending unit.
</li><li> The <a href=\"ta:.T3Tab.CycleOutputData\">CycleOutputData</a> tab shows a graph of the receiving unit's main variables (see below for details) over time, in response to the sending activation.
</li></ul>
We will see this single input being turned on and then off again, and observe the response of the receiving unit.  To see this, we can run
the simulation.
<p>
At the bottom of the <a href=\"ta:.edits.ControlPanel\">ControlPanel</a> are 4 buttons: Init, Run, Step, Stop:
</p><ol><li> <a href=\"ta:.programs.LeabraSettle.Init()\">Init</a> -- initializes the graph display and starts the simulation over from wherever it might have left off.
</li><li> <a href=\"ta:.programs.LeabraSettle.Run()\">Run</a> -- runs the full set of cycles of activation updating (updating of the equations that govern the behavior of the neural unit), displaying the results in the Network and CycleOutputData frames on the right hand side of the window.
</li><li> <code>Step Cycle</code> -- runs one single cycle of activation updating (in more complex models, multiple levels of stepping will be available)
</li><li> <a href=\"ta:.programs.LeabraSettle.Stop()\">Stop</a> -- if running, this will stop running.
</li></ol>
<ul><li> Text like this that is indented with a bullet all by itself (not part of a list) indicates actions to take.  In this case, hit <a href=\"ta:.programs.LeabraSettle.Init()\">Init</a> and <a href=\"ta:.programs.LeabraSettle.Run()\">Run</a>, and look at the <a href=\"ta:.T3Tab.Network\">Network</a> display.
</li></ul>
You should see that very shortly after the input unit comes on (indicated by the yellow color), the receiving unit is activated by this input.  To get a better idea of the precise trajectory of this activation, it is much more convenient to use the  <b>Graph View</b> , which displays the information graphically over time, allows multiple variables to be viewed at the same time, and even allows multiple runs (e.g., with different parameters) to be compared with each other.
<p>
</p><h2> The Graph View </h2>
<p>
</p><ul><li> Press the <a href=\"ta:.T3Tab.CycleOutputData\">CycleOutputData</a> tab in the right panel to display the graph view display.
</li></ul>
The plots produced by this simulation are much like that shown in Figure 2.9 in the textbook. Only the excitatory and leak currents are
operating here, with their conductances (<code>g_bar.e, g_bar.l</code>) and reversal potentials (<code>e_rev.e, e_rev.l</code>) as shown in the control panel.
<p>
</p><ul><li> Press the <a href=\"ta:.programs.LeabraSettle.Init()\">Init</a> button and then the <a href=\"ta:.programs.LeabraSettle.Run()\">Run</a> button on the control panel to display a new graph.
</li></ul>
This produces a plot using the current parameters (figure 2.17 in textbook).  You should see various lines plotted over 200 time steps ( <i>cycles</i> ) on the X axis.  Note that the standard 0-1 normalized parameters are used by default.
<p>
Here is a quick overview of each of the variables -- we'll go through them individually next
(see <a href=\"ta:.docs.GraphHelp\">GraphHelp</a> for more details on how to determine what is being graphed, and how to configure it):
</p><ul><li>  <b>net</b>  (red line) = net input, which is the total excitatory input to the neuron (net = g_e(t) * g_bar_e).  g_e(t) is the proportion of excitatory ion channels open, and it goes from 0 prior to cycle 10, to 1 from 10-160, and back to 0 thereafter.  Because g_bar_e = .4, the net value goes up to .4 from cycle 10-160.  The timing of when the input comes on and goes off is in the ControlPanel, on_cycle and off_cycle.
</li><li>  <b>I_net</b>  (orange line) = net current (sum of individual excitation and leak currents), which is excitatory (upward) when the excitatory input comes on, and then returns to zero with constant input.  When the excitatation goes off, the net current is negative as the constant leak current takes over and pushes the membrane potential down back to rest.
</li><li>  <b>v_m</b>  (yellow line) = membrane potential.  This starts out at the resting potential of .15 (-70mV in biological units), and then increases with the excitatory input. As you can see, the net current (I_net) shows the <i>rate of change</i> of the membrane potential.
</li><li>  <b>act</b>  (green line) = activation.  This shows the amount of activation sent to other units -- by default it is a rate code using the NOISY_XX1 function -- to see discrete spiking, switch the act_fun in the control panel to SPIKE instead of NOISY_XX1.
</li><li>  <b>act_eq</b>  (blue line) = rate-code equivalent activation -- this always shows a rate code equivalent for whatever activation function is being used (if a rate code like NOISY_XX1 is being used, then it is the same as act).
</li></ul>
First, let's focus on the <code>net</code> line (it's the red one, displayed as a solid line in figure 2.17 in text).  This shows the  <i>net input</i>  to the unit, which starts out at 0, and then rapidly jumps to .4, remaining there until around 160 time steps, where it goes back to 0 again.  Recall that this net input is just another name for the total excitatory input to the neuron (i.e., net = g_e * g_bar_e).  In this simulation, the sending unit always sends a g_e value of 1 when it's on, and a 0 when off.  Later, we will manipulate the value of g_bar_e in the control panel to control the magnitude of the net input (it is .4 because the default value of g_bar.e is .4).  The timing of the input is controlled by the parameters <code>on_cycle</code> and <code>off_cycle</code> (the total number of cycles is controlled by <code>n_cycles</code>).
<p>
The second line, <code>I_net</code> (in orange/dashed), shows the  <i>net current</i>  in the unit, reflecting the overall balance between the excitatory net input and the constant leak current (plus inhibition in general, but this is not present in this simulation).  As expected, this shows an excitatory (upward) current when the input comes on, and an inhibitory (downward) one when the input goes off.  Because it reflects  <i>changes</i>  in the unit, it goes back to zero after the unit adapts to the steady excitatory input.
</p><p>
The third line, <code>v_m</code> (in yellow/dotted), shows the  <i>membrane potential</i> , which starts at the resting potential of .15, then increases with the excitation, and decreases back to rest when the input goes off.  This integrates the changes reflected in the I_net variable, and represents the overall integration of all the information coming into the unit.
</p><p>
The fourth line, <code>act</code> (in green/dash-dot), shows the  <i>activation</i>  value (using the NOISY_XX1 rate-coded activation function) that results from the membrane potential.  It goes from 0 up to roughly .72 and back down again.  Note that the activation rise trails the net input by several cycles -- this is due to the time it takes for the membrane potential to reach the firing threshold for the neuron.
</p><p>
 <b>Software Tip:</b>  You can click on any line in the graph log display using the red-arrow tool (click on the red arrow button in the upper-right corner of the 3d view window to see the exact values at the point where you clicked (as displayed in the graph caption at the bottom).  You can also click on the light green outer frame, and then do the context menu (right mouse button or Ctrl + left mouse on mac) and select DataTable/Edit Dialog to obtain a spreadsheet view of all the data being plotted in the graph.   You can then scroll through this data to find any value you might want to find.
</p><p>
</p><ul><li> Click with the mouse on the v_m line on the graph to verify that the activation rise does indeed occur right around the threshold value for the membrane potential (.25).
</li></ul>
The fifth line, <code>act_eq</code> (blue) is not turned on to begin with.  To turn it on, click the on! button next to it on the graph view control panel that shows up in the middle panel when you click on the <a href=\"ta:.T3Tab.CycleOutputData\">CycleOutputData</a> tab (see the wiki <a href=\"ta:.Wiki.Graph_View\">Graph_View</a> and local docs <a href=\"ta:.docs.GraphHelp\">GraphHelp</a> for more info).  You will initially see just  the label key turn on,  but won't actually see the blue line because it is superimposed perfectly on the act value (green line). (You can reveal it by toggling the on! button off for the act variable.) This value shows the rate-code equivalent activation value for discrete spiking units.  When an actual rate-code activation function (noisy XX1) is used, act_eq is just equivalent to act.  We will see the value of this variable later when we switch to spiking units.
<p>
</p><h2> Manipulating Parameters </h2>
<p>
Now we will use some of the parameters in the control panel to explore the properties of the point neuron activation function.  
</p><p>
</p><ul><li> Click on the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a> and take a moment to familiarize yourself with the parameters (you can hover the mouse over the label for each parameter to view a brief description of what it is).
</li></ul>
 <i>'Software Tip:</i>  All  <i>edit dialogs</i>  like the control panel have at least two buttons across the bottom: <code>Apply</code> (which applies any changes you have made to actually set the parameters) and <code>Revert</code> (which reverts to the previously applied values, which is useful if you have accidentally typed in a value that you didn't want).  See the wiki <a href=\"ta:.Wiki.Edit_dialog\">Edit_dialog</a> for more information.
<p>
</p><h3> Excitatory </h3>
<p>
First, we will focus on <code>g_bar.e</code>, which controls the amount of excitatory conductance as described earlier.  In general, we are interested in seeing how the unit membrane potential reflects a balance of the different inputs coming into it (here just excitation and leak), and how the output activation responds to the resulting membrane potential.
</p><p>
</p><ul><li> Increase g_bar.e from .4 to .5 (and press the Apply and Run buttons to see the effects).  Then observe the effects of decreasing g_bar.e to .3.
</li></ul>
<hr>
<p>
 <b>Question 2.1 (a)</b>   <i>Describe the effects on the neural response of increasing g_bar.e to .5, and of decreasing it to .3.</i>   <b>(b)</b>   <i>Is there a qualitative difference in the unit activation (act) between these two changes of magnitude .1 away from the initial .4 value?</i>   <b>(c)</b>   <i>What important aspect of the point neuron activation function does this reveal?</i> 
</p><p>
</p><hr>
<p>
 <b>Software tip:</b>  It is often useful to overlay different Runs on top of each other in the graph log, which will happen naturally.  When you want to clear the log, press the Init button in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>. 
</p><p>
By systematically searching the parameter range for g_bar.e between .3 and .4, you should be able to locate the point at which the membrane potential just reaches threshold (recall that this is at V_m= .25 in the normalized units).  To make it easier to locate the threshold, we will switch from the noisy XX1 activation function (which has a  <i>soft</i>  threshold due to the effects of the convolved noise) to the XX1 activation function (which has a hard threshold due to the absence of noise).
</p><p>
</p><ul><li> In the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>, switch the act_fun setting from NOISY_XX1 to XX1 (and press Apply).
</li></ul>
<hr>
<p>
 <b>Question 2.2 (a)</b>   <i>To 3 decimal places, what value of g_bar.e puts the unit just over threshold?  Can you think of a better way of finding this value (Hint: Do you remember an equation for the equilibrium membrane potential given a particular set of inputs?)</i>    <b>(b)</b>   <i>Compute the exact value of excitatory input required to just reach threshold, showing your math (note that: g_l is always 1 because the leak channels are always open; g_e is 1 when the input is on; inhibition is not present here and can be ignored).  Does this agree with your empirically determined value?  (Hint: It should!)</i> 
</p><p>
</p><hr>
<p>
</p><h3> Leak </h3>
<p>
You can also play around with the value of the leak conductance, g_bar.l, which controls the size of the leak current.  
</p><p>
</p><ul><li> Press the <code>Defaults</code> button on the control panel to restore the default parameters, and then see what happens when you increase or decrease the leak.
</li></ul>
<hr>
<p>
 <b>Question 2.3 (a)</b>   <i>How does the response of the unit change when you change g_bar.l?  Why?</i>   <b>(b)</b>   <i>How does this differ from changes to g_bar.e?</i>   <b>(c)</b>   <i>Use the same technique you used in the previous question to compute the exact amount of leak current necessary to put the membrane potential exactly at threshold when the g_bar.e value is at the default of .4 (show your math).</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Press Defaults to restore the default parameters.
</li></ul>
Now that we have a sense of how the unit responds to different currents, and computes a resulting membrane potential that reflects the balance of these currents, we can explore the role of the reversal potentials (e_rev.e and e_rev.l).
<p>
</p><hr>
<p>
 <b>Question 2.4 (a)</b>   <i>What happens to the unit's activity if you change the leak reversal potential e_rev.l from .15 to 0?</i>   <b>(b)</b>   <i>What about when you increase it to .2?  For both questions, explain the results, taking note of what happens before the input goes on as well as what happens while it is on.</i>   <b>(c)</b>   <i>What can you conclude about the relationship between the resting potential and the leak reversal potential?</i> 
</p><p>
</p><hr>
<p>
</p><ul><li> Press Defaults to restore the default parameters.
</li></ul>
<hr>
<p>
 <b>Question 2.5 (a)</b>   <i>What happens to the unit's activity if you change the excitatory reversal potential e_rev.e from 1 to .5?  Why does this happen?</i>   <b>(b)</b>   <i>Can you compensate for this by changing the value of g_bar.e?  To two decimal places, use the simulator to find the value of g_bar.e that gives essentially the same activation value as the default parameters.</i>   <b>(c)</b>   <i>Then use the same approach as in question 2.2 to solve for the exact value of g_bar.e that will compensate for this change in e_rev.e (use .256 for the membrane potential under the default parameters, and show your math).</i> 
</p><p>
</p><hr>
<p>
</p><h2> The Activation Output </h2>
<p>
In this section, we explore the way in which the unit computes its activation output.  The main objective is to understand the relationship between the spiking and rate-code activation functions.
We will use the same project as the previous section. 
</p><p>
</p><ul><li> Press Defaults to start out with default parameters.
</li></ul>
From the previous section, we know that changing the level of excitatory input will affect the membrane potential, and the resulting rate coded activation value.  Now let's explore this relationship in the spiking activation function.  
<p>
</p><ul><li> Set act_fun to SPIKE, and press Apply and then Run.
</li></ul>
Instead of the steady values during the input presentation period, you now see the oscillations caused by the spiking mechanism (as we saw previously in figure 2.12 in the textbook).  Thus, as soon as the membrane potential crosses the threshold, the activation spikes, and the membrane potential is reset (to a sub-resting potential of 0, reflecting the overshoot of the spiking mechanism).  Then, the potential climbs back up, and the process repeats itself.
<p>
The spacing between the spikes is inversely proportional to the firing rate, but it can be hard to eyeball this from the graph.  Let's look at act_eq, the rate-code equivalent spike-rate value as a function of the spike train (see equation 2.18 in the textbook).
</p><p>
</p><ul><li> If it is not already toggled on, in the <a href=\"ta:.PanelTab.CycleOutputData\">CycleOutputData</a> graph control panel, click the <code>on!</code> button for the Y5 act_eq value, which will now show up in blue in your graph.
</li></ul>
<ul><li> Next, observe the effects of changing g_bar.e from .4, first to .38 and then to .42.
</li></ul>
<hr>
<p>
 <b>Question 2.6</b>    <i>Describe and explain the effects on the spike rate of decreasing g_bar.e  to .38, and of increasing it to .42.</i> 
</p><p>
</p><hr>
<p>
The empirically-measured rate-code equivalent for the spiking activation function (act_eq) compares fairly closely with the rate-code value computed directly as a function of the membrane potential (act for NOISY_XX1), as we saw in figure 2.15 in the textbook.
</p><p>
</p><ul><li> To explore this relationship in the simulation, you can switch between SPIKE and NOISY_XX1 for different values of g_bar.e.
</li></ul>
You should observe a reasonably close fit between the final values of act_eq for SPIKE with that of NOISY_XX1.  However, with smaller g_bar.e values (e.g., .38), the NOISY_XX1 is somewhat below the spiking act_eq.  Achieving a much closer fit between spiking and rate coded activations such as that displayed in figure 2.15 requires different parameter values that are not otherwise appropriate for this
exploration.  This is due to the  <i>aliasing</i>  effects of discrete-time updating (i.e., coarse-grained digitization effects, like when trying to display a photograph on a low-resolution display), which the spiking model is very sensitive to.
<p>
</p><ul><li> Change g_bar.e back to its default value of .4., and make sure act_fun is set to SPIKE.
</li></ul>
An important aspect of spiking in real neurons is that the timing and intervals between spikes can be quite random, although the overall rate of firing remains predictable.  This is obviously not evident with the single constant input used so far, which results in regular firing.  However, if we introduce noise by adding small randomly generated values to the membrane potential, then we can see some of
this kind of effect, although it is still not as dramatic as it would be with multiple spiking inputs coming into the cell.  Note that this additional noise plays a similar role as the convolution of noise with the XX1 function in the noisy XX1 function, but in the case of the noisy XX1 we have a deterministic function that incorporates the averaged effects of noise, while here we are actually adding in the random values themselves, making the behavior stochastic.
<p>
</p><ul><li> Change the variance of the noise generator (<code>noise_var</code>) in the control panel) from 0 to .005, and press Apply and then Run.
</li></ul>
It can be difficult to tell from a single run whether the spike timing is random -- the unit still fires with some regularity.
<p>
</p><ul><li> Do many Runs on top of each other in the graph view.
</li></ul>
Now you should see that the spike timing was actually so random that there is essentially a uniform distribution of spike times across these different runs (i.e., a spike could occur at any time step), but the rate code equivalent activation (act_eq) nevertheless remained relatively constant (i.e., it had only a few different values at the end of a run).  This happens because the precise time at which a spike fires depends greatly on whether the noise happens to move the membrane potential up or down when it approaches the threshold, which can delay or advance the spike timing in a random fashion.  Thus, the threshold greatly magnifies small differences in membrane potential by making a large distinction between subthreshold and superthreshold potentials.  On average, however, the spikes are equally likely to be early or late, so these random timing differences end up canceling out in the rate code average.  This  <i>robustness</i>  of the rate code in the face of random noise (relative to the detailed spike timing) is one important argument for why it is reasonable to think that neurons rely primarily on rate code information (see section 2.8 in the textbook for more discussion).
<p>
Now, let's explore some of the properties of the noisy XX1 rate-code activation function, compared to other possible such functions.  We will compare XX1 (equation 2.20 in the text), which is the non-noisy version of noisy XX1, and LINEAR, which is just a threshold-linear function of the difference between the membrane potential and the threshold:
</p><ul><li>  y_j = \\gamma [V_m - \\Theta]_+  
</li></ul>
where [x]_+ is again the positive component of x or 0 if x is negative (i.e., if the membrane potential is below threshold).
<p>
</p><ul><li> Press Defaults.  Then, change the excitatory input g_bar.e from .4 to .375, and press Apply and then Run.  Then, run XX1 with the same parameters (under act_fun, select XX1, press Apply and then
Run).  Next run LINEAR in the same way.</li></ul>
<p>
Notice that NOISY_XX1 starts earlier than XX1 or LINEAR, because it has a soft threshold.  This results from convolving the XX1 function with noise, such that even at sub-threshold values, there is a certain chance of getting above threshold, as reflected in a small positive activation value in the rate code.
</p><p>
</p><ul><li> Change the excitatory input g_bar.e from .375 to .42, and press Apply and then Run.  Then, as in the
previous procedure, run the other two activation functions with the same parameters.</li></ul>
<p>
Notice that LINEAR goes up to ceiling (where it is clipped at a maximum of 1), while XX1 and NOISY_XX1 increase but stay below their maximum values.  Thus, the two XX1 based functions have a saturating nonlinearity that allows them to gradually approach a maximal value, instead of just being clipped off at this maximum. However, these XX1 functions approximate the threshold-linear function
for lower levels of excitation.
</p><p>
You should also notice that XX1 and NOISY_XX1 get closer to each other as g_e gets larger.  The noise convolution has much less of an effect when the function gets flatter, as it does in the saturating nonlinearity region.  Convolving noise with a linear function gives you back the linear function itself, so wherever the function is approximately linear, noise has much less of an effect.
</p><p>
When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.
</p><p>

</p></body></html>";
  };
  taDoc @[1] {
   name="GraphHelp";
   desc=;
   auto_open=0;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>

= Graph Help =

The parameters that control what is graphed (and how) are in the [[.T3Tab.CycleOutputData]] tab in the middle panel of the window.  This tab is only visible when you have clicked to view the graph in the right panel, by clicking on the CycleOutputData tab.

The different variables to view (each of which gets its own colored line in the graph) are listed by row, with labels Y1, Y2, etc.  By default:
* Y1 = the net input (net excitatory synaptic input, or g_e)
* Y2 = I_net (net current, reflecting the balance of the excitatory and inhibitory inputs, and driving changes in the membrane potential V_m).  Mathematically, and according to Ohm's Law, this is equivalent to the time derivative of the membrane potential.
* Y3 = V_m (membrane potential) -- this is the current internal state of the neuron reflecting prior and current inputs -- it is fully graded, without a threshold, and forms the internal basis for the thresholded activation output.
* Y4 = act (raw activation output) -- when V_m goes over threshold, the neuron sends activation.  If the activation function is a rate code (e.g., NOISY_XX1), then this continuously-varying activation value reflects the average rate of spiking that would otherwise occur for the given membrane potential.  If the activation function is SPIKE, it is 1 when the neuron has spiked, and quickly decays back to 0.
* Y5= act_eq (rate-code equivalent activation) -- when using SPIKE activations, this value represents the equivalent rate code for the rate of spiking that is occurring.  Otherwise, it is the same as act.

Sometimes, it can be useful to not plot some of the variables.  The little \"on\" button next to the variable name will toggle on or off the display of that variable.

</body>
</html>";
   html_text="<html>
<head></head>
<body>
<P>
<h1> Graph Help </h1>
<P>
The parameters that control what is graphed (and how) are in the <a href=\"ta:.T3Tab.CycleOutputData\">CycleOutputData</a> tab in the middle panel of the window.  This tab is only visible when you have clicked to view the graph in the right panel, by clicking on the CycleOutputData tab.
<P>
The different variables to view (each of which gets its own colored line in the graph) are listed by row, with labels Y1, Y2, etc.  By default:
<ul><li> Y1 = the net input (net excitatory synaptic input, or g_e)
<li> Y2 = I_net (net current, reflecting the balance of the excitatory and inhibitory inputs, and driving changes in the membrane potential V_m).  Mathematically, and according to Ohm's Law, this is equivalent to the time derivative of the membrane potential.
<li> Y3 = V_m (membrane potential) -- this is the current internal state of the neuron reflecting prior and current inputs -- it is fully graded, without a threshold, and forms the internal basis for the thresholded activation output.
<li> Y4 = act (raw activation output) -- when V_m goes over threshold, the neuron sends activation.  If the activation function is a rate code (e.g., NOISY_XX1), then this continuously-varying activation value reflects the average rate of spiking that would otherwise occur for the given membrane potential.  If the activation function is SPIKE, it is 1 when the neuron has spiked, and quickly decays back to 0.
<li> Y5= act_eq (rate-code equivalent activation) -- when using SPIKE activations, this value represents the equivalent rate code for the rate of spiking that is occurring.  Otherwise, it is the same as act.
</ul>
Sometimes, it can be useful to not plot some of the variables.  The little \"on\" button next to the variable name will toggle on or off the display of that variable.
<P>
</body>
";
  };
  taDoc @[2] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Units";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Units";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Units,CECN1 Projects,Emergent,.edits.ControlPanel,.T3Tab.Network,.T3Tab.CycleOutputData,.programs.LeabraSettle.Init(),.programs.LeabraSettle.Run(),.programs.LeabraSettle.Step(),.programs.LeabraSettle.Stop(),.docs.GraphHelp\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Units - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Units\";
		var wgTitle = \"CECN1 Units\";
		var wgAction = \"view\";
		var wgArticleId = \"9\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 520;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Units skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Units</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Exploration_of_the_Individual_Neuron_.28Unit.29\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Exploration of the Individual Neuron (Unit)</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Orientation_to_the_Software_.28ControlPanel_and_Views.29\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Orientation to the Software (ControlPanel and Views)</span></a></li>
<li class=\"toclevel-2\"><a href=\"#The_Graph_View\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">The Graph View</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Manipulating_Parameters\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Manipulating Parameters</span></a>
<ul>
<li class=\"toclevel-3\"><a href=\"#Excitatory\"><span class=\"tocnumber\">2.3.1</span> <span class=\"toctext\">Excitatory</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Leak\"><span class=\"tocnumber\">2.3.2</span> <span class=\"toctext\">Leak</span></a></li>
</ul>
</li>
<li class=\"toclevel-2\"><a href=\"#The_Activation_Output\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">The Activation Output</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Exploration_of_the_Individual_Neuron_.28Unit.29\" id=\"Exploration_of_the_Individual_Neuron_.28Unit.29\"></a><h1> <span class=\"mw-headline\"> Exploration of the Individual Neuron (Unit) </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/c/c1/unit.proj\" class=\"internal\" title=\"unit.proj\">unit.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p>This simulation illustrates the basic properties of neural unit activation, reflecting a balance of excitatory and inhibitory influences (including leak and synaptic inhibition).
</p>
<ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
<a name=\"Orientation_to_the_Software_.28ControlPanel_and_Views.29\" id=\"Orientation_to_the_Software_.28ControlPanel_and_Views.29\"></a><h2> <span class=\"mw-headline\"> Orientation to the Software (ControlPanel and Views) </span></h2>
<p>As this is the first simulation project in the textbook, we begin with some introductory orientation.  All of the major controls and parameters for the simulation are contained within the <a href=\"/CompCogNeuro/index.php?title=.edits.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".edits.ControlPanel (page does not exist)\">.edits.ControlPanel</a> object located in the middle of the 3 panels visible in the main project window (clicking the link will take you there, and you can also access it from the tab at the top of this middle panel).  The right panel contains various 3D graphical displays of simulation data, including the network (NetView or Network View) and various graphs and grid-like displays (Graph view, Grid view).
</p><p>In this simulation, there are two different ways to view the results, selectable by the tabs at the top of the right side of the window:
</p>
<ul><li> The <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Network&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Network (page does not exist)\">.T3Tab.Network</a> tab shows the (very simple) network that is being simulated, with a single sending (input) unit (at the bottom) that sends activation to the receiving unit (at the top).  We are primarily concerned with how the receiving unit responds to the activation input from the sending unit.
</li><li> The <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CycleOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CycleOutputData (page does not exist)\">.T3Tab.CycleOutputData</a> tab shows a graph of the receiving unit's main variables (see below for details) over time, in response to the sending activation.
</li></ul>
<p>We will see this single input being turned on and then off again, and observe the response of the receiving unit.  To see this, we can run
the simulation.
</p><p>At the bottom of the <a href=\"/CompCogNeuro/index.php?title=.edits.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".edits.ControlPanel (page does not exist)\">.edits.ControlPanel</a> are 4 buttons: Init, Run, Step, Stop:
</p>
<ol><li> <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Init() (page does not exist)\">Init</a> -- initializes the graph display and starts the simulation over from wherever it might have left off.
</li><li> <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Run() (page does not exist)\">Run</a> -- runs the full set of cycles of activation updating (updating of the equations that govern the behavior of the neural unit), displaying the results in the Network and CycleOutputData frames on the right hand side of the window.
</li><li> <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Step()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Step() (page does not exist)\">Step</a> -- runs one single cycle of activation updating.
</li><li> <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Stop()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Stop() (page does not exist)\">Stop</a> -- if running, this will stop running.
</li></ol>
<ul><li> Text like this that is indented with a bullet all by itself (not part of a list) indicates actions to take.  In this case, hit <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Init()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Init() (page does not exist)\">Init</a> and <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Run() (page does not exist)\">Run</a>, and look at the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Network&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Network (page does not exist)\">.T3Tab.Network</a> display.
</li></ul>
<p>You should see that very shortly after the input unit comes on (indicated by the yellow color), the receiving unit is activated by this input.  To get a better idea of the precise trajectory of this activation, it is much more convenient to use the <b>Graph View</b>, which displays the information graphically over time, allows multiple variables to be viewed at the same time, and even allows multiple runs (e.g., with different parameters) to be compared with each other.
</p>
<a name=\"The_Graph_View\" id=\"The_Graph_View\"></a><h2> <span class=\"mw-headline\"> The Graph View </span></h2>
<ul><li> Press the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CycleOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CycleOutputData (page does not exist)\">.T3Tab.CycleOutputData</a> tab in the right panel to display the graph view display.
</li></ul>
<p>The plots produced by this simulation are much like that shown in Figure 2.9 in the textbook. Only the excitatory and leak currents are
operating here, with their conductances (<code>g_bar.e, g_bar.l</code>) and reversal potentials (<code>e_rev.e, e_rev.l</code>) as shown in the control panel.
</p>
<ul><li> Press the <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraSettle.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraSettle.Run() (page does not exist)\">Run</a> button on the control panel to display a new graph.
</li></ul>
<p>This produces a plot using the current parameters (figure 2.17 in textbook).  You should see various lines plotted over 200 time steps (<i>cycles</i>) on the X axis.  Note that the standard 0-1 normalized parameters are used by default.
</p><p>Here is a quick overview of each of the variables -- we'll go through them individually next
(see <a href=\"/CompCogNeuro/index.php?title=.docs.GraphHelp&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".docs.GraphHelp (page does not exist)\">.docs.GraphHelp</a> for more details on how to determine what is being graphed, and how to configure it):
</p>
<ul><li> <b>net</b> (red line) = net input, which is the total excitatory input to the neuron (net = g_e(t) * g_bar_e).  g_e(t) is the proportion of excitatory ion channels open, and it goes from 0 prior to cycle 10, to 1 from 10-160, and back to 0 thereafter.  Because g_bar_e = .4, the net value goes up to .4 from cycle 10-160.  The timing of when the input comes on and goes off is in the ControlPanel, on_cycle and off_cycle.
</li><li> <b>I_net</b> (orange line) = net current (sum of individual excitation and leak currents), which is excitatory (upward) when the excitatory input comes on, and then returns to zero with constant input.  When the excitatation goes off, the net current is negative as the constant leak current takes over and pushes the membrane potential down back to rest.
</li><li> <b>v_m</b> (yellow line) = membrane potential.  This starts out at the resting potential of .15 (-70mV in biological units), and then increases with the excitatory input. As you can see, the net current (I_net) shows the <i>rate of change</i> of the membrane potential.
</li><li> <b>act</b> (green line) = activation.  This shows the amount of activation sent to other units -- by default it is a rate code using the NOISY_XX1 function -- to see discrete spiking, switch the act_fun in the control panel to SPIKE instead of NOISY_XX1.
</li><li> <b>act_eq</b> (blue line) = rate-code equivalent activation -- this always shows a rate code equivalent for whatever activation function is being used (if a rate code like NOISY_XX1 is being used, then it is the same as act).
</li></ul>
<p>First, let's focus on the <code>net</code> line (it's the red one, displayed as a solid line in figure 2.17 in text).  This shows the <i>net input</i> to the unit, which starts out at 0, and then rapidly jumps to .4, remaining there until around 160 time steps, where it goes back to 0 again.  Recall that this net input is just another name for the total excitatory input to the neuron (i.e., net = g_e * g_bar_e).  In this simulation, the sending unit always sends a g_e value of 1 when it's on, and a 0 when off.  Later, we will manipulate the value of g_bar_e in the control panel to control the magnitude of the net input (it is .4 because the default value of g_bar.e is .4).  The timing of the input is controlled by the parameters <code>on_cycle</code> and <code>off_cycle</code> (the total number of cycles is controlled by <code>n_cycles</code>).
</p><p>The second line, <code>I_net</code> (in orange/dashed), shows the <i>net current</i> in the unit, reflecting the overall balance between the excitatory net input and the constant leak current (plus inhibition in general, but this is not present in this simulation).  As expected, this shows an excitatory (upward) current when the input comes on, and an inhibitory (downward) one when the input goes off.  Because it reflects <i>changes</i> in the unit, it goes back to zero after the unit adapts to the steady excitatory input.
</p><p>The third line, <code>v_m</code> (in yellow/dotted), shows the <i>membrane potential</i>, which starts at the resting potential of .15, then increases with the excitation, and decreases back to rest when the input goes off.  This integrates the changes reflected in the I_net variable, and represents the overall integration of all the information coming into the unit.
</p><p>The fourth line, <code>act</code> (in green/dash-dot), shows the <i>activation</i> value (using the NOISY_XX1 rate-coded activation function) that results from the membrane potential.  It goes from 0 up to roughly .72 and back down again.  Note that the activation rise trails the net input by several cycles -- this is due to the time it takes for the membrane potential to reach the firing threshold for the neuron.
</p><p><b>Software Tip:</b> You can click on any line in the graph log display using the red-arrow tool (click on the red arrow button in the upper-right corner of the 3d view window to see the exact values at the point where you clicked (as displayed in the graph caption at the bottom).  You can also click on the light green outer frame, and then do the context menu (right mouse button or Ctrl + left mouse on mac) and select DataTable/Edit Dialog to obtain a spreadsheet view of all the data being plotted in the graph.   You can then scroll through this data to find any value you might want to find.
</p>
<ul><li> Click with the mouse on the v_m line on the graph to verify that the activation rise does indeed occur right around the threshold value for the membrane potential (.25).
</li></ul>
<p>The fifth line, <code>act_eq</code> (blue) is not turned on to begin with.  To turn it on, click the on! button next to it on the graph view control panel that shows up in the middle panel when you click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.CycleOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.CycleOutputData (page does not exist)\">.T3Tab.CycleOutputData</a> tab (see the wiki <a href=\"/CompCogNeuro/index.php?title=.Wiki.Graph_View&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".Wiki.Graph View (page does not exist)\">.Wiki.Graph_View</a> and local docs <a href=\"/CompCogNeuro/index.php?title=.docs.GraphHelp&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".docs.GraphHelp (page does not exist)\">.docs.GraphHelp</a> for more info).  This value shows the rate-code equivalent activation value for discrete spiking units.  When an actual rate-code
activation function (noisy XX1) is used, act_eq is just equivalent to act.  We will see the value of this variable later when we switch to spiking units.
</p>
<a name=\"Manipulating_Parameters\" id=\"Manipulating_Parameters\"></a><h2> <span class=\"mw-headline\"> Manipulating Parameters </span></h2>
<p>Now we will use some of the parameters in the control panel to explore the properties of the point neuron activation function.  
</p>
<ul><li> Click on the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a> and take a moment to familiarize yourself with the parameters (you can hover the mouse over the label for each parameter to view a brief description of what it is).
</li></ul>
<p>'<i>Software Tip:</i> All <i>edit dialogs</i> like the control panel have at least two buttons across the bottom: <code>Apply</code> (which applies any changes you have made to actually set the parameters) and <code>Revert</code> (which reverts to the previously applied values, which is useful if you have accidentally typed in a value that you didn't want).  See the wiki <a href=\"/CompCogNeuro/index.php?title=.Wiki.Edit_dialog&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".Wiki.Edit dialog (page does not exist)\">.Wiki.Edit_dialog</a> for more information.
</p>
<a name=\"Excitatory\" id=\"Excitatory\"></a><h3> <span class=\"mw-headline\"> Excitatory </span></h3>
<p>First, we will focus on <code>g_bar.e</code>, which controls the amount of excitatory conductance as described earlier.  In general, we are interested in seeing how the unit membrane potential reflects a balance of the different inputs coming into it (here just excitation and leak), and how the output activation responds to the resulting membrane potential.
</p>
<ul><li> Increase g_bar.e from .4 to .5 (and press the Apply and Run buttons to see the effects).  Then observe the effects of decreasing g_bar.e to .3.
</li></ul>
<hr>
<p><b>Question 2.1 (a)</b> <i>Describe the effects on the neural response of increasing g_bar.e to .5, and of decreasing it to .3.</i> <b>(b)</b> <i>Is there a qualitative difference in the unit activation (act) between these two changes of magnitude .1 away from the initial .4 value?</i> <b>(c)</b> <i>What important aspect of the point neuron activation function does this reveal?</i>
</p>
<hr>
<p><b>Software tip:</b> It is often useful to overlay different Runs on top of each other in the graph log, which will happen naturally.  When you want to clear the log, press the Init button in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>. 
</p><p>By systematically searching the parameter range for g_bar.e between .3 and .4, you should be able to locate the point at which the membrane potential just reaches threshold (recall that this is at V_m= .25 in the normalized units).  To make it easier to locate the threshold, we will switch from the noisy XX1 activation function (which has a <i>soft</i> threshold due to the effects of the convolved noise) to the XX1 activation function (which has a hard threshold due to the absence of noise).
</p>
<ul><li> In the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>, switch the act_fun setting from NOISY_XX1 to XX1 (and press Apply).
</li></ul>
<hr>
<p><b>Question 2.2 (a)</b> <i>To 3 decimal places, what value of g_bar.e puts the unit just over threshold?  Can you think of a better way of finding this value (Hint: Do you remember an equation for the equilibrium membrane potential given a particular set of inputs?)</i>  <b>(b)</b> <i>Compute the exact value of excitatory input required to just reach threshold, showing your math (note that: g_l is always 1 because the leak channels are always open; g_e is 1 when the input is on; inhibition is not present here and can be ignored).  Does this agree with your empirically determined value?  (Hint: It should!)</i>
</p>
<hr>
<a name=\"Leak\" id=\"Leak\"></a><h3> <span class=\"mw-headline\"> Leak </span></h3>
<p>You can also play around with the value of the leak conductance, g_bar.l, which controls the size of the leak current.  
</p>
<ul><li> Press the <code>Defaults</code> button on the control panel to restore the default parameters, and then see what happens when you increase or decrease the leak.
</li></ul>
<hr>
<p><b>Question 2.3 (a)</b> <i>How does the response of the unit change when you change g_bar.l?  Why?</i> <b>(b)</b> <i>How does this differ from changes to g_bar.e?</i> <b>(c)</b> <i>Use the same technique you used in the previous question to compute the exact amount of leak current necessary to put the membrane potential exactly at threshold when the g_bar.e value is at the default of .4 (show your math).</i>
</p>
<hr>
<ul><li> Press Defaults to restore the default parameters.
</li></ul>
<p>Now that we have a sense of how the unit responds to different currents, and computes a resulting membrane potential that reflects the balance of these currents, we can explore the role of the reversal potentials (e_rev.e and e_rev.l).
</p>
<hr>
<p><b>Question 2.4 (a)</b> <i>What happens to the unit's activity if you change the leak reversal potential e_rev.l from .15 to 0?</i> <b>(b)</b> <i>What about when you increase it to .2?  For both questions, explain the results, taking note of what happens before the input goes on as well as what happens while it is on.</i> <b>(c)</b> <i>What can you conclude about the relationship between the resting potential and the leak reversal potential?</i>
</p>
<hr>
<ul><li> Press Defaults to restore the default parameters.
</li></ul>
<hr>
<p><b>Question 2.5 (a)</b> <i>What happens to the unit's activity if you change the excitatory reversal potential e_rev.e from 1 to .5?  Why does this happen?</i> <b>(b)</b> <i>Can you compensate for this by changing the value of g_bar.e?  To two decimal places, use the simulator to find the value of g_bar.e that gives essentially the same activation value as the default parameters.</i> <b>(c)</b> <i>Then use the same approach as in question 2.2 to solve for the exact value of g_bar.e that will compensate for this change in e_rev.e (use .256 for the membrane potential under the default parameters, and show your math).</i>
</p>
<hr>
<a name=\"The_Activation_Output\" id=\"The_Activation_Output\"></a><h2> <span class=\"mw-headline\"> The Activation Output </span></h2>
<p>In this section, we explore the way in which the unit computes its activation output.  The main objective is to understand the relationship between the spiking and rate-code activation functions.
We will use the same project as the previous section. 
</p>
<ul><li> Press Defaults to start out with default parameters.
</li></ul>
<p>From the previous section, we know that changing the level of excitatory input will affect the membrane potential, and the resulting rate coded activation value.  Now let's explore this relationship in the spiking activation function.  
</p>
<ul><li> Set act_fun to SPIKE, and press Apply and then Run.
</li></ul>
<p>Instead of the steady values during the input presentation period, you now see the oscillations caused by the spiking mechanism (as we saw previously in figure 2.12 in the textbook).  Thus, as soon as the membrane potential crosses the threshold, the activation spikes, and the membrane potential is reset (to a sub-resting potential of 0, reflecting the overshoot of the spiking mechanism).  Then, the potential climbs back up, and the process repeats itself.
</p><p>The spacing between the spikes is inversely proportional to the firing rate, but it can be hard to eyeball this from the graph.  Let's look at act_eq, the rate-code equivalent spike-rate value as a function of the spike train (see equation 2.18 in the textbook).
</p>
<ul><li> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.CycleOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.CycleOutputData (page does not exist)\">.PanelTab.CycleOutputData</a> graph control panel, click the <code>on!</code> button for the Y5 act_eq value, which will now show up in blue in your graph.
</li></ul>
<ul><li> Next, observe the effects of changing g_bar.e from .4, first to .38 and then to .42.
</li></ul>
<hr>
<p><b>Question 2.6</b>  <i>Describe and explain the effects on the spike rate of decreasing g_bar.e  to .38, and of increasing it to .42.</i>
</p>
<hr>
<p>The empirically-measured rate-code equivalent for the spiking activation function (act_eq) compares fairly closely with the rate-code value computed directly as a function of the membrane potential (act for NOISY_XX1), as we saw in figure 2.15 in the textbook.
</p>
<ul><li> To explore this relationship in the simulation, you can switch between SPIKE and NOISY_XX1 for different values of g_bar.e.
</li></ul>
<p>You should observe a reasonably close fit between the final values of act_eq for SPIKE with that of NOISY_XX1.  However, with smaller g_bar.e values (e.g., .38), the NOISY_XX1 is somewhat below the spiking act_eq.  Achieving a much closer fit between spiking and rate coded activations such as that displayed in figure 2.15 requires different parameter values that are not otherwise appropriate for this
exploration.  This is due to the <i>aliasing</i> effects of discrete-time updating (i.e., coarse-grained digitization effects, like when trying to display a photograph on a low-resolution display), which the spiking model is very sensitive to.
</p>
<ul><li> Change g_bar.e back to its default value of .4., and make sure act_fun is set to SPIKE.
</li></ul>
<p>An important aspect of spiking in real neurons is that the timing and intervals between spikes can be quite random, although the overall rate of firing remains predictable.  This is obviously not evident with the single constant input used so far, which results in regular firing.  However, if we introduce noise by adding small randomly generated values to the membrane potential, then we can see some of
this kind of effect, although it is still not as dramatic as it would be with multiple spiking inputs coming into the cell.  Note that this additional noise plays a similar role as the convolution of noise with the XX1 function in the noisy XX1 function, but in the case of the noisy XX1 we have a deterministic function that incorporates the averaged effects of noise, while here we are actually adding in the random values themselves, making the behavior stochastic.
</p>
<ul><li> Change the variance of the noise generator (<code>noise_var</code>) in the control panel) from 0 to .005, and press Apply and then Run.
</li></ul>
<p>It can be difficult to tell from a single run whether the spike timing is random -- the unit still fires with some regularity.
</p>
<ul><li> Do many Runs on top of each other in the graph view.
</li></ul>
<p>Now you should see that the spike timing was actually so random that there is essentially a uniform distribution of spike times across these different runs (i.e., a spike could occur at any time step), but the rate code equivalent activation (act_eq) nevertheless remained relatively constant (i.e., it had only a few different values at the end of a run).  This happens because the precise time at which a spike fires depends greatly on whether the noise happens to move the membrane potential up or down when it approaches the threshold, which can delay or advance the spike timing in a random fashion.  Thus, the threshold greatly magnifies small differences in membrane potential by making a large distinction between subthreshold and superthreshold potentials.  On average, however, the spikes are equally likely to be early or late, so these random timing differences end up canceling out in the rate code average.  This <i>robustness</i> of the rate code in the face of random noise (relative to the detailed spike timing) is one important argument for why it is reasonable to think that neurons rely primarily on rate code information (see section 2.8 in the textbook for more discussion).
</p><p>Now, let's explore some of the properties of the noisy XX1 rate-code activation function, compared to other possible such functions.  We will compare XX1 (equation 2.20 in the text), which is the non-noisy version of noisy XX1, and LINEAR, which is just a threshold-linear function of the difference between the membrane potential and the threshold:
</p>
<ul><li>  y_j = \\gamma [V_m - \\Theta]_+  
</li></ul>
<p>where [x]_+ is again the positive component of x or 0 if x is negative (i.e., if the membrane potential is below threshold).
</p>
<ul><li> Press Defaults.  Then, change the excitatory input g_bar.e from .4 to .375, and press Apply and then Run.  Then, run XX1 with the same parameters (under act_fun, select XX1, press Apply and then
</li></ul>
<p>Run).  Next run LINEAR in the same way.
</p><p>Notice that NOISY_XX1 starts earlier than XX1 or LINEAR, because it has a soft threshold.  This results from convolving the XX1 function with noise, such that even at sub-threshold values, there is a certain chance of getting above threshold, as reflected in a small positive activation value in the rate code.
</p>
<ul><li> Change the excitatory input g_bar.e from .375 to .42, and press Apply and then Run.  Then, as in the
</li></ul>
<p>previous procedure, run the other two activation functions with the same parameters.
</p><p>Notice that LINEAR goes up to ceiling (where it is clipped at a maximum of 1), while XX1 and NOISY_XX1 increase but stay below their maximum values.  Thus, the two XX1 based functions have a saturating nonlinearity that allows them to gradually approach a maximal value, instead of just being clipped off at this maximum. However, these XX1 functions approximate the threshold-linear function
for lower levels of excitation.
</p><p>You should also notice that XX1 and NOISY_XX1 get closer to each other as g_e gets larger.  The noise convolution has much less of an effect when the function gets flatter, as it does in the saturating nonlinearity region.  Convolving noise with a linear function gives you back the linear function itself, so wherever the function is approximately linear, noise has much less of an effect.
</p><p>When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 9/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:9-0!1!0!!en!2!edit=0 and timestamp 20090903112423 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Units\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Units</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Units\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Units&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Units&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Units&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Units\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Units\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Units\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Units&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Units&amp;oldid=520\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Units&amp;oldid=520&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Units&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 3 September 2009, at 09:02.</li>
					<li id=\"viewcount\">This page has been accessed 2,887 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.166 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="LayerWizEl";
     n_units=25;
     io_type=190578;
    };
    LayerWizEl @[1] {
     name="LayerWizEl";
     n_units=25;
     io_type=131072;
    };
    LayerWizEl @[2] {
     name="LayerWizEl";
     n_units=25;
     io_type=131073;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {
     name="DocLink";
     doc=.projects[0].docs[0]$$;
    };
   };
   name="ControlPanel";
   auto_edit=1;
   desc="The master control panel for the simulation -- see the Doc panel for more info";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="act_fun";
     desc=" activation function to use<br>  NOISY XX1:  x over x plus 1 convolved with Gaussian noise (noise is nvar)<br>  XX1:  x over x plus 1, hard threshold, no noise convolution<br>  NOISY LINEAR:  simple linear output function (still thesholded) convolved with Gaussian noise (noise is nvar)<br>  LINEAR:  simple linear output function (still thesholded)<br>  SPIKE:  discrete spiking activations (spike when > thr)";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0]$$;
     mbr=LeabraUnitSpec::act_fun;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="g_bar";
     desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
     cust_desc=0;
     base=$.projects[0].networks[0].specs[0]$;
     mbr=LeabraUnitSpec::g_bar;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="e_rev";
     desc=" [Defaults: 1, .15, .15, 1, 0] reversal potentials for each channel<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
     cust_desc=0;
     base=$.projects[0].networks[0].specs[0]$;
     mbr=LeabraUnitSpec::e_rev;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="noise var";
     desc=" 'varibility' parameter for the random numbers (gauss = standard deviation, not variance; uniform = half-range)";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0].noise$$;
     mbr=Random::var;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Sending Unit Activation Timing";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="n_cycles";
      desc=" integer value (also for enum types)";
      cust_desc=0;
      base=.projects[0].programs.gp[0][0].vars[0]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="on_cycle";
      desc=" integer value (also for enum types)";
      cust_desc=0;
      base=.projects[0].programs.gp[0][0].vars[1]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="off_cycle";
      desc=" integer value (also for enum types)";
      cust_desc=0;
      base=.projects[0].programs.gp[0][0].vars[2]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[1] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Defaults";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs[0]$$;
     mth=Program::Init;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="Environment_0";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.4579606354236603;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [1] "Event_0";      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1788908839225769;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 1] 0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {
      name="DocLink";
      doc=$.projects[0].docs[0]$;
     };
    };
    name="CycleOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cycle";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[1] {
      name="net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="I_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="v_m";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="act_eq";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="SetDefaults";
   short_nm="SDflts";
   tags=;
   desc="restores default initial parameters in the simulation";
   flags=;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="act_fun";
     var_type=T_HardEnum;
     int_val=0;
     hard_enum_type=LeabraUnitSpec::ActFun;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="g_bar_e";
     var_type=T_Real;
     real_val=0.4;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default g_bar.e value";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="g_bar_l";
     var_type=T_Real;
     real_val=2.8;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default g_bar.l value";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="e_rev_e";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default g_rev_e value";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="e_rev_l";
     var_type=T_Real;
     real_val=0.15;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default e_rev_l value";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="noise_var";
     var_type=T_Real;
     real_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default noise val";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="n_cycles";
     var_type=T_Int;
     int_val=200;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default number of cycles";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="on_cycle";
     var_type=T_Int;
     int_val=10;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default input on cycle";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="off_cycle";
     var_type=T_Int;
     int_val=160;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="default input off cycle";
     init_from=NULL;
    };
    ProgVar @[9] {
     name="unit_spec";
     var_type=T_Object;
     object_type=LeabraUnitSpec;
     object_val=$.projects[0].networks[0].specs[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[10] {
     name="settle";
     var_type=T_Object;
     object_type=Program;
     object_val=$.projects[0].programs.gp[0][0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[11] {
     name="ControlPanel";
     var_type=T_Object;
     object_type=SelectEdit;
     object_val=.projects[0].edits[0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    MemberAssign @[0] {
     desc=;
     flags=;
     obj=.projects[0].programs[0].vars[9]$$;
     path="g_bar.e";
     expr {
      expr="g_bar_e";
     };
     update_after=0;
    };
    MemberAssign @[1] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="g_bar.l";
     expr {
      expr="g_bar_l";
     };
     update_after=0;
    };
    MemberAssign @[2] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="e_rev.e";
     expr {
      expr="e_rev_e";
     };
     update_after=0;
    };
    MemberAssign @[3] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="e_rev.l";
     expr {
      expr="e_rev_l";
     };
     update_after=0;
    };
    MemberAssign @[4] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="noise.var";
     expr {
      expr="noise_var";
     };
     update_after=0;
    };
    MemberAssign @[5] {
     desc=;
     flags=;
     obj=$.projects[0].programs[0].vars[9]$;
     path="act_fun";
     expr {
      expr="act_fun";
     };
     update_after=1;
    };
    MethodCall @[6] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[10]$$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"n_cycles\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="n_cycles";
       };
      };
     };
    };
    MethodCall @[7] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[10]$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"on_cycle\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="on_cycle";
       };
      };
     };
    };
    MethodCall @[8] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[10]$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"off_cycle\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="const Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="off_cycle";
       };
      };
     };
    };
    MethodCall @[9] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[11]$$;
     method=SelectEdit::UpdateAfterEdit;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=.projects[0].networks[0]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="n_cycles";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="total number of cycles to process";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="on_cycle";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="cycle number to turn input on";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="off_cycle";
      var_type=T_Int;
      int_val=160;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="cycle number to turn input off";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="send_act";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="sending unit activation";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[3]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=Network::Init_Acts;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetCounterInit @[1] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[3]$;
      counter=Network::cycle;
      update_after=1;
     };
     MethodCall @[2] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=OFF;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][0].vars[4]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][0].vars[4]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       IfElse @[0] {
	desc=;
	flags=;
	cond {
	 expr="cycle >= on_cycle && cycle < off_cycle";
	};
	true_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc="on";
	  flags=;
	  result_var=.projects[0].programs.gp[0][0].vars[5]$$;
	  expr {
	   expr="1.0";
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc="off";
	  flags=;
	  result_var=$.projects[0].programs.gp[0][0].vars[5]$;
	  expr {
	   expr="0.0";
	  };
	 };
	};
       };
       MemberAssign @[1] {
	desc="set to network";
	flags=;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	path="layers[0].units[0].act";
	expr {
	 expr="send_act";
	};
	update_after=0;
       };
       ProgramCall @[2] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraCycle*";
       };
       MemberAssign @[3] {
	desc="need to set again for display because network turns it off..";
	flags=;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	path="layers[0].units[0].act";
	expr {
	 expr="send_act";
	};
	update_after=0;
       };
       NetUpdateView @[4] {
	desc="update network views, if update_net_view == true";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	update_var=.projects[0].programs.gp[0][0].vars[6]$$;
       };
       NetCounterIncr @[5] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[3]$;
	counter=Network::cycle;
	update_after=1;
       };
       IfContinue @[6] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=OFF;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[7] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=OFF;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < n_cycles";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][0].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][0].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      update_var=$.projects[0].programs.gp[0][0].vars[6]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     PrintExpr @[0] {
      desc=;
      flags=OFF;
      expr {
       expr="network.cycle";
      };
     };
     MethodCall @[1] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[2] {
      desc="update network views if update_net_view == true";
      flags=OFF;
      network_var=$.projects[0].programs.gp[0][1].args[0]$;
      update_var=.projects[0].programs.gp[0][1].vars[0]$$;
     };
     ProgramCall @[3] {
      desc=;
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][2]$$;
      targ_ld_init="*LeabraCycleMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraCycleMonitor";
    short_nm="CycMnt";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="cycle";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cycle";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="net";
	computed=0;
	object_type=LeabraUnit;
	object=.projects[0].networks[0].layers[1].units[0]$$;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="I_net";
	computed=0;
	object_type=LeabraUnit;
	object=$.projects[0].networks[0].layers[1].units[0]$;
	variable="I_net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="v_m";
	computed=0;
	object_type=LeabraUnit;
	object=$.projects[0].networks[0].layers[1].units[0]$;
	variable="v_m";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="act";
	computed=0;
	object_type=LeabraUnit;
	object=$.projects[0].networks[0].layers[1].units[0]$;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="act_eq";
	computed=0;
	object_type=LeabraUnit;
	object=$.projects[0].networks[0].layers[1].units[0]$;
	variable="act_eq";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][0]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][2].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[0]$$;
      method=taBase::DataUpdate;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="begin";
	required=1;
	def_val=;
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[0]$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[4] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[0]$;
      method=taBase::DataUpdate;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="begin";
	required=1;
	def_val=;
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=OFF;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAkgAAAt4AAALqAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="Network";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=1;
	  net_text=0;
	  net_text_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=-0.5: z=0: }: };
	  net_text_rot=0;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[1].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_BOTH;
	  max_size {x=1: y=1: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.1;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    name="v_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=;Receiver=;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5: y=0.5640469: z=1.702481: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.785078;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="CycleOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="cycle";
	    m_data=.projects[0].data.gp[1][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=1: max=200: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="net";
	    m_data=.projects[0].data.gp[1][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=-0.5: fix_max=1: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="I_net";
	    m_data=.projects[0].data.gp[1][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.82: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="v_m";
	    m_data=.projects[0].data.gp[1][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.248072: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="act";
	    m_data=.projects[0].data.gp[1][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="act_eq";
	    m_data=.projects[0].data.gp[1][0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.696202: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1.2;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="cycle";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=200: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=200: };
	   range {min=0: max=200: };
	   n_ticks=10;
	   axis_length=1.2;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="net";
	   fixed_range {fix_min=1: min=-0.5: fix_max=1: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.5: max=1: };
	   range {min=-0.5: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="I_net";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="v_m";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="yellow": r=1: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="act";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="act_eq";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.533978: y=0.4449999: z=1.751291: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.763791;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.02140077762305737;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05921855941414833;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7159532904624939;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="lt_avg_norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="st_avg_norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="lt_avg_ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="st_avg_ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="maxda";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="ct_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="time";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="tick";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[19] {
     name="trial";
     value 1 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[20] {
     name="group";
     value 1 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[21] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[22] {
     name="batch";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="UnitNet";
   desc=;
   specs {
    name=;
    el_typ=BaseSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="UnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0: g_gain=1: window=1: eq_gain=10: eq_dt=0: };
     spike_misc {
      exp_slope=0;
      spk_thr=0.25;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=0.4: l=2.8: i=1: h=0.1: a=0.1: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.1;
      spike_gain=0.01;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=VM_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
     noise_adapt {trial_fixed=0: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.1: min_pct_c=0.9: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="ConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="BiasSpec_0";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.02: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LayerSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=0: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraUnitSpec @[4] {
     name="BioUnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[1].children[0]$: };
     sse_tol=0.5;
     act_fun=SPIKE;
     act {gelin=0: thr=-55: gain=4.14: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0: g_gain=1: window=1: eq_gain=9: eq_dt=0: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=-90: max=55: range=145: scale=0.006896552: };
     v_m_init {name="": type=UNIFORM: mean=-70: var=0: par=1: };
     dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=0.4: l=2.8: i=1: h=0.1: a=0.1: };
     e_rev {e=55: l=-70: i=-70: h=55: a=-90: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.1;
      spike_gain=0.01;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=VM_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0: par=1: };
     noise_adapt {trial_fixed=0: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.1: min_pct_c=0.9: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=1: y=1: z=2: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=1: y=1: n_not_xy=0: n=1: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=1: y=1: n_not_xy=0: n=1: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=1: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       name="SendingUnit";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[1].projections[0]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.04170745;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.148;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.15;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="SendingUnit";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=0: max_i=0: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=-2.8: max=-2.8: max_i=0: };
     acts {cmpt=1: avg=0: max=0: max_i=0: };
     acts_p {cmpt=1: avg=0: max=0: max_i=0: };
     acts_m {cmpt=1: avg=0: max=0: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.001142156: i_kwta_pt=0: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Receiver";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     disp_scale=1;
     un_geom {x=1: y=1: n_not_xy=0: n=1: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=1: y=1: n_not_xy=0: n=1: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1]$$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=1: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="ReceivingUnit";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=4.863073e-22;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {1; };
	};
       };
       send {
	name=;
	el_typ=SendCons;
	el_def=0;
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=0: y=0: z=0: };
       act_eq=0.55;
       act_nd=0.55;
       act_avg=0.1823698;
       act_m=0.55;
       act_p=0.55;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.1555034;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.15;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="ReceivingUnit";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=1.215768e-21: max=1.215768e-21: max_i=0: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=-2.8: max=-2.8: max_i=0: };
     acts {cmpt=1: avg=0.55: max=0.55: max_i=0: };
     acts_p {cmpt=1: avg=0.55: max=0.55: max_i=0: };
     acts_m {cmpt=1: avg=0.55: max=0.55: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1347978: i_kwta_pt=0: g_bar_i=1: g_bar_l=0.1: };
     maxda=0.002763808;
     act_max_avg=0.5769754;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=14904;
   group_name=;
   trial_name=;
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=189;
   cur_cnt_err=0;
   train_time {name="train_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="epoch_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=6.169293311314099e-71;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=2;
   n_cons=1;
   max_size {x=1: y=1: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=PLUS_ONLY;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=2;
   ct_cycle=200;
   time_inc=1;
   cycle_max=200;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=1;
    m_sum=3075;
    m_nrm=0.0003252033;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0.001;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=200;
   avg_cycles=0;
   avg_cycles_sum=36200;
   avg_cycles_n=189;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=2;
   avg_send_pct=0;
   avg_send_pct_sum=4444;
   avg_send_pct_n=21671;
   maxda_stopcrit=0.005;
   maxda=0.002763808;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0;
   avg_norm_err_sum=0;
   avg_norm_err_n=4;
  };
 };
};
