// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [3] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [6] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem @[4] { };
	EditMbrItem @[5] { };
	EditMbrItem_Group @.gp[0] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
	EditMbrItem_Group @.gp[1] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
      };

      EditMthItem_Group @.mths = [5] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [5] { 
      DataTable @[0] { 
    UserDataItem_List @*(.user_data_) {
	  UserData_DocLink @[0] { };
    };

	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[3] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[4] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp[1] = [4] { 
      DataTable @[0] { 
	DataTableCols @.data = [10] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  int_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[5] { };
	  int_Data @[6] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [8] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [4] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { };
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { };
	};
      };
      DataTable @[3] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { };
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [2] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [2] {
	ResetDataRows @[0] { };
	ResetDataRows @[1] { };
      };

      ProgEl_List @.prog_code = [4] {
	DataGroupProg @[0] { 
	  DataOpList @.ops = [4] {
	    DataGroupEl @[0] { };
	    DataGroupEl @[1] { };
	    DataGroupEl @[2] { };
	    DataGroupEl @[3] { };
	  };
	};
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [12] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	    ProgArg @[9] { };
	    ProgArg @[10] { };
	    ProgArg @[11] { };
	  };
	};
	DataGroupProg @[2] { 
	  DataOpList @.ops = [4] {
	    DataGroupEl @[0] { };
	    DataGroupEl @[1] { };
	    DataGroupEl @[2] { };
	    DataGroupEl @[3] { };
	  };
	};
	MethodCall @[3] { 
	  ProgArg_List @.meth_args = [12] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	    ProgArg @[9] { };
	    ProgArg @[10] { };
	    ProgArg @[11] { };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [2] {
	DynEnumType @[0] { 
	  DynEnumItem_List @.enums = [4] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	    DynEnumItem @[2] { };
	    DynEnumItem @[3] { };
	  };
	};
	DynEnumType @[1] { 
	  DynEnumItem_List @.enums = [2] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	  };
	};
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [6] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
      };

      Function_List @.functions = [1] {
	Function @[0] { 
	  ProgVar_List @.args = [1] {
	    ProgVar @[0] { };
	  };

	  ProgEl_List @.fun_code = [3] {
	    ProgVars @[0] { 
	      ProgVar_List @.local_vars = [0] {
	      };
	    };
	    UserScript @[1] { };
	    UserScript @[2] { };
	  };
	};
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [6] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	IfReturn @[1] { };
	AssignExpr @[2] { };
	AssignExpr @[3] { };
	If @[4] { 
	  ProgEl_List @.true_code = [4] {
	    FunctionCall @[0] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    FunctionCall @[1] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    If @[2] { 
	      ProgEl_List @.true_code = [2] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		FunctionCall @[1] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
	      };
	    };
	    If @[3] { 
	      ProgEl_List @.true_code = [4] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		FunctionCall @[1] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		FunctionCall @[2] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		If @[3] { 
		  ProgEl_List @.true_code = [3] {
		    FunctionCall @[0] { 
		      ProgArg_List @.fun_args = [1] {
			ProgArg @[0] { };
		      };
		    };
		    FunctionCall @[1] { 
		      ProgArg_List @.fun_args = [1] {
			ProgArg @[0] { };
		      };
		    };
		    FunctionCall @[2] { 
		      ProgArg_List @.fun_args = [1] {
			ProgArg @[0] { };
		      };
		    };
		  };
		};
	      };
	    };
	  };
	};
	If @[5] { 
	  ProgEl_List @.true_code = [3] {
	    FunctionCall @[0] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    If @[1] { 
	      ProgEl_List @.true_code = [1] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
	      };
	    };
	    If @[2] { 
	      ProgEl_List @.true_code = [3] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		FunctionCall @[1] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
		If @[2] { 
		  ProgEl_List @.true_code = [2] {
		    FunctionCall @[0] { 
		      ProgArg_List @.fun_args = [1] {
			ProgArg @[0] { };
		      };
		    };
		    FunctionCall @[1] { 
		      ProgArg_List @.fun_args = [1] {
			ProgArg @[0] { };
		      };
		    };
		  };
		};
	      };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [8] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MemberAssign @[7] { };
	};

	ProgEl_List @.prog_code = [8] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MemberAssign @[4] { };
	  AssignExpr @[5] { };
	  WhileLoop @[6] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [8] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[4] { };
	  NetGroupedDataLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      If @[0] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};
	      };
	      AssignExpr @[1] { };
	      ProgramCall @[2] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[3] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[9] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  ProgramCall @[5] { 
	    ProgArg_List @.prog_args = [0] {
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [11] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MemberAssign @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      MemberAssign @[0] { };
	    };
	  };
	  WhileLoop @[6] { 
	    ProgEl_List @.loop_code = [5] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	      IfBreak @[4] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[9] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[10] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [4] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [10] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [3] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [3] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [2] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		  };
		};
		GraphTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		  };
		};
		GridTableView @[2] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [4] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[2] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[3] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [2] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [4] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraUnitSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.noise_sched = [0] {
	      };
	    };
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [6] {
	    LeabraConSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[2] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[3] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[4] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[5] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [3] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[2] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	LeabraBiasSpec @[3] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	BaseSpec_Group @.gp[0] = [8] { 
	  FullPrjnSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TesselPrjnSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [2] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	    };
	  };
	  TesselPrjnSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [6] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	      TessEl @[2] { };
	      TessEl @[3] { };
	      TessEl @[4] { };
	      TessEl @[5] { };
	    };
	  };
	  OneToOnePrjnSpec @[3] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  SymmetricPrjnSpec @[4] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TesselPrjnSpec @[5] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [3] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	      TessEl @[2] { };
	    };
	  };
	  TesselPrjnSpec @[6] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [1] {
	      TessEl @[0] { };
	    };
	  };
	  TesselPrjnSpec @[7] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [3] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	      TessEl @[2] { };
	    };
	  };
	};
      };

      Layer_Group @.layers = [7] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [14] {
	    LeabraUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[2] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[3] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[4] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[5] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[6] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[7] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[8] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[9] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[10] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[11] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[12] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[13] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [2]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [2]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [4]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [4]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[2] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[3] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[4] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [3]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[5] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [4]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [4]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[6] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [2]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [2]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [4] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	    LeabraPrjn @[3] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [4]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [4]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[2] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [6]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [6]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [6]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[3] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [4]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [4]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [4]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[4] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [4] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [1]		  };
		  LeabraSendCons @[3] { 
	   [6]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[3] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[2] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [6]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [1]		  };
		  LeabraSendCons @[2] { 
	   [6]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[4] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[2] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [3]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [3]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [3]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[3] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [2]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [2]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[4] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		  LeabraSendCons @[2] { 
	   [3]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[5] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[2] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [3] {
		  LeabraRecvCons @[0] { 
	   [3]		  };
		  LeabraRecvCons @[1] { 
	   [2]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		};

		SendCons_List @.send = [3] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [3]		  };
		  LeabraSendCons @[2] { 
	   [2]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[6] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [3]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	    LeabraUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [3]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [2] {
	NetViewObj @[0] { };
	NetViewObj @[1] { };
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ChangeLog";
   desc=;
   auto_open=0;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>

<li>Mon Oct  1 15:45:21 2007 pauli <code>attn_simple.proj.gz</code><br>

<li>Mon Oct  1 15:42:31 2007 pauli <code>attn_simple.proj.gz</code><br>

<li>Mon Oct  1 15:36:24 2007 pauli <code>attn_simple.proj.gz</code><br>
  fresh project after conversion
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<li>Mon Oct  1 15:45:21 2007 pauli <code>attn_simple.proj.gz</code><br>
<P>
<li>Mon Oct  1 15:42:31 2007 pauli <code>attn_simple.proj.gz</code><br>
<P>
<li>Mon Oct  1 15:36:24 2007 pauli <code>attn_simple.proj.gz</code><br>
  fresh project after conversion
</ul>
</body>
</html>
";
  };
  taDoc @[1] {
   name="ProgramDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>

= Simple Attention Model =

Let's step through the network structure and connectivity, which was completely pre-specified (i.e., the network was not trained, and no learning takes place, because it was easier to hand-construct this simple architecture).  As you can see, the network basically resembles figure 8.23 in the textbook, with mutually interconnected ''Spatial'' and ''Object'' pathways feeding off of a V1-like layer that contains a spatially mapped feature array (figure 8.25 in the text).  In this simple case, we're assuming that each \"object\" is represented by a single distinct feature in this array, and also that space is organized along a single dimension. Thus, the first row of units represents the first object's feature (which serves as the cue stimulus) in each of 7 locations, and the second row represents the second object's feature (which serves as the target) in these same 7 locations.

* Now select r.wt in the network view and click on the object and spatial units to see how they function via their connectivity patterns.

The object processing pathway has a sequence of 3 increasingly spatially invariant layers of representations, with each unit collapsing over 3 adjacent spatial locations of the object-defining feature in the layer below.  Note that the highest, fully spatially invariant level of the object pathway plays the role of the output layer, and is used for measuring the reaction time to detect objects.  This happens by stopping settling whenever the ''target'' output (object 2) gets above an activity of .6 (if this doesn't happen, settling stops after 200 cycles).

The spatial processing pathway has a sequence of two layers of spatial representations, differing in the level of spatial resolution.  As in the object pathway, each unit in the spatial pathway represents 3 adjacent spatial locations, but unlike the object pathway, these units are not sensitive to particular features.  Two units per location provide distributed representations in both layers of the spatial pathway.  This redundancy will be useful for demonstrating the effects of partial damage to this pathway.

== Perceiving Multiple Objects ==

Although much of the detailed behavioral data we will explore with the model concerns the Posner spatial cueing task, we think the more basic functional motivation for visual attention is to facilitate object recognition when multiple objects are presented simultaneously.  Therefore, we will start with a quick exploration of the network's object recognition capacities as a function of the spatial distribution of two objects.  This will provide an introduction to the kinds of interactions between spatial and object processing that can happen using this relatively simple model.  Let's begin by viewing the events that we will present to the network.

* Click on the [[.T3Tab.InputData]] tab to view the events -- MultiObj is in the upper left hand side.

You should see 3 events (Figure 8.26 in textbook). The first event has two different objects (features) present in different spatial locations.  Note that the target object has slightly higher activation (i.e., it is more salient), which will result in the reliable selection of this object over the other.  The next event has two of the same objects (targets) presented in different locations.  Finally, the last event has the two different objects in the same spatial location.  As the figure makes clear, recognizing objects when they overlap in the same location is considerably more difficult than when they appear in different locations.  Although it is clearly easier to recognize objects if only copies of the same object are present as opposed to different objects, this difference is not likely to be significant for small numbers of presented objects.

Now, let's test these predictions in the model.

* Switch back to viewing act in the network window.  Do Batch: Init and Step Trial in the control panel.

This will present the first event to the network, which will stop settling (i.e., updating the network's activations a cycle at a time) when the target unit's activation exceeds the threshold of .6 in the Output layer.

* Then Step Trial through the remaining events.

You should have seen that the network settled relatively quickly for the first two events, but was slowed on the third event where the objects overlap in the same region of space (occasionally not so slow on the last one).  The graph view next to the network shows the pattern more precisely, showing the settling times (number of cycles to reach threshold) for each event.

* To get a better sense of the overall pattern, hit Run and 10 runs of the model will be performed. To make things go faster, you can click on the [[.T3Tab.BatchOutputData]] tab just see the data output.  To see each run of data better, you can click on the GroupOutputData Graph tab at the bottom of the [[.PanelTab.SimpleAttnNet]] or [[.PanelTab.BatchOutputData]] view panel, and then click On the batch_group field for the Z axis -- each batch will now be stacked backward in depth.

You should see that overall the network has more difficulty with the objects appearing in the same spatial location, where spatial attention cannot help focus on one object.  The overall average cycles by condition are reported in the upper-right table (BatchAvgOutputData) in the network view display (last column contains the cycles).

<hr>

'''Question 8.8 (a)''' <em>Describe the network's reaction to each event and explain it in terms of the interactions between the excitation and inhibition as it flows through the spatial and object pathways in the network. '''(b)''' Report the averages for each condition from the table in the network view panel. </em>

<hr>

You should have observed that spatial representations can facilitate the processing of objects by allocating attention to one object over another.  The key contrast condition is when both objects lie in the same location, so that spatial attention can no longer separate them out, leaving the object pathway to try to process both objects simultaneously.

== The Posner Spatial Cuing Task ==

Now, let's see how this model does on the Posner spatial cuing task.

* Set <code>input_data</code> in the control panel to <code>StdPosner</code>.  Click on the [[.T3Tab.InputData]] tab to see the input patterns (upper right grid view in that window).

There are three ''groups'' of events shown here, which correspond to a Neutral cue (no cue), a Valid cue, and an Invalid cue.  There is just one event for the neutral case, which is the presentation of the target object in the left location.  For the valid case, the first event is the cue presented on the left, followed by a target event with the target also on the left.  The invalid case has the same cue event, but the target shows up on the right (opposite) side of space.  The network's activations are not reset between the cue and target events within a group, but they are reset at the end of a group (after the target).  Thus, residual activation from the cuing event can persist and affect processing for the target event, but the activation is cleared between different trial types.

* Do Batch: Init and Step Trial. Note how the network responds to each of the three conditions of the Posner task as you continue to Step through these cases.  Press Run to run a batch of 10 runs (you can turn off the network Display button to speed up these batch runs).

Your graph log should resemble Figure 8.27 in the textbook. 

<hr>

'''Question 8.9 (a)''' <em>By what mechanism does the spatial cue influence the subsequent processing of the target in the valid and invalid cases? '''(b)''' How is this influence reflected in the settling time (report average data per condition/group from the table in the network view panel)?</em>

<hr>

Typical reaction times for young adults (i.e., college students) on this task are roughly: neutral, 370 ms; valid 350 ms; invalid 390 ms, showing about 20 ms on either side of the neutral condition for the effects of attentional focus.  These data should agree in general with the pattern of results you obtained, but to fit the data precisely you would have to add a constant offset of roughly 310 ms to the number of cycles of settling for each trial type.  This constant offset can be thought of as the time needed to perform all the other aspects of the task that are not included in the simulation (e.g., generating a response).  Note also that one cycle of settling in the network corresponds with one millisecond of processing in humans.  Of course, this relationship is not automatic -- we adjusted the time constant for activation updating (dt.vm = .07) so that the two were in agreement in this particular model.

=== Effects of Spatial Pathway Strength ===

Now let's explore the effects of the wt_scale parameters in the ControlPanel on the network's performance, which helps to illuminate how the network captures normal performance in this task.  First, let's try reducing Spat_Obj wt_scale.rel from 2 to 1, which reduces the influence of the two spatial pathway layers on the corresponding object pathway layers.

* Do a Batch Run with Spat_Obj set to 1.

You should find that the network settling time for the invalid condition has decreased from roughly 83 cycles for the standard network to roughly 75 cycles for this case.  This faster settling for the invalid trials is just what one would expect -- because there is less of a spatial attention effect on the object system, the invalid cue does not slow it down as much.  The effects on the other trial types are less interesting, and involve some technical effects of the wt_scale parameters on processing speed in the network.

* Set Spat_Obj wt_scale.rel back to 2, and  reduce the influence from the V1 layer to the spatial representations by reducing the value of V1_Spat wt_scale.rel from 2 to 1.5 and then to 1, doing a Batch Run for each and noting the cycle averages.

Again the interesting effect is in the invalid trials, where the network takes an average of roughly 91 and 115 cycles for V1_Spat values of 1.5 and 1, respectively.  As V1 has less effect on the spatial pathway, it becomes more and more difficult for input in a novel location (e.g., the target presented on the opposite side of the cue) to overcome the residual spatial activation in the cued location.  This shows that the spatial pathway needs to have a balance between sensitivity to bottom-up inputs and ability to retain a focus of spatial attention over time.  This network allows this balance to be set separately from that of the influence of the spatial pathway on the object pathway (controlled by the Spat_Obj parameter), which is not the case with the Cohen et al. (1994)
model.

* Set V1_Spat wt_scale.rel back to 2 before continuing.

=== Close Posner and Retinal Eccentricity ===

One additional manipulation we can make is to the eccentricity (visual distance) of the cue and target.  If they are presented closer together, then one might expect to get less of an attentional effect, or even a facilitation if the nearby location was partially activated by the cue.

* Set input_data to ClosePosner, and Init, Step Trial, and then Run through this case.

You will see that an overlapping set of spatial representations is activated, and the Batch Run reveals that there is no longer a significant slowing for the invalid case relative to the neutral case (but the validity effect remains).

* Switch the input_data back to StdPosner before continuing.

=== Effects of Spatial Pathway Lesions ===

As we mentioned earlier, Posner et al. (1984) showed that patients who had suffered lesions in one hemisphere of the parietal cortex exhibit differentially impaired performance on the invalid trials of the Posner spatial cuing task.  Specifically, they are slower when the cue is presented on the side of space processed by the intact hemisphere (i.e., ipsilateral to the lesion), and the target is then processed by the lesioned hemisphere.  The patients showed a 120 ms difference between invalid and valid cases, with a validly cued RT of roughly 640 ms, and an invalidly cued RT of 760 ms.  These data can be compared to matched (elderly) control subjects who showed a roughly 60 ms invalid-valid difference, with a validly cued RT of 540 ms and an invalidly cued RT 600 ms (Table 8.3 in the textbook). 

You should notice that, as one might expect, older people are slower than the young adult normals, and older people with some kind of brain damage are still slower yet, due to generalized effects of the damage.  In this case, we are interested in the specific involvement of the parietal lobes in these attentional phenomena, and so we have to be careful to dissociate the specific from the generalized effects.  To determine if the patients have a specific attentional problem, we must first find a way of {\\em normalizing} the data so that we can make useful comparisons among these different groups (including the model). We normalize by dividing the elderly control's data by a constant factor to get the same basic numbers reported for the adult normals (or the model).  If there is a specific effect of the brain damage, we should find that the pattern of reaction times is different from the adult normals even when it is appropriately normalized.

To find the appropriate scaling factors, we use the ratio between the valid RT's for the different groups.  Ideally, we would want to use the neutral case, which should be a good measure of the overall slowing, but only the valid and invalid trial data are available for the patients and elderly controls.  So, to compare the elderly controls with the adult normals, we take the adult valid RT's of 350 ms, and divide that by the elderly control subjects valid RT's of 540 ms, giving a ratio of .65.  Now, we multiply the elderly controls invalid RT's (600 ms) by this factor, and we should get something close to the adult normals invalid RT's (390 ms).  Indeed, the fit is perfect -- 600 * .65 = 390.  The elderly controls thus appear to behave just like the adult normals, but with a constant slowing factor.

However, when we apply this normalizing procedure to the patient's data, the results do not fit well.  Thus, we again divide 350 ms by the the 640 ms valid RT's, giving a ratio of .55.  Then, we do 760 * .55 = 418, which is substantially slower than the 390 ms invalid times for the adult normals (Table 8.3).  This makes it clear that the patients are specifically slower in the invalid trials even when their overall slowing has been taken into account by the normalizing procedure.  This differential slowing is what led to the hypothesis that these patients have difficulty disengaging attention.

Now, we lesion the model, and see if it simulates the patient's data. However, because the model will not suffer the generalized effects of brain damage (which are probably caused by swelling and other such factors), and because it will not \"age,\" we expect it to behave just like a adult subject that has only the specific effect of the lesion.  Thus, we compare the model's performance to the normalized patient values.  Although we can add in the 310 ms constant to the models' settling time to get a comparable RT measure, it is somewhat easier to just compare the difference between the invalid and valid cases, which subtracts away any constant factors (see the Diff column in Table 8.3).

* To lesion the model, set the <code>lesion_lay</code> field in the control panel to SPAT1_2 instead of NO_LESION, and make sure the lesion_locations and lesion_n_units values are both set to HALF, which will lesion only the right half of the spatial layers, and only 1 out of the 2 spatial units in each location.  Apply this change, and then hit the Lesion button.  Select r.wt in the network view and confirm that these units (the back 2 units on the right for Spat1, and the back right unit for Spat2) have their weights zeroed out.  Init, Step Trial, and then Run the lesioned network.

<hr>

'''Question 8.10 (a)''' <em>Report the resulting averages.  '''(b)''' Compute the invalid-valid difference, and compare it with the patient's data, and with the intact network.  '''(c)''' With the network Display on and viewing act,  Step through the events, and explain why the lesioned model is slower on the invalid trials in terms of the activation dynamics of the network.</em>

<hr>

You should have found that you can simulate the apparent disengage deficit without having a specific \"disengager\" mechanism.

=== Reverse Posner ===

One additional source of support for this model comes from the pattern of patient data for the opposite configuration of the cuing task, where the cue is presented in the lesioned side of space, and the invalid target is thus presented in the intact side.  Interestingly, data from Posner et al. (1984) clearly show that there is a very reduced invalid-valid reaction time difference for this condition in the patients.  Thus, it appears that it is easier for the patients to switch attention to the intact side of space, and therefore less of an invalid cost, relative to the normal control data.  Furthermore, there appears to be less of a valid cuing effect for the patients when the cue and target are presented on the damaged side as compared to the intact side.  Let's see what the model has to say about this.

* Set input_data to ReversePosner, and do Init, Step Trial, Run for this case.

You should see that the network shows a reduced difference between the valid and invalid trials compared to the intact network (an average of roughly 55 cycles for valid, 61 for invalid, for a difference of only around 6 compared to around 41 for the intact network).  Thus, the cue has less of an effect -- less facilitation on valid trials and less interference on invalid ones.  This is exactly the pattern seen in the Posner et al. (1984) data.  In the model, it occurs simply because the stronger intact side of space where the target is presented has less difficulty competing with the damaged side of space where the cue was presented.  In contrast, the disengage theory would predict that the lesioned network on the reverse Posner task should perform like the intact network on the standard Posner task.  Under these conditions, any required disengaging abilities should be intact (either because the network has not been lesioned, or because the cue is presented on the side of space that the lesioned network should be able to disengage from).

== Balint's Syndrome ==

As mentioned previously, additional lesion data comes from ''Balint's syndrome'' patients, who suffered from ''bilateral'' parietal lesions.  The most striking feature of these patients is that they have ''simultanagnosia'' -- the inability to recognize multiple objects presented simultaneously (see Farah, 1990 for a review).  Interestingly, when such subjects were tested on the Posner task (e.g., Coslett & Saffran, 1991), they exhibited a ''decreased'' level of attentional effects (i.e., a smaller invalid-valid difference).  As emphasized by Cohen et al. (1994), these data provide an important argument against the ''disengage'' explanation of parietal function offered by Posner and colleagues, which would instead predict bilateral slowing for invalid trials (i.e., difficulty disengaging).  The observed pattern of data falls naturally out of the model we have been exploring.

* To simulate this condition, first set input_data back to StdPosner, and then set lesion_locations to FULL instead of HALF (keep lesion_n_units at HALF), and do Lesion.

* Init, Step Trial, and Run the bilaterally lesioned network.

<hr>

'''Question 8.11 (a)''' <em> Report the results of the Batch Run for the bilaterally lesioned network.  '''(b)''' Explain how and why these results differ from those of the unilaterally lesioned network.</em>

<hr>

Finally, we can explore the effects of a more severe lesion to the parietal spatial representations, which might provide a better model of the syndrome known as ''hemispatial neglect'' (typically referred to as just ''neglect'').  As described previously, neglect results from unilateral lesions of the parietal cortex (usually in the right hemisphere), which cause patients to generally neglect the lesioned side of space.  We simulate neglect by doing a similar lesion to the unilateral one we did before, but by doing FULL for lesion_n_units to lesion both of the units in each location.

* Specifically, set lesion_locations back to HALF, and set lesion_n_units FULL, and do Lesion.  Set input_data to the MultiObj case.  Do Init, Step Trial, Run in the overall control panel.

Observe that even when the more salient object is in the lesioned side of space, the network still focuses attention on the intact side.  Thus, it is specifically neglecting this lesioned side.  In the first case, this causes the network to activate the cue object representation, which does not stop the network settling, resulting in a full 200 cycles of settling.  

* Now set input_data to StdPosner, and then do Init, Step Trial, Run.

You will see a similar neglect phenomenon, which makes the network completely incapable of switching attention into the damaged side of space to detect the target (again resulting in the full 200 cycles of settling for the invalid case).

Interestingly, if one does the ReversePosner case, then all attentional effects are completely eliminated, so that the settling times are relatively similar in all three conditions (roughly around 67 cycles).  This is not because the network is incapable of processing stimuli in the damaged side of space -- by looking at the activations in the network you can see that it does process the cue. Instead, the target presented to the good side of space has no difficulty competing with the weak residual representation of the cue in the damaged side.  Competition can explain the general tendency for neglect on the grounds that it is very rare to actually have no other competing stimuli (which can be relatively weak and still win the competition), coming into the intact side of space, so that attention is usually focused on the intact side.

The smaller level of damage that produces the slowed target detection times in the Posner task may be more closely associated with the phenomenon of ''extinction'', in which patients with unilateral parietal lesions show neglect only when there is a relatively strong competing visual stimulus presented to the good side of space (e.g., the cue in the invalid trials of the Posner task).  Thus, the model may be able to account for a wide range of different spatial processing deficits associated with parietal damage, depending on both the severity and location of damage.

== Temporal Dynamics and Inhibition of Return ==

Another interesting aspect of the Posner spatial cuing task has to do with the temporal dynamics of the attentional cuing effect.  To this point, we have ignored these aspects of the task by assuming that the cue activation persists to the point of target onset.  This corresponds to experimental conditions when the target follows the cue after a relatively short delay (e.g., around 100 ms).  However, the Posner task has also been run with longer delays between the cue and the target (e.g., 500 ms), with some interesting results.  Instead of a facilitation effect for the valid trials relative to the invalid ones, the ordering of valid and invalid trials actually reverses at the long delays (e.g., Maylor, 1985).  This phenomenon has been labeled ''inhibition of return'', to denote the idea that there is something that inhibits the system from returning attention to the cued location after a sufficient delay.

Our model can be used to simulate at least the qualitative patterns of behavior on the Posner task over different delays.  This is done by varying the length of cue presentation (a variable delay event could have been inserted, but residual activation would persist anyway, and varying the cue length is simpler), and turning on the accommodation current, which causes neurons that have been active for a while to \"fatigue\" (see Section 2.9 in
Chapter 2 for details).  Thus, if the cue activation persists for long enough, those spatial representations will become fatigued, and if attention is subsequently directed there, the network will actually be slower to respond.  Also, because the spatial activations have fatigued, they no longer compete with the activation of the other location for the invalidly cued trials, eliminating the slowing.

Now, let's see this in the model.

* First, un-lesion the network by setting lesion_lay to NO_LESION and doing Lesion.  Next, set input_data to StdPosner.  Then, click the acc.on button in the control panel to turn on accommodation. Next, let's choose a cue duration that, even with the accommodation channels active, still produces the original pattern of results. Set cue_dur to 75.  Now, do Init, Step Trial, and Run.

You should observe the now-familiar pattern of a valid facilitation and an invalid slowing.  

* Batch Run with increasing durations (change using the cue_dur field) in increments of 25 from 75 to 200.

You should see that the valid-invalid difference decreases with increasing duration, equalizes at 125 epochs, and by 150 epochs, the validly cued condition is actually ''slower'' than the invalidly cued one, which is the hallmark of the inhibition of return phenomenon (Figure 8.28).

* Step through the running of the network with cue_dur at 150.

<hr>

'''Question 8.12''' <em>Report in detail what happens on the valid and invalid trials that produces the inhibition of return effect. </em>

<hr>

== Object-Based Attentional Effects ==

So far, we have explored spatially mediated attentional effects. However, the very same mechanisms (and model) can be used to understand object-based attentional effects.  For example, instead of cuing one region of space, we can cue one object, and then present a display containing the cue object and another different object, and determine which of the two objects is processed more readily.  By analogy with the Posner spatial cuing paradigm, we would expect that the cued object would be processed more readily than the non-cued one. Of course, one would have to use different, but similar cue and target objects to rule out a target detection response based on the cue itself.

Because a simple object recognition task is problematic, the object-based attention studies that have been run experimentally typically involve a comparison between two operations (e.g., detecting a small visual target) on one object versus two operations on two different objects.  If the spatial distances associated with these operations are the same in the two conditions, any difference in reaction time would indicate a cost for switching attention between the two objects.  Such an object cost has been found in a number of studies (Duncan, 1984; Vecera & Farah, 1994; Mozer et al., 1992).

In the simulator, we can run the simpler cuing experiment analogous to the Posner task because we have transparent access to the internal representations, and can measure the object processing facilitation directly.

* Set input_type to ObjAttn, and click on [[.T3Tab.InputData]] to see these patterns (lower left grid view).

The first event is a control condition, where we present two objects without any prior cuing.  Note that, as in the MultiObj case, the target object is more strongly activated than the cue object, so the network will process the target object.  The next event is a cuing event, where the cue object is presented in the central location. Then, within the same group so that activations persist, the next event presents the two objects just as in the first event.  Thus, if the prior object cue is effective, it should be able to overcome the relatively small difference in bottom-up salience between the two objects, so that the network processes the cue object and not the target.  Finally, the next two events are for the case where the two objects appear in the same location.  Recall that before, the network was unable to select either object for processing in this case, because they are spatially overlapping.  Perhaps now, with the object-based attentional cue, the network will be able to focus on the cue object.

* Make sure acc is off and cue_dur is back to 200, and then do Init, Step Trial (you may also need to turn the network display on).  Note how the network responds to each of the three task conditions as you continue to Step through these cases.

You should observe that the prior object cue is indeed capable of influencing subsequent processing in favor of the same object.  Note also that the spatial system responds to this in the appropriate manner -- it activates the spatial location associated with the cued object.  Finally, note that the top-down object cue is sufficient to enable the system to select one object (even the less active one) when the two objects are presented overlapping in the same location.

</body>
</html>
";
   html_text="<html><head></head><body>
<p>
</p><h1> Simple Attention Model </h1>
<p>
Let's step through the network structure and connectivity, which was completely pre-specified (i.e., the network was not trained, and no learning takes place, because it was easier to hand-construct this simple architecture).  As you can see, the network basically resembles figure 8.23 in the textbook, with mutually interconnected  <i>Spatial</i>  and  <i>Object</i>  pathways feeding off of a V1-like layer that contains a spatially mapped feature array (figure 8.25 in the text).  In this simple case, we're assuming that each \"object\" is represented by a single distinct feature in this array, and also that space is organized along a single dimension. Thus, the first row of units represents the first object's feature (which serves as the cue stimulus) in each of 7 locations, and the second row represents the second object's feature (which serves as the target) in these same 7 locations.
</p><p>
</p><ul><li> Now select r.wt in the network view and click on the object and spatial units to see how they function via their connectivity patterns.
</li></ul>
The object processing pathway has a sequence of 3 increasingly spatially invariant layers of representations, with each unit collapsing over 3 adjacent spatial locations of the object-defining feature in the layer below.  Note that the highest, fully spatially invariant level of the object pathway plays the role of the output layer, and is used for measuring the reaction time to detect objects.  This happens by stopping settling whenever the  <i>target</i>  output (object 2) gets above an activity of .6 (if this doesn't happen, settling stops after 200 cycles).
<p>
The spatial processing pathway has a sequence of two layers of spatial representations, differing in the level of spatial resolution.  As in the object pathway, each unit in the spatial pathway represents 3 adjacent spatial locations, but unlike the object pathway, these units are not sensitive to particular features.  Two units per location provide distributed representations in both layers of the spatial pathway.  This redundancy will be useful for demonstrating the effects of partial damage to this pathway.
</p><p>
</p><h2> Perceiving Multiple Objects </h2>
<p>
Although much of the detailed behavioral data we will explore with the model concerns the Posner spatial cueing task, we think the more basic functional motivation for visual attention is to facilitate object recognition when multiple objects are presented simultaneously.  Therefore, we will start with a quick exploration of the network's object recognition capacities as a function of the spatial distribution of two objects.  This will provide an introduction to the kinds of interactions between spatial and object processing that can happen using this relatively simple model.  Let's begin by viewing the events that we will present to the network.
</p><p>
</p><ul><li> Click on the <a href=\"ta:.T3Tab.InputData\">InputData</a> tab to view the events -- MultiObj is in the upper left hand side.
</li></ul>
You should see 3 events (Figure 8.26 in textbook). The first event has two different objects (features) present in different spatial locations.  Note that the target object has slightly higher activation (i.e., it is more salient), which will result in the reliable selection of this object over the other.  The next event has two of the same objects (targets) presented in different locations.  Finally, the last event has the two different objects in the same spatial location.  As the figure makes clear, recognizing objects when they overlap in the same location is considerably more difficult than when they appear in different locations.  Although it is clearly easier to recognize objects if only copies of the same object are present as opposed to different objects, this difference is not likely to be significant for small numbers of presented objects.
<p>
Now, let's test these predictions in the model.
</p><p>
</p><ul><li> Switch back to viewing act in the network window.  Do Batch: Init and Step Trial in the control panel.
</li></ul>
This will present the first event to the network, which will stop settling (i.e., updating the network's activations a cycle at a time) when the target unit's activation exceeds the threshold of .6 in the Output layer.
<p>
</p><ul><li> Then Step Trial through the remaining events.
</li></ul>
You should have seen that the network settled relatively quickly for the first two events, but was slowed on the third event where the objects overlap in the same region of space (occasionally not so slow on the last one).  The graph view next to the network shows the pattern more precisely, showing the settling times (number of cycles to reach threshold) for each event.
<p>
</p><ul><li> To get a better sense of the overall pattern, hit Run and 10 runs of the model will be performed. To make things go faster, you can click on the <a href=\"ta:.T3Tab.BatchOutputData\">BatchOutputData</a> tab just see the data output.  To see each run of data better, you can click on the GroupOutputData Graph tab at the bottom of the <a href=\"ta:.PanelTab.SimpleAttnNet\">SimpleAttnNet</a> or <a href=\"ta:.PanelTab.BatchOutputData\">BatchOutputData</a> view panel, and then click On the batch_group field for the Z axis -- each batch will now be stacked backward in depth.
</li></ul>
You should see that overall the network has more difficulty with the objects appearing in the same spatial location, where spatial attention cannot help focus on one object.  The overall average cycles by condition are reported in the upper-right table (BatchAvgOutputData) in the network view display (last column contains the cycles).
<p>
</p><hr>
<p>
 <b>Question 8.8 (a)</b>  <em>Describe the network's reaction to each event and explain it in terms of the interactions between the excitation and inhibition as it flows through the spatial and object pathways in the network.  <b>(b)</b>  Report the averages for each condition from the table in the network view panel. </em>
</p><p>
</p><hr>
<p>
You should have observed that spatial representations can facilitate the processing of objects by allocating attention to one object over another.  The key contrast condition is when both objects lie in the same location, so that spatial attention can no longer separate them out, leaving the object pathway to try to process both objects simultaneously.
</p><p>
</p><h2> The Posner Spatial Cuing Task </h2>
<p>
Now, let's see how this model does on the Posner spatial cuing task.
</p><p>
</p><ul><li> Set <code>input_data</code> in the control panel to <code>StdPosner</code>.  Click on the <a href=\"ta:.T3Tab.InputData\">InputData</a> tab to see the input patterns (upper right grid view in that window).
</li></ul>
There are three  <i>groups</i>  of events shown here, which correspond to a Neutral cue (no cue), a Valid cue, and an Invalid cue.  There is just one event for the neutral case, which is the presentation of the target object in the left location.  For the valid case, the first event is the cue presented on the left, followed by a target event with the target also on the left.  The invalid case has the same cue event, but the target shows up on the right (opposite) side of space.  The network's activations are not reset between the cue and target events within a group, but they are reset at the end of a group (after the target).  Thus, residual activation from the cuing event can persist and affect processing for the target event, but the activation is cleared between different trial types.
<p>
</p><ul><li> Do Batch: Init and Step Trial. Note how the network responds to each of the three conditions of the Posner task as you continue to Step through these cases.  Press Run to run a batch of 10 runs (you can turn off the network Display button to speed up these batch runs).
</li></ul>
Your graph log should resemble Figure 8.27 in the textbook. 
<p>
</p><hr>
<p>
 <b>Question 8.9 (a)</b>  <em>By what mechanism does the spatial cue influence the subsequent processing of the target in the valid and invalid cases?  <b>(b)</b>  How is this influence reflected in the settling time (report average data per condition/group from the table in the network view panel)?</em>
</p><p>
</p><hr>
<p>
Typical reaction times for young adults (i.e., college students) on this task are roughly: neutral, 370 ms; valid 350 ms; invalid 390 ms, showing about 20 ms on either side of the neutral condition for the effects of attentional focus.  These data should agree in general with the pattern of results you obtained, but to fit the data precisely you would have to add a constant offset of roughly 310 ms to the number of cycles of settling for each trial type.  This constant offset can be thought of as the time needed to perform all the other aspects of the task that are not included in the simulation (e.g., generating a response).  Note also that one cycle of settling in the network corresponds with one millisecond of processing in humans.  Of course, this relationship is not automatic -- we adjusted the time constant for activation updating (dt.vm = .07) so that the two were in agreement in this particular model.
</p><p>
</p><h3> Effects of Spatial Pathway Strength </h3>
<p>
Now let's explore the effects of the wt_scale parameters in the ControlPanel on the network's performance, which helps to illuminate how the network captures normal performance in this task.  First, let's try reducing Spat_Obj wt_scale.rel from 2 to 1, which reduces the influence of the two spatial pathway layers on the corresponding object pathway layers.
</p><p>
</p><ul><li> Do a Batch Run with Spat_Obj set to 1.
</li></ul>
You should find that the network settling time for the invalid condition has decreased from roughly 83 cycles for the standard network to roughly 75 cycles for this case.  This faster settling for the invalid trials is just what one would expect -- because there is less of a spatial attention effect on the object system, the invalid cue does not slow it down as much.  The effects on the other trial types are less interesting, and involve some technical effects of the wt_scale parameters on processing speed in the network.
<p>
</p><ul><li> Set Spat_Obj wt_scale.rel back to 2, and  reduce the influence from the V1 layer to the spatial representations by reducing the value of V1_Spat wt_scale.rel from 2 to 1.5 and then to 1, doing a Batch Run for each and noting the cycle averages.
</li></ul>
Again the interesting effect is in the invalid trials, where the network takes an average of roughly 91 and 115 cycles for V1_Spat values of 1.5 and 1, respectively.  As V1 has less effect on the spatial pathway, it becomes more and more difficult for input in a novel location (e.g., the target presented on the opposite side of the cue) to overcome the residual spatial activation in the cued location.  This shows that the spatial pathway needs to have a balance between sensitivity to bottom-up inputs and ability to retain a focus of spatial attention over time.  This network allows this balance to be set separately from that of the influence of the spatial pathway on the object pathway (controlled by the Spat_Obj parameter), which is not the case with the Cohen et al. (1994)
model.
<p>
</p><ul><li> Set V1_Spat wt_scale.rel back to 2 before continuing.
</li></ul>
<h3> Close Posner and Retinal Eccentricity </h3>
<p>
One additional manipulation we can make is to the eccentricity (visual distance) of the cue and target.  If they are presented closer together, then one might expect to get less of an attentional effect, or even a facilitation if the nearby location was partially activated by the cue.
</p><p>
</p><ul><li> Set input_data to ClosePosner, and Init, Step Trial, and then Run through this case.
</li></ul>
You will see that an overlapping set of spatial representations is activated, and the Batch Run reveals that there is no longer a significant slowing for the invalid case relative to the neutral case (but the validity effect remains).
<p>
</p><ul><li> Switch the input_data back to StdPosner before continuing.
</li></ul>
<h3> Effects of Spatial Pathway Lesions </h3>
<p>
As we mentioned earlier, Posner et al. (1984) showed that patients who had suffered lesions in one hemisphere of the parietal cortex exhibit differentially impaired performance on the invalid trials of the Posner spatial cuing task.  Specifically, they are slower when the cue is presented on the side of space processed by the intact hemisphere (i.e., ipsilateral to the lesion), and the target is then processed by the lesioned hemisphere.  The patients showed a 120 ms difference between invalid and valid cases, with a validly cued RT of roughly 640 ms, and an invalidly cued RT of 760 ms.  These data can be compared to matched (elderly) control subjects who showed a roughly 60 ms invalid-valid difference, with a validly cued RT of 540 ms and an invalidly cued RT 600 ms (Table 8.3 in the textbook). 
</p><p>
You should notice that, as one might expect, older people are slower than the young adult normals, and older people with some kind of brain damage are still slower yet, due to generalized effects of the damage.  In this case, we are interested in the specific involvement of the parietal lobes in these attentional phenomena, and so we have to be careful to dissociate the specific from the generalized effects.  To determine if the patients have a specific attentional problem, we must first find a way of {\\em normalizing} the data so that we can make useful comparisons among these different groups (including the model). We normalize by dividing the elderly control's data by a constant factor to get the same basic numbers reported for the adult normals (or the model).  If there is a specific effect of the brain damage, we should find that the pattern of reaction times is different from the adult normals even when it is appropriately normalized.
</p><p>
To find the appropriate scaling factors, we use the ratio between the valid RT's for the different groups.  Ideally, we would want to use the neutral case, which should be a good measure of the overall slowing, but only the valid and invalid trial data are available for the patients and elderly controls.  So, to compare the elderly controls with the adult normals, we take the adult valid RT's of 350 ms, and divide that by the elderly control subjects valid RT's of 540 ms, giving a ratio of .65.  Now, we multiply the elderly controls invalid RT's (600 ms) by this factor, and we should get something close to the adult normals invalid RT's (390 ms).  Indeed, the fit is perfect -- 600 * .65 = 390.  The elderly controls thus appear to behave just like the adult normals, but with a constant slowing factor.
</p><p>
However, when we apply this normalizing procedure to the patient's data, the results do not fit well.  Thus, we again divide 350 ms by the the 640 ms valid RT's, giving a ratio of .55.  Then, we do 760 * .55 = 418, which is substantially slower than the 390 ms invalid times for the adult normals (Table 8.3).  This makes it clear that the patients are specifically slower in the invalid trials even when their overall slowing has been taken into account by the normalizing procedure.  This differential slowing is what led to the hypothesis that these patients have difficulty disengaging attention.
</p><p>
Now, we lesion the model, and see if it simulates the patient's data. However, because the model will not suffer the generalized effects of brain damage (which are probably caused by swelling and other such factors), and because it will not \"age,\" we expect it to behave just like a adult subject that has only the specific effect of the lesion.  Thus, we compare the model's performance to the normalized patient values.  Although we can add in the 310 ms constant to the models' settling time to get a comparable RT measure, it is somewhat easier to just compare the difference between the invalid and valid cases, which subtracts away any constant factors (see the Diff column in Table 8.3).
</p><p>
</p><ul><li> To lesion the model, set the <code>lesion_lay</code> field in the control panel to SPAT1_2 instead of NO_LESION, and make sure the lesion_locations and lesion_n_units values are both set to HALF, which will lesion only the right half of the spatial layers, and only 1 out of the 2 spatial units in each location.  Apply this change, and then hit the Lesion button.  Select r.wt in the network view and confirm that these units (the back 2 units on the right for Spat1, and the back right unit for Spat2) have their weights zeroed out.  Init, Step Trial, and then Run the lesioned network.
</li></ul>
<hr>
<p>
 <b>Question 8.10 (a)</b>  <em>Report the resulting averages.   <b>(b)</b>  Compute the invalid-valid difference, and compare it with the patient's data, and with the intact network.   <b>(c)</b>  With the network Display on and viewing act,  Step through the events, and explain why the lesioned model is slower on the invalid trials in terms of the activation dynamics of the network.</em>
</p><p>
</p><hr>
<p>
You should have found that you can simulate the apparent disengage deficit without having a specific \"disengager\" mechanism.
</p><p>
</p><h3> Reverse Posner </h3>
<p>
One additional source of support for this model comes from the pattern of patient data for the opposite configuration of the cuing task, where the cue is presented in the lesioned side of space, and the invalid target is thus presented in the intact side.  Interestingly, data from Posner et al. (1984) clearly show that there is a very reduced invalid-valid reaction time difference for this condition in the patients.  Thus, it appears that it is easier for the patients to switch attention to the intact side of space, and therefore less of an invalid cost, relative to the normal control data.  Furthermore, there appears to be less of a valid cuing effect for the patients when the cue and target are presented on the damaged side as compared to the intact side.  Let's see what the model has to say about this.
</p><p>
</p><ul><li> Set input_data to ReversePosner, and do Init, Step Trial, Run for this case.
</li></ul>
You should see that the network shows a reduced difference between the valid and invalid trials compared to the intact network (an average of roughly 55 cycles for valid, 61 for invalid, for a difference of only around 6 compared to around 41 for the intact network).  Thus, the cue has less of an effect -- less facilitation on valid trials and less interference on invalid ones.  This is exactly the pattern seen in the Posner et al. (1984) data.  In the model, it occurs simply because the stronger intact side of space where the target is presented has less difficulty competing with the damaged side of space where the cue was presented.  In contrast, the disengage theory would predict that the lesioned network on the reverse Posner task should perform like the intact network on the standard Posner task.  Under these conditions, any required disengaging abilities should be intact (either because the network has not been lesioned, or because the cue is presented on the side of space that the lesioned network should be able to disengage from).
<p>
</p><h2> Balint's Syndrome </h2>
<p>
As mentioned previously, additional lesion data comes from  <i>Balint's syndrome</i>  patients, who suffered from  <i>bilateral</i>  parietal lesions.  The most striking feature of these patients is that they have  <i>simultanagnosia</i>  -- the inability to recognize multiple objects presented simultaneously (see Farah, 1990 for a review).  Interestingly, when such subjects were tested on the Posner task (e.g., Coslett &amp; Saffran, 1991), they exhibited a  <i>decreased</i>  level of attentional effects (i.e., a smaller invalid-valid difference).  As emphasized by Cohen et al. (1994), these data provide an important argument against the  <i>disengage</i>  explanation of parietal function offered by Posner and colleagues, which would instead predict bilateral slowing for invalid trials (i.e., difficulty disengaging).  The observed pattern of data falls naturally out of the model we have been exploring.
</p><p>
</p><ul><li> To simulate this condition, first set input_data back to StdPosner, and then set lesion_locations to FULL instead of HALF (keep lesion_n_units at HALF), and do Lesion.
</li></ul>
<ul><li> Init, Step Trial, and Run the bilaterally lesioned network.
</li></ul>
<hr>
<p>
 <b>Question 8.11 (a)</b>  <em> Report the results of the Batch Run for the bilaterally lesioned network.   <b>(b)</b>  Explain how and why these results differ from those of the unilaterally lesioned network.</em>
</p><p>
</p><hr>
<p>
Finally, we can explore the effects of a more severe lesion to the parietal spatial representations, which might provide a better model of the syndrome known as  <i>hemispatial neglect</i>  (typically referred to as just  <i>neglect</i> ).  As described previously, neglect results from unilateral lesions of the parietal cortex (usually in the right hemisphere), which cause patients to generally neglect the lesioned side of space.  We simulate neglect by doing a similar lesion to the unilateral one we did before, but by doing FULL for lesion_n_units to lesion both of the units in each location.
</p><p>
</p><ul><li> Specifically, set lesion_locations back to HALF, and set lesion_n_units FULL, and do Lesion.  Set input_data to the MultiObj case.  Do Init, Step Trial, Run in the overall control panel.
</li></ul>
Observe that even when the more salient object is in the lesioned side of space, the network still focuses attention on the intact side.  Thus, it is specifically neglecting this lesioned side.  In the first case, this causes the network to activate the cue object representation, which does not stop the network settling, resulting in a full 200 cycles of settling.  
<p>
</p><ul><li> Now set input_data to StdPosner, and then do Init, Step Trial, Run.
</li></ul>
You will see a similar neglect phenomenon, which makes the network completely incapable of switching attention into the damaged side of space to detect the target (again resulting in the full 200 cycles of settling for the invalid case).
<p>
Interestingly, if one does the ReversePosner case, then all attentional effects are completely eliminated, so that the settling times are relatively similar in all three conditions (roughly around 67 cycles).  This is not because the network is incapable of processing stimuli in the damaged side of space -- by looking at the activations in the network you can see that it does process the cue. Instead, the target presented to the good side of space has no difficulty competing with the weak residual representation of the cue in the damaged side.  Competition can explain the general tendency for neglect on the grounds that it is very rare to actually have no other competing stimuli (which can be relatively weak and still win the competition), coming into the intact side of space, so that attention is usually focused on the intact side.
</p><p>
The smaller level of damage that produces the slowed target detection times in the Posner task may be more closely associated with the phenomenon of  <i>extinction</i> , in which patients with unilateral parietal lesions show neglect only when there is a relatively strong competing visual stimulus presented to the good side of space (e.g., the cue in the invalid trials of the Posner task).  Thus, the model may be able to account for a wide range of different spatial processing deficits associated with parietal damage, depending on both the severity and location of damage.
</p><p>
</p><h2> Temporal Dynamics and Inhibition of Return </h2>
<p>
Another interesting aspect of the Posner spatial cuing task has to do with the temporal dynamics of the attentional cuing effect.  To this point, we have ignored these aspects of the task by assuming that the cue activation persists to the point of target onset.  This corresponds to experimental conditions when the target follows the cue after a relatively short delay (e.g., around 100 ms).  However, the Posner task has also been run with longer delays between the cue and the target (e.g., 500 ms), with some interesting results.  Instead of a facilitation effect for the valid trials relative to the invalid ones, the ordering of valid and invalid trials actually reverses at the long delays (e.g., Maylor, 1985).  This phenomenon has been labeled  <i>inhibition of return</i> , to denote the idea that there is something that inhibits the system from returning attention to the cued location after a sufficient delay.
</p><p>
Our model can be used to simulate at least the qualitative patterns of behavior on the Posner task over different delays.  This is done by varying the length of cue presentation (a variable delay event could have been inserted, but residual activation would persist anyway, and varying the cue length is simpler), and turning on the accommodation current, which causes neurons that have been active for a while to \"fatigue\" (see Section 2.9 in
Chapter 2 for details).  Thus, if the cue activation persists for long enough, those spatial representations will become fatigued, and if attention is subsequently directed there, the network will actually be slower to respond.  Also, because the spatial activations have fatigued, they no longer compete with the activation of the other location for the invalidly cued trials, eliminating the slowing.
</p><p>
Now, let's see this in the model.
</p><p>
</p><ul><li> First, un-lesion the network by setting lesion_lay to NO_LESION and doing Lesion.  Next, set input_data to StdPosner.  Then, click the acc.on button in the control panel to turn on accommodation. Next, let's choose a cue duration that, even with the accommodation channels active, still produces the original pattern of results. Set cue_dur to 75.  Now, do Init, Step Trial, and Run.
</li></ul>
You should observe the now-familiar pattern of a valid facilitation and an invalid slowing.  
<p>
</p><ul><li> Batch Run with increasing durations (change using the cue_dur field) in increments of 25 from 75 to 200.
</li></ul>
You should see that the valid-invalid difference decreases with increasing duration, equalizes at 125 epochs, and by 150 epochs, the validly cued condition is actually  <i>slower</i>  than the invalidly cued one, which is the hallmark of the inhibition of return phenomenon (Figure 8.28).
<p>
</p><ul><li> Step through the running of the network with cue_dur at 150.
</li></ul>
<hr>
<p>
 <b>Question 8.12</b>  <em>Report in detail what happens on the valid and invalid trials that produces the inhibition of return effect. </em>
</p><p>
</p><hr>
<p>
</p><h2> Object-Based Attentional Effects </h2>
<p>
So far, we have explored spatially mediated attentional effects. However, the very same mechanisms (and model) can be used to understand object-based attentional effects.  For example, instead of cuing one region of space, we can cue one object, and then present a display containing the cue object and another different object, and determine which of the two objects is processed more readily.  By analogy with the Posner spatial cuing paradigm, we would expect that the cued object would be processed more readily than the non-cued one. Of course, one would have to use different, but similar cue and target objects to rule out a target detection response based on the cue itself.
</p><p>
Because a simple object recognition task is problematic, the object-based attention studies that have been run experimentally typically involve a comparison between two operations (e.g., detecting a small visual target) on one object versus two operations on two different objects.  If the spatial distances associated with these operations are the same in the two conditions, any difference in reaction time would indicate a cost for switching attention between the two objects.  Such an object cost has been found in a number of studies (Duncan, 1984; Vecera &amp; Farah, 1994; Mozer et al., 1992).
</p><p>
In the simulator, we can run the simpler cuing experiment analogous to the Posner task because we have transparent access to the internal representations, and can measure the object processing facilitation directly.
</p><p>
</p><ul><li> Set input_type to ObjAttn, and click on <a href=\"ta:.T3Tab.InputData\">InputData</a> to see these patterns (lower left grid view).
</li></ul>
The first event is a control condition, where we present two objects without any prior cuing.  Note that, as in the MultiObj case, the target object is more strongly activated than the cue object, so the network will process the target object.  The next event is a cuing event, where the cue object is presented in the central location. Then, within the same group so that activations persist, the next event presents the two objects just as in the first event.  Thus, if the prior object cue is effective, it should be able to overcome the relatively small difference in bottom-up salience between the two objects, so that the network processes the cue object and not the target.  Finally, the next two events are for the case where the two objects appear in the same location.  Recall that before, the network was unable to select either object for processing in this case, because they are spatially overlapping.  Perhaps now, with the object-based attentional cue, the network will be able to focus on the cue object.
<p>
</p><ul><li> Make sure acc is off and cue_dur is back to 200, and then do Init, Step Trial (you may also need to turn the network display on).  Note how the network responds to each of the three task conditions as you continue to Step through these cases.
</li></ul>
You should observe that the prior object cue is indeed capable of influencing subsequent processing in favor of the same object.  Note also that the spatial system responds to this in the appropriate manner -- it activates the spatial location associated with the cued object.  Finally, note that the top-down object cue is sufficient to enable the system to select one object (even the less active one) when the two objects are presented overlapping in the same location.
<p>


</p></body></html>";
  };
  taDoc @[2] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_AttnSimple";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_AttnSimple";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 AttnSimple,CECN1 Projects,Emergent,.T3Tab.InputData,.PanelTab.SimpleAttnNet\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 AttnSimple - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_AttnSimple\";
		var wgTitle = \"CECN1 AttnSimple\";
		var wgAction = \"view\";
		var wgArticleId = \"107\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 404;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_AttnSimple skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 AttnSimple</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Simple_Attention_.28Posner_Spatial_Cuing_Task.29\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Simple Attention (Posner Spatial Cuing Task)</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Perceiving_Multiple_Objects\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Perceiving Multiple Objects</span></a></li>
<li class=\"toclevel-2\"><a href=\"#The_Posner_Spatial_Cuing_Task\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">The Posner Spatial Cuing Task</span></a>
<ul>
<li class=\"toclevel-3\"><a href=\"#Effects_of_Spatial_Pathway_Strength\"><span class=\"tocnumber\">2.2.1</span> <span class=\"toctext\">Effects of Spatial Pathway Strength</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Close_Posner_and_Retinal_Eccentricity\"><span class=\"tocnumber\">2.2.2</span> <span class=\"toctext\">Close Posner and Retinal Eccentricity</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Effects_of_Spatial_Pathway_Lesions\"><span class=\"tocnumber\">2.2.3</span> <span class=\"toctext\">Effects of Spatial Pathway Lesions</span></a></li>
<li class=\"toclevel-3\"><a href=\"#Reverse_Posner\"><span class=\"tocnumber\">2.2.4</span> <span class=\"toctext\">Reverse Posner</span></a></li>
</ul>
</li>
<li class=\"toclevel-2\"><a href=\"#Balint.27s_Syndrome\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">Balint's Syndrome</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Temporal_Dynamics_and_Inhibition_of_Return\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Temporal Dynamics and Inhibition of Return</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Object-Based_Attentional_Effects\"><span class=\"tocnumber\">2.5</span> <span class=\"toctext\">Object-Based Attentional Effects</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Simple_Attention_.28Posner_Spatial_Cuing_Task.29\" id=\"Simple_Attention_.28Posner_Spatial_Cuing_Task.29\"></a><h1> <span class=\"mw-headline\"> Simple Attention (Posner Spatial Cuing Task) </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/b/bb/attn_simple.proj\" class=\"internal\" title=\"attn simple.proj\">attn_simple.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p>Let's step through the network structure and connectivity, which was completely pre-specified (i.e., the network was not trained, and no learning takes place, because it was easier to hand-construct this simple architecture).  As you can see, the network basically resembles figure 8.23 in the textbook, with mutually interconnected <i>Spatial</i> and <i>Object</i> pathways feeding off of a V1-like layer that contains a spatially mapped feature array (figure 8.25 in the text).  In this simple case, we're assuming that each \"object\" is represented by a single distinct feature in this array, and also that space is organized along a single dimension. Thus, the first row of units represents the first object's feature (which serves as the cue stimulus) in each of 7 locations, and the second row represents the second object's feature (which serves as the target) in these same 7 locations.
</p>
<ul><li> Now select r.wt in the network view and click on the object and spatial units to see how they function via their connectivity patterns.
</li></ul>
<p>The object processing pathway has a sequence of 3 increasingly spatially invariant layers of representations, with each unit collapsing over 3 adjacent spatial locations of the object-defining feature in the layer below.  Note that the highest, fully spatially invariant level of the object pathway plays the role of the output layer, and is used for measuring the reaction time to detect objects.  This happens by stopping settling whenever the <i>target</i> output (object 2) gets above an activity of .6 (if this doesn't happen, settling stops after 200 cycles).
</p><p>The spatial processing pathway has a sequence of two layers of spatial representations, differing in the level of spatial resolution.  As in the object pathway, each unit in the spatial pathway represents 3 adjacent spatial locations, but unlike the object pathway, these units are not sensitive to particular features.  Two units per location provide distributed representations in both layers of the spatial pathway.  This redundancy will be useful for demonstrating the effects of partial damage to this pathway.
</p>
<a name=\"Perceiving_Multiple_Objects\" id=\"Perceiving_Multiple_Objects\"></a><h2> <span class=\"mw-headline\"> Perceiving Multiple Objects </span></h2>
<p>Although much of the detailed behavioral data we will explore with the model concerns the Posner spatial cueing task, we think the more basic functional motivation for visual attention is to facilitate object recognition when multiple objects are presented simultaneously.  Therefore, we will start with a quick exploration of the network's object recognition capacities as a function of the spatial distribution of two objects.  This will provide an introduction to the kinds of interactions between spatial and object processing that can happen using this relatively simple model.  Let's begin by viewing the events that we will present to the network.
</p>
<ul><li> Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.InputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.InputData (page does not exist)\">.T3Tab.InputData</a> tab to view the events -- MultiObj is in the upper left hand side.
</li></ul>
<p>You should see 3 events (Figure 8.26 in textbook). The first event has two different objects (features) present in different spatial locations.  Note that the target object has slightly higher activation (i.e., it is more salient), which will result in the reliable selection of this object over the other.  The next event has two of the same objects (targets) presented in different locations.  Finally, the last event has the two different objects in the same spatial location.  As the figure makes clear, recognizing objects when they overlap in the same location is considerably more difficult than when they appear in different locations.  Although it is clearly easier to recognize objects if only copies of the same object are present as opposed to different objects, this difference is not likely to be significant for small numbers of presented objects.
</p><p>Now, let's test these predictions in the model.
</p>
<ul><li> Switch back to viewing act in the network window.  Do Batch: Init and Step in the control panel.
</li></ul>
<p>This will present the first event to the network, which will stop settling (i.e., updating the network's activations a cycle at a time) when the target unit's activation exceeds the threshold of .6 in the Output layer.
</p>
<ul><li> Then Step through the remaining events.
</li></ul>
<p>You should have seen that the network settled relatively quickly for the first two events, but was slowed on the third event where the objects overlap in the same region of space (occasionally not so slow on the last one).  The graph view next to the network shows the pattern more precisely, showing the settling times (number of cycles to reach threshold) for each event.
</p>
<ul><li> To get a better sense of the overall pattern, hit Run and 10 runs of the model will be performed. To see each run of data better, you can click on the GroupOutputData Graph tab at the bottom of the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.SimpleAttnNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.SimpleAttnNet (page does not exist)\">.PanelTab.SimpleAttnNet</a> view panel, and then click On the batch_group field for the Z axis -- each batch will now be stacked backward in depth.
</li></ul>
<p>You should see that overall the network has more difficulty with the objects appearing in the same spatial location, where spatial attention cannot help focus on one object.  The overall average cycles by condition are reported in the upper-right table (BatchAvgOutputData) in the network view display (last column contains the cycles).
</p>
<hr>
<p><b>Question 8.8 (a)</b> <em>Describe the network's reaction to each event and explain it in terms of the interactions between the excitation and inhibition as it flows through the spatial and object pathways in the network. <b>(b)</b> Report the averages for each condition from the table in the network view panel. </em>
</p>
<hr>
<p>You should have observed that spatial representations can facilitate the processing of objects by allocating attention to one object over another.  The key contrast condition is when both objects lie in the same location, so that spatial attention can no longer separate them out, leaving the object pathway to try to process both objects simultaneously.
</p>
<a name=\"The_Posner_Spatial_Cuing_Task\" id=\"The_Posner_Spatial_Cuing_Task\"></a><h2> <span class=\"mw-headline\"> The Posner Spatial Cuing Task </span></h2>
<p>Now, let's see how this model does on the Posner spatial cuing task.
</p>
<ul><li> Set <code>input_data</code> in the control panel to <code>StdPosner</code>.  Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.InputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.InputData (page does not exist)\">.T3Tab.InputData</a> tab to see the input patterns (upper right grid view in that window).
</li></ul>
<p>There are three <i>groups</i> of events shown here, which correspond to a Neutral cue (no cue), a Valid cue, and an Invalid cue.  There is just one event for the neutral case, which is the presentation of the target object in the left location.  For the valid case, the first event is the cue presented on the left, followed by a target event with the target also on the left.  The invalid case has the same cue event, but the target shows up on the right (opposite) side of space.  The network's activations are not reset between the cue and target events within a group, but they are reset at the end of a group (after the target).  Thus, residual activation from the cuing event can persist and affect processing for the target event, but the activation is cleared between different trial types.
</p>
<ul><li> Do Batch: Init and Step. Note how the network responds to each of the three conditions of the Posner task as you continue to Step through these cases.  Press Run to run a batch of 10 runs (you can turn off the network Display button to speed up these batch runs).
</li></ul>
<p>Your graph log should resemble Figure 8.27 in the textbook. 
</p>
<hr>
<p><b>Question 8.9 (a)</b> <em>By what mechanism does the spatial cue influence the subsequent processing of the target in the valid and invalid cases? <b>(b)</b> How is this influence reflected in the settling time (report average data per condition/group from the table in the network view panel)?</em>
</p>
<hr>
<p>Typical reaction times for young adults (i.e., college students) on this task are roughly: neutral, 370 ms; valid 350 ms; invalid 390 ms, showing about 20 ms on either side of the neutral condition for the effects of attentional focus.  These data should agree in general with the pattern of results you obtained, but to fit the data precisely you would have to add a constant offset of roughly 310 ms to the number of cycles of settling for each trial type.  This constant offset can be thought of as the time needed to perform all the other aspects of the task that are not included in the simulation (e.g., generating a response).  Note also that one cycle of settling in the network corresponds with one millisecond of processing in humans.  Of course, this relationship is not automatic -- we adjusted the time constant for activation updating (dt.vm = .07) so that the two were in agreement in this particular model.
</p>
<a name=\"Effects_of_Spatial_Pathway_Strength\" id=\"Effects_of_Spatial_Pathway_Strength\"></a><h3> <span class=\"mw-headline\"> Effects of Spatial Pathway Strength </span></h3>
<p>Now let's explore the effects of the wt_scale parameters in the ControlPanel on the network's performance, which helps to illuminate how the network captures normal performance in this task.  First, let's try reducing Spat_Obj wt_scale.rel from 2 to 1, which reduces the influence of the two spatial pathway layers on the corresponding object pathway layers.
</p>
<ul><li> Do a Batch Run with Spat_Obj set to 1.
</li></ul>
<p>You should find that the network settling time for the invalid condition has decreased from roughly 83 cycles for the standard network to roughly 75 cycles for this case.  This faster settling for the invalid trials is just what one would expect -- because there is less of a spatial attention effect on the object system, the invalid cue does not slow it down as much.  The effects on the other trial types are less interesting, and involve some technical effects of the wt_scale parameters on processing speed in the network.
</p>
<ul><li> Set Spat_Obj wt_scale.rel back to 2, and  reduce the influence from the V1 layer to the spatial representations by reducing the value of V1_Spat wt_scale.rel from 2 to 1.5 and then to 1, doing a Batch Run for each and noting the cycle averages.
</li></ul>
<p>Again the interesting effect is in the invalid trials, where the network takes an average of roughly 91 and 115 cycles for V1_Spat values of 1.5 and 1, respectively.  As V1 has less effect on the spatial pathway, it becomes more and more difficult for input in a novel location (e.g., the target presented on the opposite side of the cue) to overcome the residual spatial activation in the cued location.  This shows that the spatial pathway needs to have a balance between sensitivity to bottom-up inputs and ability to retain a focus of spatial attention over time.  This network allows this balance to be set separately from that of the influence of the spatial pathway on the object pathway (controlled by the Spat_Obj parameter), which is not the case with the Cohen et al. (1994)
model.
</p>
<ul><li> Set V1_Spat wt_scale.rel back to 2 before continuing.
</li></ul>
<a name=\"Close_Posner_and_Retinal_Eccentricity\" id=\"Close_Posner_and_Retinal_Eccentricity\"></a><h3> <span class=\"mw-headline\"> Close Posner and Retinal Eccentricity </span></h3>
<p>One additional manipulation we can make is to the eccentricity (visual distance) of the cue and target.  If they are presented closer together, then one might expect to get less of an attentional effect, or even a facilitation if the nearby location was partially activated by the cue.
</p>
<ul><li> Set input_data to ClosePosner, and Init, Step, and then Run through this case.
</li></ul>
<p>You will see that an overlapping set of spatial representations is activated, and the Batch Run reveals that there is no longer a significant slowing for the invalid case relative to the neutral case (but the validity effect remains).
</p>
<ul><li> Switch the input_data back to StdPosner before continuing.
</li></ul>
<a name=\"Effects_of_Spatial_Pathway_Lesions\" id=\"Effects_of_Spatial_Pathway_Lesions\"></a><h3> <span class=\"mw-headline\"> Effects of Spatial Pathway Lesions </span></h3>
<p>As we mentioned earlier, Posner et al. (1984) showed that patients who had suffered lesions in one hemisphere of the parietal cortex exhibit differentially impaired performance on the invalid trials of the Posner spatial cuing task.  Specifically, they are slower when the cue is presented on the side of space processed by the intact hemisphere (i.e., ipsilateral to the lesion), and the target is then processed by the lesioned hemisphere.  The patients showed a 120 ms difference between invalid and valid cases, with a validly cued RT of roughly 640 ms, and an invalidly cued RT of 760 ms.  These data can be compared to matched (elderly) control subjects who showed a roughly 60 ms invalid-valid difference, with a validly cued RT of 540 ms and an invalidly cued RT 600 ms (Table 8.3 in the textbook). 
</p><p>You should notice that, as one might expect, older people are slower than the young adult normals, and older people with some kind of brain damage are still slower yet, due to generalized effects of the damage.  In this case, we are interested in the specific involvement of the parietal lobes in these attentional phenomena, and so we have to be careful to dissociate the specific from the generalized effects.  To determine if the patients have a specific attentional problem, we must first find a way of {\\em normalizing} the data so that we can make useful comparisons among these different groups (including the model). We normalize by dividing the elderly control's data by a constant factor to get the same basic numbers reported for the adult normals (or the model).  If there is a specific effect of the brain damage, we should find that the pattern of reaction times is different from the adult normals even when it is appropriately normalized.
</p><p>To find the appropriate scaling factors, we use the ratio between the valid RT's for the different groups.  Ideally, we would want to use the neutral case, which should be a good measure of the overall slowing, but only the valid and invalid trial data are available for the patients and elderly controls.  So, to compare the elderly controls with the adult normals, we take the adult valid RT's of 350 ms, and divide that by the elderly control subjects valid RT's of 540 ms, giving a ratio of .65.  Now, we multiply the elderly controls invalid RT's (600 ms) by this factor, and we should get something close to the adult normals invalid RT's (390 ms).  Indeed, the fit is perfect -- 600 * .65 = 390.  The elderly controls thus appear to behave just like the adult normals, but with a constant slowing factor.
</p><p>However, when we apply this normalizing procedure to the patient's data, the results do not fit well.  Thus, we again divide 350 ms by the the 640 ms valid RT's, giving a ratio of .55.  Then, we do 760 * .55 = 418, which is substantially slower than the 390 ms invalid times for the adult normals (Table 8.3).  This makes it clear that the patients are specifically slower in the invalid trials even when their overall slowing has been taken into account by the normalizing procedure.  This differential slowing is what led to the hypothesis that these patients have difficulty disengaging attention.
</p><p>Now, we lesion the model, and see if it simulates the patient's data. However, because the model will not suffer the generalized effects of brain damage (which are probably caused by swelling and other such factors), and because it will not \"age,\" we expect it to behave just like a adult subject that has only the specific effect of the lesion.  Thus, we compare the model's performance to the normalized patient values.  Although we can add in the 310 ms constant to the models' settling time to get a comparable RT measure, it is somewhat easier to just compare the difference between the invalid and valid cases, which subtracts away any constant factors (see the Diff column in Table 8.3).
</p>
<ul><li> To lesion the model, set the <code>lesion_lay</code> field in the control panel to SPAT1_2 instead of NO_LESION, and make sure the lesion_locations and lesion_n_units values are both set to HALF, which will lesion only the right half of the spatial layers, and only 1 out of the 2 spatial units in each location.  Apply this change, and then hit the Lesion button.  Select r.wt in the network view and confirm that these units (the back 2 units on the right for Spat1, and the back right unit for Spat2) have their weights zeroed out.  Init, Step, and then Run the lesioned network.
</li></ul>
<hr>
<p><b>Question 8.10 (a)</b> <em>Report the resulting averages.  <b>(b)</b> Compute the invalid-valid difference, and compare it with the patient's data, and with the intact network.  <b>(c)</b> With the network Display on and viewing act,  Step through the events, and explain why the lesioned model is slower on the invalid trials in terms of the activation dynamics of the network.</em>
</p>
<hr>
<p>You should have found that you can simulate the apparent disengage deficit without having a specific \"disengager\" mechanism.
</p>
<a name=\"Reverse_Posner\" id=\"Reverse_Posner\"></a><h3> <span class=\"mw-headline\"> Reverse Posner </span></h3>
<p>One additional source of support for this model comes from the pattern of patient data for the opposite configuration of the cuing task, where the cue is presented in the lesioned side of space, and the invalid target is thus presented in the intact side.  Interestingly, data from Posner et al. (1984) clearly show that there is a very reduced invalid-valid reaction time difference for this condition in the patients.  Thus, it appears that it is easier for the patients to switch attention to the intact side of space, and therefore less of an invalid cost, relative to the normal control data.  Furthermore, there appears to be less of a valid cuing effect for the patients when the cue and target are presented on the damaged side as compared to the intact side.  Let's see what the model has to say about this.
</p>
<ul><li> Set input_data to ReversePosner, and do Init, Step, Run for this case.
</li></ul>
<p>You should see that the network shows a reduced difference between the valid and invalid trials compared to the intact network (an average of roughly 55 cycles for valid, 61 for invalid, for a difference of only around 6 compared to around 41 for the intact network).  Thus, the cue has less of an effect -- less facilitation on valid trials and less interference on invalid ones.  This is exactly the pattern seen in the Posner et al. (1984) data.  In the model, it occurs simply because the stronger intact side of space where the target is presented has less difficulty competing with the damaged side of space where the cue was presented.  In contrast, the disengage theory would predict that the lesioned network on the reverse Posner task should perform like the intact network on the standard Posner task.  Under these conditions, any required disengaging abilities should be intact (either because the network has not been lesioned, or because the cue is presented on the side of space that the lesioned network should be able to disengage from).
</p>
<a name=\"Balint.27s_Syndrome\" id=\"Balint.27s_Syndrome\"></a><h2> <span class=\"mw-headline\"> Balint's Syndrome </span></h2>
<p>As mentioned previously, additional lesion data comes from <i>Balint's syndrome</i> patients, who suffered from <i>bilateral</i> parietal lesions.  The most striking feature of these patients is that they have <i>simultanagnosia</i> -- the inability to recognize multiple objects presented simultaneously (see Farah, 1990 for a review).  Interestingly, when such subjects were tested on the Posner task (e.g., Coslett &amp; Saffran, 1991), they exhibited a <i>decreased</i> level of attentional effects (i.e., a smaller invalid-valid difference).  As emphasized by Cohen et al. (1994), these data provide an important argument against the <i>disengage</i> explanation of parietal function offered by Posner and colleagues, which would instead predict bilateral slowing for invalid trials (i.e., difficulty disengaging).  The observed pattern of data falls naturally out of the model we have been exploring.
</p>
<ul><li> To simulate this condition, first set input_data back to StdPosner, and then set lesion_locations to FULL instead of HALF (keep lesion_n_units at HALF), and do Lesion.
</li></ul>
<ul><li> Init, Step, and Run the bilaterally lesioned network.
</li></ul>
<hr>
<p><b>Question 8.11 (a)</b> <em> Report the results of the Batch Run for the bilaterally lesioned network.  <b>(b)</b> Explain how and why these results differ from those of the unilaterally lesioned network.</em>
</p>
<hr>
<p>Finally, we can explore the effects of a more severe lesion to the parietal spatial representations, which might provide a better model of the syndrome known as <i>hemispatial neglect</i> (typically referred to as just <i>neglect</i>).  As described previously, neglect results from unilateral lesions of the parietal cortex (usually in the right hemisphere), which cause patients to generally neglect the lesioned side of space.  We simulate neglect by doing a similar lesion to the unilateral one we did before, but by doing FULL for lesion_n_units to lesion both of the units in each location.
</p>
<ul><li> Specifically, set lesion_locations back to HALF, and set lesion_n_units FULL, and do Lesion.  Set input_data to the MultiObj case.  Do Init, Step, Run in the overall control panel.
</li></ul>
<p>Observe that even when the more salient object is in the lesioned side of space, the network still focuses attention on the intact side.  Thus, it is specifically neglecting this lesioned side.  In the first case, this causes the network to activate the cue object representation, which does not stop the network settling, resulting in a full 200 cycles of settling.  
</p>
<ul><li> Now set input_data to StdPosner, and then do Init, Step, Run.
</li></ul>
<p>You will see a similar neglect phenomenon, which makes the network completely incapable of switching attention into the damaged side of space to detect the target (again resulting in the full 200 cycles of settling for the invalid case).
</p><p>Interestingly, if one does the ReversePosner case, then all attentional effects are completely eliminated, so that the settling times are relatively similar in all three conditions (roughly around 67 cycles).  This is not because the network is incapable of processing stimuli in the damaged side of space -- by looking at the activations in the network you can see that it does process the cue. Instead, the target presented to the good side of space has no difficulty competing with the weak residual representation of the cue in the damaged side.  Competition can explain the general tendency for neglect on the grounds that it is very rare to actually have no other competing stimuli (which can be relatively weak and still win the competition), coming into the intact side of space, so that attention is usually focused on the intact side.
</p><p>The smaller level of damage that produces the slowed target detection times in the Posner task may be more closely associated with the phenomenon of <i>extinction</i>, in which patients with unilateral parietal lesions show neglect only when there is a relatively strong competing visual stimulus presented to the good side of space (e.g., the cue in the invalid trials of the Posner task).  Thus, the model may be able to account for a wide range of different spatial processing deficits associated with parietal damage, depending on both the severity and location of damage.
</p>
<a name=\"Temporal_Dynamics_and_Inhibition_of_Return\" id=\"Temporal_Dynamics_and_Inhibition_of_Return\"></a><h2> <span class=\"mw-headline\"> Temporal Dynamics and Inhibition of Return </span></h2>
<p>Another interesting aspect of the Posner spatial cuing task has to do with the temporal dynamics of the attentional cuing effect.  To this point, we have ignored these aspects of the task by assuming that the cue activation persists to the point of target onset.  This corresponds to experimental conditions when the target follows the cue after a relatively short delay (e.g., around 100 ms).  However, the Posner task has also been run with longer delays between the cue and the target (e.g., 500 ms), with some interesting results.  Instead of a facilitation effect for the valid trials relative to the invalid ones, the ordering of valid and invalid trials actually reverses at the long delays (e.g., Maylor, 1985).  This phenomenon has been labeled <i>inhibition of return</i>, to denote the idea that there is something that inhibits the system from returning attention to the cued location after a sufficient delay.
</p><p>Our model can be used to simulate at least the qualitative patterns of behavior on the Posner task over different delays.  This is done by varying the length of cue presentation (a variable delay event could have been inserted, but residual activation would persist anyway, and varying the cue length is simpler), and turning on the accommodation current, which causes neurons that have been active for a while to \"fatigue\" (see Section 2.9 in
Chapter 2 for details).  Thus, if the cue activation persists for long enough, those spatial representations will become fatigued, and if attention is subsequently directed there, the network will actually be slower to respond.  Also, because the spatial activations have fatigued, they no longer compete with the activation of the other location for the invalidly cued trials, eliminating the slowing.
</p><p>Now, let's see this in the model.
</p>
<ul><li> First, un-lesion the network by setting lesion_lay to NO_LESION and doing Lesion.  Next, set input_data to StdPosner.  Then, click the acc.on button in the control panel to turn on accommodation. Next, let's choose a cue duration that, even with the accommodation channels active, still produces the original pattern of results. Set cue_dur to 75.  Now, do Init, Step, and Run.
</li></ul>
<p>You should observe the now-familiar pattern of a valid facilitation and an invalid slowing.  
</p>
<ul><li> Batch Run with increasing durations (change using the cue_dur field) in increments of 25 from 75 to 200.
</li></ul>
<p>You should see that the valid-invalid difference decreases with increasing duration, equalizes at 125 epochs, and by 150 epochs, the validly cued condition is actually <i>slower</i> than the invalidly cued one, which is the hallmark of the inhibition of return phenomenon (Figure 8.28).
</p>
<ul><li> Step through the running of the network with cue_dur at 150.
</li></ul>
<hr>
<p><b>Question 8.12</b> <em>Report in detail what happens on the valid and invalid trials that produces the inhibition of return effect. </em>
</p>
<hr>
<a name=\"Object-Based_Attentional_Effects\" id=\"Object-Based_Attentional_Effects\"></a><h2> <span class=\"mw-headline\"> Object-Based Attentional Effects </span></h2>
<p>So far, we have explored spatially mediated attentional effects. However, the very same mechanisms (and model) can be used to understand object-based attentional effects.  For example, instead of cuing one region of space, we can cue one object, and then present a display containing the cue object and another different object, and determine which of the two objects is processed more readily.  By analogy with the Posner spatial cuing paradigm, we would expect that the cued object would be processed more readily than the non-cued one. Of course, one would have to use different, but similar cue and target objects to rule out a target detection response based on the cue itself.
</p><p>Because a simple object recognition task is problematic, the object-based attention studies that have been run experimentally typically involve a comparison between two operations (e.g., detecting a small visual target) on one object versus two operations on two different objects.  If the spatial distances associated with these operations are the same in the two conditions, any difference in reaction time would indicate a cost for switching attention between the two objects.  Such an object cost has been found in a number of studies (Duncan, 1984; Vecera &amp; Farah, 1994; Mozer et al., 1992).
</p><p>In the simulator, we can run the simpler cuing experiment analogous to the Posner task because we have transparent access to the internal representations, and can measure the object processing facilitation directly.
</p>
<ul><li> Set input_type to ObjAttn, and click on <a href=\"/CompCogNeuro/index.php?title=.T3Tab.InputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.InputData (page does not exist)\">.T3Tab.InputData</a> to see these patterns (lower left grid view).
</li></ul>
<p>The first event is a control condition, where we present two objects without any prior cuing.  Note that, as in the MultiObj case, the target object is more strongly activated than the cue object, so the network will process the target object.  The next event is a cuing event, where the cue object is presented in the central location. Then, within the same group so that activations persist, the next event presents the two objects just as in the first event.  Thus, if the prior object cue is effective, it should be able to overcome the relatively small difference in bottom-up salience between the two objects, so that the network processes the cue object and not the target.  Finally, the next two events are for the case where the two objects appear in the same location.  Recall that before, the network was unable to select either object for processing in this case, because they are spatially overlapping.  Perhaps now, with the object-based attentional cue, the network will be able to focus on the cue object.
</p>
<ul><li> Make sure acc is off and cue_dur is back to 200, and then do Init, Step (you may also need to turn the network display on).  Note how the network responds to each of the three task conditions as you continue to Step through these cases.
</li></ul>
<p>You should observe that the prior object cue is indeed capable of influencing subsequent processing in favor of the same object.  Note also that the spatial system responds to this in the appropriate manner -- it activates the spatial location associated with the cued object.  Finally, note that the top-down object cue is sufficient to enable the system to select one object (even the less active one) when the two objects are presented overlapping in the same location.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 12/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:107-0!1!0!!en!2!edit=0 and timestamp 20090904065519 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_AttnSimple\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_AttnSimple</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_AttnSimple\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_AttnSimple&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_AttnSimple&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_AttnSimple&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_AttnSimple\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_AttnSimple\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_AttnSimple\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_AttnSimple&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_AttnSimple&amp;oldid=404\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+AttnSimple&amp;oldid=404&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+AttnSimple&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 7 January 2009, at 09:13.</li>
					<li id=\"viewcount\">This page has been accessed 866 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.289 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="Main control panel for Simple Attention model";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="input_data";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0].args[1]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="Spat_Obj wt_scale";
     desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
     cust_desc=0;
     base=.projects[0].networks[0].specs[1].children[4]$$;
     mbr=LeabraConSpec::wt_scale;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="V1_Spat wt_scale";
     desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
     cust_desc=0;
     base=.projects[0].networks[0].specs[1].children[1]$$;
     mbr=LeabraConSpec::wt_scale;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="acc";
     desc=" [Defaults: .01, .5, .1, .1] accomodation (inhibitory) v-gated chan (K+)<br>  on: [Default: false]  true if channel is on<br>  b inc dt:  time constant for increases in basis variable (basis ~ intracellular calcium which builds up slowly as function of activation)<br>  b dec dt:  time constant for decreases in basis variable (basis ~ intracellular calcium which builds up slowly as function of activation)<br>  a thr:  activation threshold of the channel: when basis > a_thr, conductance starts to build up (channels open)<br>  d thr:  deactivation threshold of the channel: when basis < d_thr, conductance diminshes (channels close)<br>  g dt:  time constant for changing conductance (activating or deactivating) -- if = 1, then gc is equal to the basis if channel is on<br>  init:  initialize variables when state is intialized between trials (else with weights)<br>  trl:  update after every trial instead of every cycle -- time constants need to be much larger in general";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0].children[0]$$;
     mbr=LeabraUnitSpec::acc;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[4] {
     label="cue_dur";
     desc=" integer value (also for enum types)";
     cust_desc=0;
     base=.projects[0].programs.gp[0][4].vars[3]$$;
     mbr=ProgVar::int_val;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1;
     };
    };
    EditMbrItem @[5] {
     label="cycle update view";
     desc=" boolean value";
     cust_desc=0;
     base=.projects[0].programs.gp[0][5].vars[0]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Misc Special Parameters (not manipulated)";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="dt";
      desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
      cust_desc=0;
      base=.projects[0].networks[0].specs[0]$$;
      mbr=LeabraUnitSpec::dt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="act";
      desc=" activation function specs<br>  gelin:  compute rate-code activations directly off of the g_e excitatory conductance (i.e., net = netinput) compared to the g_e value that would put the unit right at its firing threshold (g_e_thr) -- this reproduces the empirical rate-code behavior of a discrete spiking network much better than computing off of the v_m - thr value -- important: when gelin is clicked, the membrane potential (v_m, and all other parameters relevant to it such as dt.vm) is completely irrelevant to the activation output of the unit -- all the other conductances (g_i, g_l, g_a, g_h) enter via their effects on the effective threshold (g_e_thr)<br>  thr: [Default: 0.25;0.5]  threshold value Theta (Q) for firing output activation (.5 is more accurate value based on AdEx biological parameters)<br>  gain: [Default: 600;80]  gain (gamma) of the sigmoidal rate-coded activation function -- 600 is default for gelin = false, 80 is default for gelin = true<br>  nvar: [Default: 0.005;0.01]  variance of the Gaussian noise kernel for convolving with XX1 in NOISY_XX1 -- 0.005 is default for geiln = false, 0.01 is default for gelin = true<br>  avg dt: [Default: 0.005]  time constant for integrating activation average (computed across trials)<br>  avg init: [Default: 0.15]  initial activation average value<br>  i thr:  [STD or NO_AH for da mod units) how to compute the inhibitory threshold for kWTA functions (what currents to include or exclude in determining what amount of inhibition would keep the unit just at threshold firing) -- for units with dopamine-like modulation using the a and h currents, NO_AH makes learning much more reliable because otherwise kwta partially compensates for the da modulation<br>    STD:  include all currents (except bias weights) in inhibitory threshold computation<br>    NO A:  exclude gc.a current: allows accommodation to knock out units from kwta active list, without other units coming in to take their place<br>    NO H:  exclude gc.h current: prevent hysteresis current from affecting inhibitory threshold computation<br>    NO AH:  exclude gc.a and gc.h currents: prevent both accommodation and hysteresis currents from affecting inhibitory threshold computation<br>    ALL:  include all currents INCLUDING bias weights";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[0]$;
      mbr=LeabraUnitSpec::act;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="noise";
      desc=" distribution parameters for random added noise<br>  type:  type of random variable to generate<br>    UNIFORM:  uniform with var = range on either side of the mean<br>    BINOMIAL:  binomial with var = p, par = n<br>    POISSON:  poisson with lambda = var<br>    GAMMA:  gamma with var and par = stages<br>    GAUSSIAN:  normal with var<br>    NONE:  just the mean<br>  mean:  mean of random distribution<br>  var:  'varibility' parameter for the random numbers (gauss = standard deviation, not variance; uniform = half-range)<br>  par:  extra parameter for distribution (depends on each one)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs[0]$;
      mbr=LeabraUnitSpec::noise;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[1] {
     name="Lesion Parameters";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="lesion_lay";
      desc=" current value, which for normal mutually-exclusive options is index into list of enums (-1 = not set), and for bits is the bit values";
      cust_desc=0;
      base=.projects[0].programs[1].vars[0].dyn_enum_val$$;
      mbr=DynEnum::value;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[1] {
      label="lesion_locations";
      desc=" current value, which for normal mutually-exclusive options is index into list of enums (-1 = not set), and for bits is the bit values";
      cust_desc=0;
      base=.projects[0].programs[1].vars[1].dyn_enum_val$$;
      mbr=DynEnum::value;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="lesion_n_units";
      desc=" current value, which for normal mutually-exclusive options is index into list of enums (-1 = not set), and for bits is the bit values";
      cust_desc=0;
      base=.projects[0].programs[1].vars[2].dyn_enum_val$$;
      mbr=DynEnum::value;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Batch: Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][0]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Lesion";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[1]$$;
     mth=Program::Run_Gui;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {
      name="DocLink";
      doc=.projects[0].docs[1]$$;
     };
    };
    name="MultiObjs";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [3] "Diff_Obj_Loc";"Same_Obj_Diff_Loc";"Diff_Obj_Same_Loc";      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [3] "Diff_Obj_Loc";"Same_Obj_Diff_Loc";"Diff_Obj_Same_Loc";      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 2 3] 0;0.81999999;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0.81999999;0;0;0;1;0;0;0.81999999;
0;0;0;0;0;0;1;0;0;0;
0;0;      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 2 3] 0;1;0;1;0;1;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="StdPosner";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Neutral";"Valid";"Valid";"Invalid";"Invalid";      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Target";"Cue";"Target";"Cue";"Target";      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 2 5] 0;0;0;0;0;0;0;0;1;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;1;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;1;0;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 2 5] 0;1;1;0;0;1;1;0;0;1;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="ClosePosner";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Neutral";"Valid";"Valid";"Invalid";"Invalid";      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Target";"Cue";"Target";"Cue";"Target";      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 2 5] 0;0;0;0;0;0;0;0;0;1;
0;0;0;0;0;0;1;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;1;0;0;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 2 5] 0;1;1;0;0;1;1;0;0;1;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    name="ReversePosner";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Neutral";"Valid";"Valid";"Invalid";"Invalid";      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Target";"Cue";"Target";"Cue";"Target";      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 2 5] 0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;1;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 2 5] 0;1;1;0;0;1;1;0;0;1;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[4] {
    name="ObjAttn";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "Neutral";"Valid";"Valid";"Invalid";"Invalid";      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] "NoObj";"ObjCue";"DiffPos";"ObjCue";"SamePos";      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 2 5] 0;0.81999999;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0.81999999;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0.81999999;0;0;
0;0;0;0;1;0;0;0;0;0;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1869158893823624;
	val_type_fixed=0;
       };
      };
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;2;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 2 5] 0;1;1;0;1;0;1;0;1;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[5] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[6] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="GroupOutputData";
    desc=;
    data {
     name="data";
     el_typ=DataColTp;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[1] {
      name="group_name_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="group_first";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="minus_cycles_last";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    name="BatchAvgOutputData";
    desc="average across entire batch of data run so far";
    data {
     name="data";
     el_typ=DataColTp;
     el_def=0;
     String_Data @[0] {
      name="group_name_group_group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="group_first_first";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch_group_last";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="minus_cycles_last_mean";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="GenGroupData";
   short_nm="GenData";
   tags=;
   desc="generate group-level data from trial data table";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="trial_mon_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="trial-level output data -- if we want to reset it every epoch";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="GroupOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][2]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="BatchAvgOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][3]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    ResetDataRows @[0] {
     desc=;
     flags=;
     data_var=.projects[0].programs[0].vars[1]$$;
    };
    ResetDataRows @[1] {
     desc=;
     flags=;
     data_var=.projects[0].programs[0].vars[2]$$;
    };
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    DataGroupProg @[0] {
     desc=;
     flags=;
     src_data_var=.projects[0].programs[0].vars[0]$$;
     dest_data_var=$.projects[0].programs[0].vars[1]$;
     group_spec {
      name="group_spec";
      ops {
       name=;
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="batch";
	agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="group_name";
	agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[2] {
	col_name="group";
	agg {name="Aggregate": op=FIRST: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[3] {
	col_name="minus_cycles";
	agg {name="Aggregate": op=LAST: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=1;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[1]$;
     method=DataTable::SortColName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col1";
       required=1;
       def_val=;
       expr {
	expr="\"batch_group\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="ascending1";
       required=0;
       def_val="true";
       expr {
	expr="true";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col2";
       required=0;
       def_val="\"\"";
       expr {
	expr="\"group_first\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="ascending2";
       required=0;
       def_val="true";
       expr {
	expr="true";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col3";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=bool;
       type="bool";
       name="ascending3";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col4";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=bool;
       type="bool";
       name="ascending4";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col5";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=bool;
       type="bool";
       name="ascending5";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col6";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=bool;
       type="bool";
       name="ascending6";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
     };
    };
    DataGroupProg @[2] {
     desc=;
     flags=;
     src_data_var=$.projects[0].programs[0].vars[1]$;
     dest_data_var=$.projects[0].programs[0].vars[2]$;
     group_spec {
      name="group_spec";
      ops {
       name=;
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="group_name_group";
	agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="group_first";
	agg {name="Aggregate": op=FIRST: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[2] {
	col_name="batch_group";
	agg {name="Aggregate": op=LAST: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[3] {
	col_name="minus_cycles_last";
	agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=1;
     };
    };
    MethodCall @[3] {
     desc=;
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[2]$;
     method=DataTable::SortColName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col1";
       required=1;
       def_val=;
       expr {
	expr="\"group_first_first\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="ascending1";
       required=0;
       def_val="true";
       expr {
	expr="true";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col2";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="ascending2";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col3";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=bool;
       type="bool";
       name="ascending3";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col4";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=bool;
       type="bool";
       name="ascending4";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col5";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=bool;
       type="bool";
       name="ascending5";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="col6";
       required=0;
       def_val="\"\"";
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=bool;
       type="bool";
       name="ascending6";
       required=0;
       def_val="true";
       expr {
	expr=;
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="LesionNet";
   short_nm="LsnNt";
   tags=;
   desc="lesion the network";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=DynEnumType;
    el_def=0;
    DynEnumType @[0] {
     name="LesionLayer";
     desc="layer(s) to lesion";
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="NO_LESION";
       value=0;
       desc="don't make any lesion (restore to intact network)";
      };
      DynEnumItem @[1] {
       name="SPAT1";
       value=1;
       desc="just lesion in Spat1 layer";
      };
      DynEnumItem @[2] {
       name="SPAT2";
       value=2;
       desc="just lesion in Spat2 layer";
      };
      DynEnumItem @[3] {
       name="SPAT1_2";
       value=3;
       desc="lesion in both Spat1 and Spat2 layers";
      };
     };
     bits=0;
    };
    DynEnumType @[1] {
     name="LesionSize";
     desc="How many units to lesion";
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="HALF";
       value=0;
       desc="only lesion half of the units (per location or across locations)";
      };
      DynEnumItem @[1] {
       name="FULL";
       value=1;
       desc="lesion all of the units (per location or across locations)";
      };
     };
     bits=0;
    };
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=.projects[0].networks[0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="network to train";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="lesion_lay";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[0].programs[1].types[0]$$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="locations";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[0].programs[1].types[1]$$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="n_units_per_loc";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=$.projects[0].programs[1].types[1]$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="i";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="Spat1";
     var_type=T_Object;
     object_type=LeabraLayer;
     object_val=.projects[0].networks[0].layers[2]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="Spat2";
     var_type=T_Object;
     object_type=LeabraLayer;
     object_val=.projects[0].networks[0].layers[3]$$;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
    Function @[0] {
     desc=;
     flags=;
     name="LesionUnit";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="unit";
       var_type=T_Object;
       object_type=Unit;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ProgVars @[0] {
       desc=;
       flags=;
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
       };
      };
      UserScript @[1] {
       desc="zero out the recv weights";
       flags=;
       script {
	expr="for(int g=0; g< unit.recv.size; g++) {
  for(int ci=0;ci<unit.recv[g].size;ci++) {
    unit.recv[g].Cn(ci)->wt = 0.0;
  }
}";
       };
      };
      UserScript @[2] {
       desc="zero out the send weights";
       flags=;
       script {
	expr="for(int g=0; g< unit.send.size; g++) {
  for(int ci=0;ci<unit.send[g].size;ci++) {
    unit.send[g].Cn(ci)->wt = 0.0;
  }
}";
       };
      };
     };
    };
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    MethodCall @[0] {
     desc="start with fresh weights";
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[1].args[0]$$;
     method=Network::Init_Weights;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    IfReturn @[1] {
     desc=;
     flags=;
     cond {
      expr="lesion_lay == NO_LESION";
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=;
     result_var=.projects[0].programs[1].vars[4]$$;
     expr {
      expr="network.layers.Spat1";
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=;
     result_var=.projects[0].programs[1].vars[5]$$;
     expr {
      expr="network.layers.Spat2";
     };
    };
    If @[4] {
     desc=;
     flags=;
     cond {
      expr="lesion_lay ==  SPAT1 ||  lesion_lay ==  SPAT1_2";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=;
       result_var=NULL;
       fun=.projects[0].programs[1].functions[0]$$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Unit;
	 type="Unit*";
	 name="unit";
	 required=1;
	 def_val=;
	 expr {
	  expr="Spat1.units.gp[3][1]";
	 };
	};
       };
      };
      FunctionCall @[1] {
       desc=;
       flags=;
       result_var=NULL;
       fun=$.projects[0].programs[1].functions[0]$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Unit;
	 type="Unit*";
	 name="unit";
	 required=1;
	 def_val=;
	 expr {
	  expr="Spat1.units.gp[4][1]";
	 };
	};
       };
      };
      If @[2] {
       desc=;
       flags=;
       cond {
	expr="n_units_per_loc ==  FULL";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat1.units.gp[3][0]";
	   };
	  };
	 };
	};
	FunctionCall @[1] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat1.units.gp[4][0]";
	   };
	  };
	 };
	};
       };
      };
      If @[3] {
       desc=;
       flags=;
       cond {
	expr="locations ==  FULL";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat1.units.gp[0][1]";
	   };
	  };
	 };
	};
	FunctionCall @[1] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat1.units.gp[1][1]";
	   };
	  };
	 };
	};
	FunctionCall @[2] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat1.units.gp[2][1]";
	   };
	  };
	 };
	};
	If @[3] {
	 desc=;
	 flags=;
	 cond {
	  expr="n_units_per_loc ==  FULL";
	 };
	 true_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  FunctionCall @[0] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   fun=$.projects[0].programs[1].functions[0]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Unit;
	     type="Unit*";
	     name="unit";
	     required=1;
	     def_val=;
	     expr {
	      expr="Spat1.units.gp[0][0]";
	     };
	    };
	   };
	  };
	  FunctionCall @[1] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   fun=$.projects[0].programs[1].functions[0]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Unit;
	     type="Unit*";
	     name="unit";
	     required=1;
	     def_val=;
	     expr {
	      expr="Spat1.units.gp[1][0]";
	     };
	    };
	   };
	  };
	  FunctionCall @[2] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   fun=$.projects[0].programs[1].functions[0]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Unit;
	     type="Unit*";
	     name="unit";
	     required=1;
	     def_val=;
	     expr {
	      expr="Spat1.units.gp[2][0]";
	     };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };
    If @[5] {
     desc=;
     flags=;
     cond {
      expr="lesion_lay ==  SPAT2 ||  lesion_lay ==  SPAT1_2";
     };
     true_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=;
       result_var=NULL;
       fun=$.projects[0].programs[1].functions[0]$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=Unit;
	 type="Unit*";
	 name="unit";
	 required=1;
	 def_val=;
	 expr {
	  expr="Spat2.units.gp[2][1]";
	 };
	};
       };
      };
      If @[1] {
       desc=;
       flags=;
       cond {
	expr="n_units_per_loc ==  FULL";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat2.units.gp[2][0]";
	   };
	  };
	 };
	};
       };
      };
      If @[2] {
       desc=;
       flags=;
       cond {
	expr="locations ==  FULL";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat2.units.gp[0][1]";
	   };
	  };
	 };
	};
	FunctionCall @[1] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[1].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Unit;
	   type="Unit*";
	   name="unit";
	   required=1;
	   def_val=;
	   expr {
	    expr="Spat2.units.gp[1][1]";
	   };
	  };
	 };
	};
	If @[2] {
	 desc=;
	 flags=;
	 cond {
	  expr="n_units_per_loc ==  FULL";
	 };
	 true_code {
	  name=;
	  el_typ=ProgEl;
	  el_def=0;
	  FunctionCall @[0] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   fun=$.projects[0].programs[1].functions[0]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Unit;
	     type="Unit*";
	     name="unit";
	     required=1;
	     def_val=;
	     expr {
	      expr="Spat2.units.gp[0][0]";
	     };
	    };
	   };
	  };
	  FunctionCall @[1] {
	   desc=;
	   flags=;
	   result_var=NULL;
	   fun=$.projects[0].programs[1].functions[0]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=Unit;
	     type="Unit*";
	     name="unit";
	     required=1;
	     def_val=;
	     expr {
	      expr="Spat2.units.gp[1][0]";
	     };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[0][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][1]$$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=$.projects[0].programs.gp[0][1]$;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][1].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][1].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=OFF;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
     MethodCall @[5] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=Network::Init_Acts;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      method=taBase::UpdateAllViews;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MemberAssign @[7] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="epoch";
      expr {
       expr="0";
      };
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[6]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     IfElse @[3] {
      desc=;
      flags=OFF;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MemberAssign @[4] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="epoch";
      expr {
       expr="0";
      };
      update_after=0;
     };
     AssignExpr @[5] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[6] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=0;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[7] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraEpochGpData";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="item_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- if we want to reset it every epoch";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="group_index";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="prv_group_index";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[7] {
      name="item_index";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter: note also needs to do this in regular running program";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[2]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][2].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[2]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[0][2].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
      flags=OFF;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[3]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[4] {
      desc=;
      flags=NON_STD;
      result_var=.projects[0].programs.gp[0][2].vars[6]$$;
      expr {
       expr="-1";
      };
     };
     NetGroupedDataLoop @[5] {
      desc="iterates over groups and items within groups";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       If @[0] {
	desc="init activation at start of group";
	flags=NON_STD;
	cond {
	 expr="prv_group_index != group_index";
	};
	true_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][2].args[0]$;
	  method=Network::Init_Acts;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
       };
       AssignExpr @[1] {
	desc=;
	flags=NON_STD;
	result_var=$.projects[0].programs.gp[0][2].vars[6]$;
	expr {
	 expr="group_index";
	};
       };
       ProgramCall @[2] {
	desc="call the trial process";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[3] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][2].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[0].programs.gp[0][2].args[1]$$;
      group_index_var=.projects[0].programs.gp[0][2].vars[5]$$;
      item_index_var=.projects[0].programs.gp[0][2].vars[7]$$;
      group_order_var=.projects[0].programs.gp[0][2].vars[0]$$;
      item_order_var=.projects[0].programs.gp[0][2].vars[1]$$;
      group_order=SEQUENTIAL;
      item_order=SEQUENTIAL;
      group_col=0;
      update_after=0;
      group_idx_list{ 0;1;2;      };
      item_idx_list{ 2;      };
     };
     IfElse @[6] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[9] {
      desc="call the epoch monitor";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][4]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     ProgramCall @[5] {
      desc="group trial data for plotting purposes";
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      target=.projects[0].programs[0]$$;
      targ_ld_init="*GenGroupData*";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="cue_dur";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="duration to present Cue stimuli";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=1;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][4].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][4].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     IfElse @[5] {
      desc=;
      flags=NON_STD;
      cond {
       expr="network->trial_name == \"Cue\"";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MemberAssign @[0] {
	desc=;
	flags=;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	path="cycle_max";
	expr {
	 expr="cue_dur";
	};
	update_after=0;
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MemberAssign @[0] {
	desc=;
	flags=;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	path="cycle_max";
	expr {
	 expr="200";
	};
	update_after=0;
       };
      };
     };
     WhileLoop @[6] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][5]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
	counter=Network::cycle;
	update_after=1;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=OFF;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
       IfBreak @[4] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=NON_STD;
	cond {
	 expr="network.layers.Output.units[1].act_eq > network->trg_max_act_stopcrit";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[7] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[9] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[10] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][5].args[0]$;
      update_var=$.projects[0].programs.gp[0][5].vars[0]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="Group";
	net_target=GROUP_NAME;
	layer_name="Group";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][1]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][8].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$.projects[0].programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[2]$$;
      obj=.projects[0].programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0.002458512550219893;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=0.9975414872169495;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.8005836606025696;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAugAAAn8AAAMSAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="SimpleAttnNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=1;
	  net_text_xform {scale={x=0.7654127: y=0.765413: z=0.7654128: }: rotate={x=1: y=1.19209e-07: z=1.976145e-14: rot=1.48927: }: translate={x=0.05603385: y=-0.7853288: z=0.05294004: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[6].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=12: y=3: z=3.25: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.005;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;V1=0;Spat1=0;Spat2=0;Obj1=0;Obj2=0;Output=0;	  };
	 };
	 GraphTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[1][2]$;
FloatTransform @*(.m_transform) {scale={x=0.7886286: y=0.7886265: z=0.7886258: }: rotate={x=-0.98516: y=-0.1714355: z=0.01069289: rot=0.1264548: }: translate={x=1.135431: y=-0.2063672: z=0.05579768: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch_group";
	    m_data=.projects[0].data.gp[1][2].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="group_name_group";
	    m_data=.projects[0].data.gp[1][2].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="group_first";
	    m_data=.projects[0].data.gp[1][2].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="minus_cycles_last";
	    m_data=.projects[0].data.gp[1][2].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=0.7886286: y=0.7886265: z=0.7886258: }: rotate={x=-0.98516: y=-0.1714355: z=0.01069289: rot=0.1264548: }: translate={x=1.135431: y=-0.2063672: z=0.05579768: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=0;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="group_first";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.2: max=2.2: };
	   range {min=-0.2: max=2.2: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch_group";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=10: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=10: };
	   range {min=0: max=10: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="minus_cycles_last";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=200: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=200: };
	   range {min=0: max=200: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="group_name_group";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=-0.2: max=2.2: };
	   range {min=-0.2: max=2.2: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=COLOR_AXIS;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="batch_group";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=9: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=9: };
	   range {min=0: max=9: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	 GridTableView @[2] {
	  name=;
	  m_data=$.projects[0].data.gp[1][3]$;
FloatTransform @*(.m_transform) {scale={x=0.5175549: y=0.5175549: z=0.5175549: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.088289: y=0.7511764: z=-4.487047e-06: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="group_name_group_group";
	    m_data=.projects[0].data.gp[1][3].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="group_first_first";
	    m_data=.projects[0].data.gp[1][3].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="batch_group_last";
	    m_data=.projects[0].data.gp[1][3].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="minus_cycles_last_mean";
	    m_data=.projects[0].data.gp[1][3].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.5175549: y=0.5175549: z=0.5175549: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.088289: y=0.7511764: z=-4.487047e-06: }: };
	  view_rows=3;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=1.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.08: max=0.1: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.9769006: y=0.3712146: z=2.488404: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.919956;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.5169005: y=0.7831941: z=1.480162: };
	 orient {x=-1.000012: y=0: z=0: rot=0.175998: };
	 focal_dist=1.941709;
	};
	T3SavedView @[2] {
	 name="Graph";
	 view_saved=1;
	 pos {x=1.5009: y=0.3533558: z=1.183174: };
	 orient {x=-0.9999971: y=0: z=0: rot=0.1440004: };
	 focal_dist=1.631613;
	};
	T3SavedView @[3] {
	 name="Batch";
	 view_saved=1;
	 pos {x=1.5009: y=1.119803: z=1.144882: };
	 orient {x=-0.9999971: y=0: z=0: rot=0.1440004: };
	 focal_dist=1.592921;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="InputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=0.4281528: y=0.4281528: z=0.4281528: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.7053722: y=1.728033: z=-4.78498e-09: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.4281528: y=0.4281528: z=0.4281528: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.7053722: y=1.728033: z=-4.78498e-09: }: };
	  view_rows=3;
	  view_range {min=0: max=2: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=3;
	  col_range {min=0: max=2: };
	  width=2;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.07: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=.projects[0].data.gp[0][1]$$;
FloatTransform @*(.m_transform) {scale={x=0.5657248: y=0.5657248: z=0.5657248: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.687449: y=1.576509: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.projects[0].data.gp[0][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][1].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.5657248: y=0.5657248: z=0.5657248: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.687449: y=1.576509: z=0: }: };
	  view_rows=5;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=3;
	  col_range {min=0: max=2: };
	  width=1.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.07: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[2] {
	  name=;
	  m_data=.projects[0].data.gp[0][2]$$;
FloatTransform @*(.m_transform) {scale={x=0.5698257: y=0.5698257: z=0.5698257: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.688108: y=0.8997712: z=-7.212613e-09: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.projects[0].data.gp[0][2].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][2].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][2].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][2].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.5698257: y=0.5698257: z=0.5698257: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1.688108: y=0.8997712: z=-7.212613e-09: }: };
	  view_rows=5;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=3;
	  col_range {min=0: max=2: };
	  width=1.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.07: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[3] {
	  name=;
	  m_data=.projects[0].data.gp[0][4]$$;
FloatTransform @*(.m_transform) {scale={x=0.565159: y=0.5651588: z=0.565159: }: rotate={x=0: y=1.006174: z=0: rot=0.00687073: }: translate={x=0.7096565: y=0.891903: z=0.00223984: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.projects[0].data.gp[0][4].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][4].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=6;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][4].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][4].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.565159: y=0.5651588: z=0.565159: }: rotate={x=0: y=1.006174: z=0: rot=0.00687073: }: translate={x=0.7096565: y=0.891903: z=0.00223984: }: };
	  view_rows=5;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=3;
	  col_range {min=1: max=3: };
	  width=1.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.07: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.661183: y=1.527084: z=2.413309: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.419871;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="BatchOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name="T3DataViewRoot_0";
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataViewMain;
	 el_def=0;
	 GraphTableView @[0] {
	  name="GraphTableView_1";
	  m_data=$.projects[0].data.gp[1][2]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch_group";
	    m_data=$.projects[0].data.gp[1][2].data[0]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="group_name_group";
	    m_data=$.projects[0].data.gp[1][2].data[1]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="group_first";
	    m_data=$.projects[0].data.gp[1][2].data[2]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="minus_cycles_last";
	    m_data=$.projects[0].data.gp[1][2].data[3]$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=0;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name="GraphAxisView_4";
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="group_first";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.2: max=2.2: };
	   range {min=-0.2: max=2.2: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name="GraphAxisView_5";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch_group";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=10: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name="GraphPlotView_16";
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="minus_cycles_last";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=200: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=200: };
	   range {min=0: max=200: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name="GraphPlotView_17";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name="GraphPlotView_18";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name="GraphPlotView_19";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name="GraphPlotView_20";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="group_name_group";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name="GraphPlotView_21";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name="GraphPlotView_22";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name="GraphPlotView_23";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name="GraphPlotView_24";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name="GraphPlotView_25";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name="GraphPlotView_26";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name="GraphPlotView_27";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name="GraphPlotView_28";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name="GraphPlotView_29";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name="GraphPlotView_30";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name="GraphPlotView_31";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=COLOR_AXIS;
	  color_axis {
	   name="GraphAxisView_6";
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="batch_group";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=9: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=9: };
	   range {min=0: max=9: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale_0";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="GraphAxisView_7";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	 GridTableView @[1] {
	  name="GridTableView_5";
	  m_data=$.projects[0].data.gp[1][3]$;
FloatTransform @*(.m_transform) {scale={x=0.6281885: y=0.6281885: z=0.6281885: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.01171571: y=1.249547: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="group_name_group_group";
	    m_data=$.projects[0].data.gp[1][3].data[0]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="group_first_first";
	    m_data=$.projects[0].data.gp[1][3].data[1]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="batch_group_last";
	    m_data=$.projects[0].data.gp[1][3].data[2]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="minus_cycles_last_mean";
	    m_data=$.projects[0].data.gp[1][3].data[3]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.6281885: y=0.6281885: z=0.6281885: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.01171571: y=1.249547: z=0: }: };
	  view_rows=3;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=0;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=1.5;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale_0";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.08: max=0.1: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.4461805: y=0.8377771: z=2.749921: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.749921;
	};
	T3SavedView @[1] {
	 name="View_1";
	 view_saved=1;
	 pos {x=0.4461805: y=0.8377771: z=2.749921: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.749921;
	};
	T3SavedView @[2] {
	 name="View_2";
	 view_saved=1;
	 pos {x=0.4461805: y=0.8377771: z=2.749921: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.749921;
	};
	T3SavedView @[3] {
	 name="View_3";
	 view_saved=1;
	 pos {x=0.4461805: y=0.8377771: z=2.749921: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.749921;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7295719981193542;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="SimpleAttnNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="UnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
      LeabraUnitSpec @[0] {
       name="SpatialUnits";
       desc=;
       unique{ acc;       };
       children {
	name=;
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       act_range {min=0: max=1: range=1: scale=1: };
       bias_con_type=LeabraCon;
       bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[3]$$: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {gelin=0: thr=0.25: gain=100: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
       spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
       spike_misc {
	exp_slope=0.02;
	spk_thr=1.2;
	clamp_max_p=0.11;
	clamp_type=REGULAR;
	vm_r=0.3;
	vm_dend=0.3;
	vm_dend_dt=0.16;
	vm_dend_time=6.25;
       };
       opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
       maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=1: range=1: scale=1: };
       v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
       dt {integ=1: vm=0.07: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=14.28571: net_time=1.428571: };
       act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
       g_bar {e=1: l=0.1: i=1: h=0.1: a=1.5: };
       e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
       hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       adapt {
	on=0;
	dt=0.007;
	vm_gain=0.04;
	spike_gain=0.00805;
	interval=10;
	dt_time=142.8571;
       };
       depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
       syn_delay {
	on=0;
	delay=4;
       };
       da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
       noise_type=VM_NOISE;
       noise {name="": type=GAUSSIAN: mean=0: var=0.0008: par=1: };
       noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
       noise_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=1;
	cur_val=0;
       };
      };
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[3]$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=100: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.07: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=14.28571: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.1: i=1: h=0.1: a=1.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.02: b_dec_dt=0.02: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=VM_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.0008: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="ConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @[0] {
       name="FmInput";
       desc=;
       unique{ rnd;wt_scale;lrate;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1.65: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[1] {
       name="V1_Spatial";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=2: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[2] {
       name="TopDown";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.5: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[3] {
       name="SpatialSelf";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[4] {
       name="Spat_Obj";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=2: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
      LeabraConSpec @[5] {
       name="Obj_Spat";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.5: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0;
       cur_lrate=0;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.01: err=0.99: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=1: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="Object";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Spatial";
       desc=;
       unique{ kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_AVG_INHIB;
	kwta_pt=0.6;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=4: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=0: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[1] {
       name="Input";
       desc=;
       unique{ kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_AVG_INHIB;
	kwta_pt=0.6;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=0: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[2] {
       name="V1";
       desc=;
       unique{ kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_AVG_INHIB;
	kwta_pt=0.6;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=2: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=0: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_AVG_INHIB;
      kwta_pt=0.6;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=0: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    LeabraBiasSpec @[3] {
     name="BiasSpec_0";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=0.02: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
    BaseSpec_Group @.gp[0] {
     name="LeabraPrjns";
     el_typ=LeabraUnitSpec;
     el_def=0;
     FullPrjnSpec @[0] {
      name="FullPrjnSpec_0";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=FullPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
     TesselPrjnSpec @[1] {
      name="Spat_Obj";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=0;
      send_scale {x=1: y=0: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
       TessEl @[1] {
	send_off {x=0: y=1: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     TesselPrjnSpec @[2] {
      name="SpatialPath";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=1: y=0: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
       TessEl @[1] {
	send_off {x=1: y=0: };
	wt_val=1;
       };
       TessEl @[2] {
	send_off {x=2: y=0: };
	wt_val=1;
       };
       TessEl @[3] {
	send_off {x=0: y=1: };
	wt_val=1;
       };
       TessEl @[4] {
	send_off {x=1: y=1: };
	wt_val=1;
       };
       TessEl @[5] {
	send_off {x=2: y=1: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     OneToOnePrjnSpec @[3] {
      name="OneToOnePrjn";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     SymmetricPrjnSpec @[4] {
      name="SymmetricPrjn";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=SymmetricPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
     TesselPrjnSpec @[5] {
      name="SpatialSelf";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=0;
      send_scale {x=1: y=0: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=0.5;
       };
       TessEl @[1] {
	send_off {x=0: y=1: };
	wt_val=0.5;
       };
       TessEl @[2] {
	send_off {x=0: y=2: };
	wt_val=0;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     TesselPrjnSpec @[6] {
      name="Input_V1";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=1: y=1: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     TesselPrjnSpec @[7] {
      name="ObjPathway";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=1: y=1: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
       TessEl @[1] {
	send_off {x=1: y=0: };
	wt_val=1;
       };
       TessEl @[2] {
	send_off {x=2: y=0: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=12: y=3: z=4: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=2: y=0: z=0: };
     disp_scale=1;
     un_geom {x=7: y=2: n_not_xy=0: n=14: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=7: y=2: n_not_xy=0: n=14: };
     scaled_act_geom {x=7: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=2: n_not_xy=0: n=14: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[1].projections[2]$$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3467482;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.1500001;
       avg_l=0.3476745;
       l_thr=1.043023;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[2] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[3] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[4] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[5] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[6] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[7] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[8] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3518514;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[9] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[10] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[11] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[12] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {12; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.243019;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[13] {
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {13; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.03685985;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.1264286: max=0.95: max_i=8: };
     acts_m {cmpt=1: avg=0.1264286: max=0.95: max_i=8: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.07142857: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[1]$$: };
     hard_clamped=0;
     avg_l_avg=2.920508e-11;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="V1";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=2: y=0: z=1: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=7: y=1: n_not_xy=0: n=7: };
     gp_spc {x=0: y=0: };
     act_geom {x=7: y=2: n_not_xy=0: n=1: };
     scaled_act_geom {x=7: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Spat1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=SymmetricPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][4]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1].children[2]$$: };
       recv_idx=0;
       send_idx=3;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Obj1";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[4]$$;
       spec {type=SymmetricPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[2]$: };
       recv_idx=1;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][6]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=2: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[1].projections[0]$$;
	  other_idx=3;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[1].projections[1]$$;
	  other_idx=2;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[4].projections[0]$$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[0]$$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {7; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=1: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.4106715: max=0.8201888: max_i=1: };
       acts_m {cmpt=1: avg=0.4106715: max=0.8201888: max_i=1: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 4;
	  units = {0; 1; 2; 3; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {0; 2; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2657187;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.3155853;
	l_thr=0.9467558;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 4;
	  units = {0; 1; 2; 3; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {1; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {8; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2748882;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=2: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {0; 1; 2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {0; 2; 4; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {2; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {0; 1; 2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {9; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[3] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=3: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {2; 3; 4; 5; 6; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {2; 4; 6; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {3; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {6; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {2; 3; 4; 5; 6; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {10; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {7; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[4] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=4: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {4; 5; 6; 7; 8; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {4; 6; 8; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {4; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {8; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 6;
	  units = {4; 5; 6; 7; 8; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {11; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {9; };
	 wt = {0; };
	};
	n_recv_cons=10;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[5] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=5: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 4;
	  units = {6; 7; 8; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {6; 8; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {5; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {10; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 4;
	  units = {6; 7; 8; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {7; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {12; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {11; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2140021;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[6] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=6: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 1;
	  units = {8; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {6; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {12; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=3;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=2;
	 };
	 { con_alloc = 1;
	  units = {9; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {13; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {13; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03685985;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.05866735: max=0.8201888: max_i=1: };
     acts_m {cmpt=1: avg=0.05866735: max=0.8201888: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.07142857: pct_c=0.9285714: adth_k=1: k_ithr=3.838925: k1_ithr=0.4464084: ithr_r=2.151713: ithr_diff=0.8837152: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.07142857: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2].children[1]$: };
     hard_clamped=0;
     avg_l_avg=2.368173e+21;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Spat1";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=1: z=2: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=5: y=1: n_not_xy=0: n=5: };
     gp_spc {x=0: y=0: };
     act_geom {x=5: y=2: n_not_xy=0: n=1: };
     scaled_act_geom {x=5: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_V1";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[1]$$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][2]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Obj1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][1]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1].children[5]$$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Spat1";
       from_type=SELF;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][5]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1].children[3]$$: };
       recv_idx=2;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[3] {
       name="Fm_Spat2";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=SymmetricPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[2]$: };
       recv_idx=3;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[2];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
	    Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers[4].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=3: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.8224822: max=0.837324: max_i=0: };
       acts_m {cmpt=1: avg=0.8224822: max=0.837324: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {0; 2; 4; 1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[1]$$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[2]$$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {1; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[3]$$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[4].projections[1]$$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[3].projections[0]$$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=11;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3126375;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.3104305;
	l_thr=0.9312915;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {0; 2; 4; 1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {0; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=11;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3062472;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.3111369;
	l_thr=0.9334106;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=1: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.8278403: max=0.8361422: max_i=0: };
       acts_m {cmpt=1: avg=0.8278403: max=0.8361422: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {2; 4; 6; 3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {3; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 4;
	  units = {0; 1; 2; 3; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=13;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3091028;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.3112259;
	l_thr=0.9336776;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {2; 4; 6; 3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {2; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 4;
	  units = {0; 1; 2; 3; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=13;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3179455;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.3103311;
	l_thr=0.9309934;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=2: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {4; 6; 8; 5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {5; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 6;
	  units = {0; 1; 2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	n_recv_cons=15;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.05761489;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {4; 6; 8; 5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {4; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 6;
	  units = {0; 1; 2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	n_recv_cons=15;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.06346021;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[3] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=3: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {6; 8; 10; 7; 9; 11; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {6; 7; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {7; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 4;
	  units = {2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {6; };
	 wt = {0; };
	};
	n_recv_cons=13;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2416825;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {6; 8; 10; 7; 9; 11; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {6; 7; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {6; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 4;
	  units = {2; 3; 4; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {7; };
	 wt = {0; };
	};
	n_recv_cons=13;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2427228;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[4] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=4: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {8; 10; 12; 9; 11; 13; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {9; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {8; };
	 wt = {0; };
	};
	n_recv_cons=11;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2330732;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {8; 10; 12; 9; 11; 13; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 3;
	  units = {8; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {9; };
	 wt = {0; };
	};
	n_recv_cons=11;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2384149;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0].children[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.3300645: max=0.837324: max_i=0: };
     acts_m {cmpt=1: avg=0.3300645: max=0.837324: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=4: pct=0.4: pct_c=0.6: adth_k=2: k_ithr=2.215789: k1_ithr=-0.03239989: ithr_r=0: ithr_diff=1.014622: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.4: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[0]$$: };
     hard_clamped=0;
     avg_l_avg=3.789422e+22;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[3] {
     name="Spat2";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=1: z=3: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=3: y=1: n_not_xy=0: n=3: };
     gp_spc {x=0: y=0: };
     act_geom {x=3: y=2: n_not_xy=0: n=1: };
     scaled_act_geom {x=3: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Spat1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][2]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs[1]$$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Spat2";
       from_type=SELF;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][5]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[3]$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Obj2";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[5]$$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[5]$: };
       recv_idx=2;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[3];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[3].projections[1];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[5].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=2: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.8756199: max=0.8783025: max_i=0: };
       acts_m {cmpt=1: avg=0.8756199: max=0.8783025: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {0; 2; 4; 1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[3].projections[1]$$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {1; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[3].projections[2]$$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[5].projections[1]$$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3311066;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.2455196;
	l_thr=0.7365588;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {0; 2; 4; 1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {0; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.3320018;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.2440799;
	l_thr=0.7322398;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=1: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {2; 4; 6; 3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {3; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2166747;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.1196393;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {2; 4; 6; 3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {2; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2443065;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.1222004;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=2: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=2: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {4; 6; 8; 5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {5; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2524383;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=1;
	 };
	 { con_alloc = 6;
	  units = {4; 6; 8; 5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; 0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {4; };
	  wt = {0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=3;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	n_recv_cons=9;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2522247;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0].children[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2918733: max=0.8783025: max_i=0: };
     acts_m {cmpt=1: avg=0.2918733: max=0.8783025: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=4: pct=0.6666667: pct_c=0.3333333: adth_k=2: k_ithr=1.286544: k1_ithr=-0.1: ithr_r=0: ithr_diff=1.077728: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.6666667: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2].children[0]$: };
     hard_clamped=0;
     avg_l_avg=8.908108e-39;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[4] {
     name="Obj1";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=7: y=1: z=2: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=5: y=1: n_not_xy=0: n=5: };
     gp_spc {x=0: y=0: };
     act_geom {x=5: y=2: n_not_xy=0: n=1: };
     scaled_act_geom {x=5: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_V1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[1]$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][7]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Spat1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[4]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Obj2";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[5]$;
       spec {type=SymmetricPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[2]$: };
       recv_idx=2;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[5].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=2: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.4103337: max=0.8206674: max_i=1: };
       acts_m {cmpt=1: avg=0.4103337: max=0.8206674: max_i=1: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {0; 2; 4; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[4].projections[2]$$;
	  other_idx=1;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[5].projections[0]$$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2427504;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.2681168;
	l_thr=0.8043505;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2358549;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.1129374;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=1: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.3990421: max=0.7980842: max_i=1: };
       acts_m {cmpt=1: avg=0.3990421: max=0.7980842: max_i=1: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {2; 4; 6; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {0; 2; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2467607;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.1500001;
	avg_l=0.2691128;
	l_thr=0.8073383;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {1; 3; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2435884;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=2: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {4; 6; 8; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {0; 2; 4; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	n_recv_cons=8;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03912396;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 3;
	  units = {1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	n_recv_cons=8;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03925055;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[3] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=3: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {6; 8; 10; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {6; 7; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {2; 4; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {6; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03914918;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {7; 9; 11; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {6; 7; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 2;
	  units = {3; 5; };
	  wt = {0.5; 0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {7; };
	 wt = {0; };
	};
	n_recv_cons=7;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.1995341;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[4] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=4: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {8; 10; 12; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 1;
	  units = {4; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {8; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.03686643;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {9; 11; 13; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {8; 9; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=1;
	 };
	 { con_alloc = 1;
	  units = {5; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=1;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	  other_idx=1;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {9; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2024087;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.1618752: max=0.8206674: max_i=0: };
     acts_m {cmpt=1: avg=0.1618752: max=0.8206674: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.1: pct_c=0.9: adth_k=1: k_ithr=2.090481: k1_ithr=0.3863155: ithr_r=1.688495: ithr_diff=0.8152025: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2]$$: };
     hard_clamped=0;
     avg_l_avg=6.627972e-10;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[5] {
     name="Obj2";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=8: y=1: z=3: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=3: y=1: n_not_xy=0: n=3: };
     gp_spc {x=0: y=0: };
     act_geom {x=3: y=2: n_not_xy=0: n=1: };
     scaled_act_geom {x=3: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Obj1";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][7]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Spat2";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[4]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_Output";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[6]$$;
       spec {type=SymmetricPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][4]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[2]$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[2];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[2];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[6].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=2: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.4014757: max=0.8029515: max_i=1: };
       acts_m {cmpt=1: avg=0.4014757: max=0.8029515: max_i=1: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {0; 2; 4; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[5].projections[2]$$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[6].projections[0]$$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2525707;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.2060646;
	l_thr=0.6181937;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {1; 3; 5; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.2263812;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=1: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {2; 4; 6; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.07383105;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.1129367;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {3; 5; 7; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {2; 3; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.05917252;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[2] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=2: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=2: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name=;
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0: max=0: max_i=0: };
       acts_m {cmpt=1: avg=0: max=0: max_i=0: };
       phase_dif_ratio=1;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {4; 6; 8; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.04306597;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name=;
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 3;
	  units = {5; 7; 9; };
	  wt = {0.5; 0.5; 0.5; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {4; 5; };
	  wt = {0.5; 0.5; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.5; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[2]$;
	  other_idx=2;
	 };
	 LeabraSendCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[2]$;
	  other_idx=2;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	n_recv_cons=6;
	pos {x=0: y=1: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.200362;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.112936;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.1338252: max=0.8029515: max_i=0: };
     acts_m {cmpt=1: avg=0.1338252: max=0.8029515: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.1666667: pct_c=0.8333333: adth_k=1: k_ithr=2.737123: k1_ithr=0.3296426: ithr_r=2.116654: ithr_diff=0.8795661: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1666667: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=7.038776e+28;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[6] {
     name="Output";
     desc=;
     flags=;
     layer_type=TARGET;
     pos {x=5: y=1: z=3: };
     disp_scale=1;
     un_geom {x=1: y=2: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=1: y=2: n_not_xy=0: n=2: };
     scaled_act_geom {x=1: y=2: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Obj2";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[5]$;
       spec {type=TesselPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][7]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=2: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {0; 2; 4; };
	 wt = {0.5; 0.5; 0.5; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=3;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.2702841;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.1700094;
       l_thr=0.5100282;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[6].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {1; 3; 5; };
	 wt = {0.5; 0.5; 0.5; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[5].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=3;
       pos {x=0: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.3336999;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.112936;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.3021199: max=0.6042398: max_i=1: };
     acts_m {cmpt=1: avg=0.3021199: max=0.6042398: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=2.878065: k1_ithr=-0.1: ithr_r=0: ithr_diff=1.034746: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=1.019389e-38;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
    NetViewObj @[0] {
     name="CueText";
     desc=;
     pos {x=0.01904457: y=0.3836414: z=-0.1084131: };
     rot {x=0: y=0: z=1: rot=0: };
     scale {x=1: y=1: z=1: };
     obj_type=TEXT;
     obj_fname=;
     text="Cue";
     font_size=0.05;
     set_color=1;
     color {r=0: g=0: b=0: a=1: };
    };
    NetViewObj @[1] {
     name="TargText";
     desc=;
     pos {x=-0.03346384: y=0.3712413: z=-0.4809728: };
     rot {x=6.460368e-07: y=1: z=1.756127e-08: rot=0.02302713: };
     scale {x=1: y=1: z=1: };
     obj_type=TEXT;
     obj_fname=;
     text="Target";
     font_size=0.05;
     set_color=1;
     color {r=0: g=0: b=0: a=1: };
    };
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=2;
   trial=0;
   tick=0;
   cycle=0;
   time=27589;
   group_name="Diff_Obj_Same_Loc";
   trial_name="Diff_Obj_Same_Loc";
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=1;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="train_time": start={usr=22583: sys=2771: tot=128799079268: }: end={usr=22603: sys=2771: tot=128799079288: }: used={usr=20: sys=0: tot=20: }: s_used=0.2: n_used=1: };
   epoch_time {name="epoch_time": start={usr=22583: sys=2771: tot=128799079268: }: end={usr=22600: sys=2771: tot=128799079286: }: used={usr=17: sys=0: tot=18: }: s_used=0.18: n_used=1: };
   trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=6.169293311314099e-71;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=62;
   n_cons=394;
   max_size {x=12: y=3: z=4: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=53;
   time_inc=1;
   cycle_max=200;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=23;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=53;
   avg_cycles=62.33333;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0.06451613;
   send_pct_n=4;
   send_pct_tot=62;
   avg_send_pct=0.05951358;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=-1;
   maxda=0.1497723;
   trg_max_act_stopcrit=0.6;
   trg_max_act=0.6042398;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
