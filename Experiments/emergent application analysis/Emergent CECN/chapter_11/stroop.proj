// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [3] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [1] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [5] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem @[4] { };
      };

      EditMthItem_Group @.mths = [10] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
	EditMthItem @[5] { };
	EditMthItem @[6] { };
	EditMthItem @[7] { };
	EditMthItem @[8] { };
	EditMthItem @[9] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [4] { 
      DataTable @[0] { 
	DataTableCols @.data = [6] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	};
      };
      DataTable @[1] { 
    UserDataItem_List @*(.user_data_) {
	  UserDataItem @[0] { };
    };

	DataTableCols @.data = [5] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	};
      };
      DataTable @[2] { 
    UserDataItem_List @*(.user_data_) {
	  UserDataItem @[0] { };
    };

	DataTableCols @.data = [9] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[6] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[7] { };
	  int_Data @[8] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[3] { 
    UserDataItem_List @*(.user_data_) {
	  UserDataItem @[0] { };
	  UserDataItem @[1] { };
	  UserDataItem @[2] { };
    };

	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  String_Data @[1] { };
	  String_Data @[2] { };
	  String_Data @[3] { };
	};
      };
      DataTable_Group @.gp[0] = [14] { 
	DataTable @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };

	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[1] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };

	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[2] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[3] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[4] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[5] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[6] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[7] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[8] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[9] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[10] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[11] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[12] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
	DataTable @[13] { 
	  DataTableCols @.data = [5] {
	    String_Data @[0] { };
	    float_Data @[1] { };
	    float_Data @[2] { };
	    float_Data @[3] { };
	    float_Data @[4] { };
	  };
	};
      };
    };
    DataTable_Group @.gp[1] = [4] { 
      DataTable @[0] { 
	DataTableCols @.data = [13] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  int_Data @[9] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[10] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[11] { };
	  String_Data @[12] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [12] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  int_Data @[9] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[10] { };
	  int_Data @[11] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[2] { 
	DataTableCols @.data = [19] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  int_Data @[8] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[9] { };
	  int_Data @[10] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[11] { };
	  float_Data @[12] { };
	  float_Data @[13] { };
	  float_Data @[14] { };
	  float_Data @[15] { };
	  float_Data @[16] { };
	  float_Data @[17] { };
	  float_Data @[18] { };
	};
      };
      DataTable @[3] { 
	DataTableCols @.data = [8] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	};
      };
    };
    DataTable_Group @.gp[2] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [12] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  int_Data @[9] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[10] { };
	  int_Data @[11] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [0] {
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [13] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	  ProgVar @[10] { };
	  ProgVar @[11] { };
	  ProgVar @[12] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [16] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	  ForLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      MemberAssign @[0] { };
	      AssignExpr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      PrintExpr @[3] { };
	    };
	  };
	  Comment @[6] { };
	  MemberAssign @[7] { };
	  MemberAssign @[8] { };
	  MemberAssign @[9] { };
	  Comment @[10] { };
	  AssignExpr @[11] { };
	  MemberAssign @[12] { };
	  MemberAssign @[13] { };
	  MethodCall @[14] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  PrintExpr @[15] { };
	};

	ProgEl_List @.prog_code = [7] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  AssignExpr @[4] { };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[4] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[7] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [6] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[5] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [5] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      PrintExpr @[1] { };
	      NetCounterIncr @[2] { };
	      IfContinue @[3] { };
	      IfBreak @[4] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [5] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	      LayerWriterEl @[4] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [13] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  Comment @[2] { };
	  AssignExpr @[3] { };
	  AssignExpr @[4] { };
	  AssignExpr @[5] { };
	  DataVarProg @[6] { };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[1] = [11] { 
      Program @[0] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [3] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	  DynEnumType @[1] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	  DynEnumType @[2] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [11] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	  ProgVar @[10] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [12] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  ForLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      AssignExpr @[0] { };
	      MethodCall @[1] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };
	  };
	  Comment @[2] { };
	  MemberAssign @[3] { };
	  MemberAssign @[4] { };
	  MemberAssign @[5] { };
	  Comment @[6] { };
	  AssignExpr @[7] { };
	  MemberAssign @[8] { };
	  MemberAssign @[9] { };
	  MethodCall @[10] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  PrintExpr @[11] { };
	};

	ProgEl_List @.prog_code = [3] {
	  MemberAssign @[0] { };
	  ProgramCall @[1] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [0] {
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [10] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetGroupedDataLoop @[4] { 
	    ProgEl_List @.loop_code = [6] {
	      IfElse @[0] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	      DataVarProg @[1] { };
	      OtherProgramVar @[2] { };
	      MemberAssign @[3] { };
	      ProgramCall @[4] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[5] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [14] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	  ProgVar @[10] { };
	  ProgVar @[11] { };
	  ProgVar @[12] { };
	  ProgVar @[13] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [13] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  IfElse @[1] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  ForLoop @[2] { 
	    ProgEl_List @.loop_code = [4] {
	      MemberAssign @[0] { };
	      AssignExpr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      PrintExpr @[3] { };
	    };
	  };
	  Comment @[3] { };
	  MemberAssign @[4] { };
	  MemberAssign @[5] { };
	  MemberAssign @[6] { };
	  Comment @[7] { };
	  AssignExpr @[8] { };
	  MemberAssign @[9] { };
	  MemberAssign @[10] { };
	  MethodCall @[11] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  PrintExpr @[12] { };
	};

	ProgEl_List @.prog_code = [4] {
	  AssignExpr @[0] { };
	  MemberAssign @[1] { };
	  AssignExpr @[2] { };
	  WhileLoop @[3] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      VarIncr @[1] { };
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [8] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[4] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[2] { 
	    ProgEl_List @.true_code = [1] {
	      ResetDataRows @[0] { };
	    };
	  };
	  WhileLoop @[3] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  If @[1] { 
	    ProgEl_List @.true_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	    };
	  };
	  NetUpdateView @[2] { };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [5] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	      LayerWriterEl @[4] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [12] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [5] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  DataVarProg @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [19] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	      NetMonItem @[13] { };
	      NetMonItem @[14] { };
	      NetMonItem @[15] { };
	      NetMonItem @[16] { };
	      NetMonItem @[17] { };
	      NetMonItem @[18] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [13] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  Comment @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[9] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[10] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[11] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[12] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[10] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
    };
    Program_Group @.gp[2] = [3] { 
      Program @[0] { 
	ProgObjList @.objs = [1] {
	  DataTable @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };

	    DataTableCols @.data = [6] {
	      String_Data @[0] { };
	      float_Data @[1] { };
	      float_Data @[2] { };
	      float_Data @[3] { };
	      float_Data @[4] { };
	      float_Data @[5] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  InitNamedUnits @[0] { };
	};

	ProgEl_List @.prog_code = [14] {
	  Comment @[0] { };
	  AssignExpr @[1] { };
	  AssignExpr @[2] { };
	  DataVarProg @[3] { };
	  AssignExpr @[4] { };
	  DataVarProg @[5] { };
	  Comment @[6] { };
	  AssignExpr @[7] { };
	  AssignExpr @[8] { };
	  DataVarProg @[9] { };
	  AssignExpr @[10] { };
	  DataVarProg @[11] { };
	  Comment @[12] { };
	  DataGenCall @[13] { 
	    ProgArg_List @.meth_args = [5] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	      ProgArg @[4] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [4] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	  DynEnumType @[1] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	  DynEnumType @[2] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	  DynEnumType @[3] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	ProgVar_List @.vars = [17] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	  ProgVar @[8] { };
	  ProgVar @[9] { };
	  ProgVar @[10] { };
	  ProgVar @[11] { };
	  ProgVar @[12] { };
	  ProgVar @[13] { };
	  ProgVar @[14] { };
	  ProgVar @[15] { };
	  ProgVar @[16] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  InitNamedUnits @[0] { };
	};

	ProgEl_List @.prog_code = [8] {
	  IfElse @[0] { 
	    ProgEl_List @.true_code = [1] {
	      ResetDataRows @[0] { };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  Comment @[1] { };
	  AssignExpr @[2] { };
	  AssignExpr @[3] { };
	  AssignExpr @[4] { };
	  AssignExpr @[5] { };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      IfElse @[0] { 
		ProgEl_List @.true_code = [1] {
		  AssignExpr @[0] { };
		};

		ProgEl_List @.false_code = [1] {
		  AssignExpr @[0] { };
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  ForLoop @[7] { 
	    ProgEl_List @.loop_code = [7] {
	      AssignExpr @[0] { };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  AssignExpr @[0] { };
		};

		ProgEl_List @.false_code = [7] {
		  AddNewDataRow @[0] { };
		  IfElse @[1] { 
		    ProgEl_List @.true_code = [2] {
		      SetUnitsVar @[0] { };
		      AssignExpr @[1] { };
		    };

		    ProgEl_List @.false_code = [2] {
		      SetUnitsVar @[0] { };
		      AssignExpr @[1] { };
		    };
		  };
		  AssignExpr @[2] { };
		  AssignExpr @[3] { };
		  DataVarProg @[4] { };
		  DataVarProg @[5] { };
		  AssignExpr @[6] { };
		};
	      };
	      AddNewDataRow @[2] { };
	      SetUnitsVar @[3] { };
	      AssignExpr @[4] { };
	      DataVarProg @[5] { };
	      DataVarProg @[6] { };
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [0] {
	};

	ProgVar_List @.vars = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [5] {
	  OtherProgramVar @[0] { };
	  ProgramCall @[1] { 
	    ProgArg_List @.prog_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  ProgramCall @[3] { 
	    ProgArg_List @.prog_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[3] = [1] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [0] {
	};

	ProgVar_List @.vars = [4] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [1] {
	  DataSelectRowsProg @[0] { 
	    DataOpList @.ops = [1] {
	      DataSelectEl @[0] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [6] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [1] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [10] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		    ScaleRange @[4] { };
		    ScaleRange @[5] { };
		    ScaleRange @[6] { };
		    ScaleRange @[7] { };
		    ScaleRange @[8] { };
		    ScaleRange @[9] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [8] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [13] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		    GraphColView @[12] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[3] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [12] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[4] { 
	      T3DataView_List @.children = [2] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [6] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		    GridColView @[5] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[5] { 
	      T3DataView_List @.children = [2] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [5] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [3] {
	LeabraUnitSpec @[0] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraUnitSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.noise_sched = [0] {
	      };
	    };
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @[1] { 
	  BaseSpec_Group @.children = [2] {
	    LeabraBiasSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	    LeabraConSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @[2] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	BaseSpec_Group @.gp[0] = [5] { 
	  FullPrjnSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TesselPrjnSpec @[3] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [2] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	    };
	  };
	  TesselPrjnSpec @[4] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [1] {
	      TessEl @[0] { };
	    };
	  };
	};
      };

      Layer_Group @.layers = [5] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [4] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	    LeabraPrjn @[3] { };
	  };

	  Unit_Group @.units = [0] {
	    LeabraUnit_Group @.gp[0] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [1]		  };
		  LeabraRecvCons @[1] { 
	   [0]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [1]		  };
		  LeabraRecvCons @[1] { 
	   [0]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	    };
	    LeabraUnit_Group @.gp[1] = [2] { 
	      LeabraUnit @[0] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [0]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	      LeabraUnit @[1] { 
	UserDataItem_List @*(.user_data_) {
	};

		RecvCons_List @.recv = [4] {
		  LeabraRecvCons @[0] { 
	   [0]		  };
		  LeabraRecvCons @[1] { 
	   [1]		  };
		  LeabraRecvCons @[2] { 
	   [1]		  };
		  LeabraRecvCons @[3] { 
	   [2]		  };
		};

		SendCons_List @.send = [2] {
		  LeabraSendCons @[0] { 
	   [1]		  };
		  LeabraSendCons @[1] { 
	   [2]		  };
		};
	      };
	    };
	  };
	};
	LeabraLayer @[3] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [4]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [4]		};
	      };
	    };
	    LeabraUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [4]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [4]		};
	      };
	    };
	  };
	};
	LeabraLayer @[4] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [2]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [2]		};
	      };
	    };
	    LeabraUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [2]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [2]		};
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ImportLog";
   desc=;
   auto_open=0;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>

<li>Sun Sep 23 18:38:18 2007 jrr <code>stroop.proj</code><br>
== Issues with Training ==
<li> added MakeTrainEnv to perform the same functionality as the FreqEnv in v3 (also makes it easy for students to view frequency of each trial type).
<li> added StimFrequencies DataLegend in order to view events as described in the text.
<li> on ConSpec_0 had to assign norm_con_n=true in order for training to work. Equivalent to fix_savg.dig_gp_n=true in the v3 code (wasn't appropriately set with the conversion). If norm_con_n = false, then no weights change. 
* Weights from input layers to hidden layer end up being around 0.36 and 0.40 for color naming and word reading, respectively for v4 (for v3, they end up around 0.362 and 0.412, respectively), so pretty close.
*  pfc -> Hidden layer weights (0.358, 0.365 for v4; 0.362, 0.387 for v3), also pretty close, but would like them to be a little higher in the current version
* Weights to output are a little different (0.60 and 0.80 for v4; 0.85 vs. 0.97 in v3), not as close -- doesn't seem to impact results (see below).
<li> added a graphview for EpochOutputData to view training progress
<li> added code to init code of LeabraTrain to set all unit_spec.specs to TrainUnitSpecs and trg_max_act_stopcrit to 1 and cyces_max to 60. Changed code to use SetUnitSpec rather than building units.

== Issues with Testing ==
<li> Text says stopping criterion is 0.7, but 0.5 is used in the simulation in the testing procedure in v3. Example is followed, and 0.5 is used here, but it's available to change via an arg to the Testing Prog
<li> made the testing env (LeabraBasicTest_NEpoch) and made a new frame from TrialOutputData 
<li> modified init code in LeabraBasicTest_NEpoch to set unit spec to TestUnitSpec, trg_max_act_stopcrit to 0.5 and cycles_max to 200. Changed code to use SetUnitSpec rather than building units
<li> Just made a data table with both kinds of test, and and new counters to plot. Also makes it easier to view the testing input datatables. Modified TrialOutputData and LeabraTrialMonitor to construct the right counters, and created the Test_BothTasks datatable
<li> UnitNames in the network don't seem to stay after closing and reopening -- link included in Documentation and the control panel to name the units

== Issues with SOA ==
<li> created a big data table that is created prior to testing, and assign it a trialtype number to make colors be different (created with SOAEnvAll -- just calls SOAEnv 4 times with appropriate parameters).
<li> changed trial_init on net to decay_state, and fixed other init progs to set the decay state to the appropriate value (1 for train and basic test, 0 for soa test)
<li>

== Param changes ==
<li>For whatever reason, network was having issues after meeting on 10/3/07.
<li>It would still demonstrate typical stroop effect, but it would actually get the conflict color naming trial wrong, rather than just have it be slow.
<li>Decided to change virtually all non-default params to defaults (rather than what was in the v3 project), and that fixed everything. 
* Changed maxda_stopcrit to 0.005 from 0.001 during training, 
* on ConSpec_0, changed savg_cor.cor to default value and savg_cor.thresh to the default value, 
* on UnitSpec_0, changed learn to 0.01 from 0
* i think only non-default values are:
** gain and vm in unitspecs
** norm_con_n in conspec
** decay states in layers (as appropriate)
** changed inhib type in hidden layer to get cleaner effects (based on what I was seeing was happening in hidden layer)
<li> to get better SOA effect, changed hidden inhib. to unit grp with gp_i and gp_g rather than layer and group inhib for layer -- this is actually kind of important

</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<li>Sun Sep 23 18:38:18 2007 jrr <code>stroop.proj</code><br>
<h2> Issues with Training </h2>
<li> added MakeTrainEnv to perform the same functionality as the FreqEnv in v3 (also makes it easy for students to view frequency of each trial type).
<li> added StimFrequencies DataLegend in order to view events as described in the text.
<li> on ConSpec_0 had to assign norm_con_n=true in order for training to work. Equivalent to fix_savg.dig_gp_n=true in the v3 code (wasn't appropriately set with the conversion). If norm_con_n = false, then no weights change. 
<ul><li> Weights from input layers to hidden layer end up being around 0.36 and 0.40 for color naming and word reading, respectively for v4 (for v3, they end up around 0.362 and 0.412, respectively), so pretty close.
<li>  pfc -> Hidden layer weights (0.358, 0.365 for v4; 0.362, 0.387 for v3), also pretty close, but would like them to be a little higher in the current version
<li> Weights to output are a little different (0.60 and 0.80 for v4; 0.85 vs. 0.97 in v3), not as close -- doesn't seem to impact results (see below).
<li> added a graphview for EpochOutputData to view training progress</ul>
<li> added code to init code of LeabraTrain to set all unit_spec.specs to TrainUnitSpecs and trg_max_act_stopcrit to 1 and cyces_max to 60. Changed code to use SetUnitSpec rather than building units.
<P>
<h2> Issues with Testing </h2>
<li> Text says stopping criterion is 0.7, but 0.5 is used in the simulation in the testing procedure in v3. Example is followed, and 0.5 is used here, but it's available to change via an arg to the Testing Prog
<li> made the testing env (LeabraBasicTest_NEpoch) and made a new frame from TrialOutputData 
<li> modified init code in LeabraBasicTest_NEpoch to set unit spec to TestUnitSpec, trg_max_act_stopcrit to 0.5 and cycles_max to 200. Changed code to use SetUnitSpec rather than building units
<li> Just made a data table with both kinds of test, and and new counters to plot. Also makes it easier to view the testing input datatables. Modified TrialOutputData and LeabraTrialMonitor to construct the right counters, and created the Test_BothTasks datatable
<li> UnitNames in the network don't seem to stay after closing and reopening -- link included in Documentation and the control panel to name the units
<P>
<h2> Issues with SOA </h2>
<li> created a big data table that is created prior to testing, and assign it a trialtype number to make colors be different (created with SOAEnvAll -- just calls SOAEnv 4 times with appropriate parameters).
<li> changed trial_init on net to decay_state, and fixed other init progs to set the decay state to the appropriate value (1 for train and basic test, 0 for soa test)
<li>
<P>
<h2> Param changes </h2>
<li>For whatever reason, network was having issues after meeting on 10/3/07.
<li>It would still demonstrate typical stroop effect, but it would actually get the conflict color naming trial wrong, rather than just have it be slow.
<li>Decided to change virtually all non-default params to defaults (rather than what was in the v3 project), and that fixed everything. 
<ul><li> Changed maxda_stopcrit to 0.005 from 0.001 during training, 
<li> on ConSpec_0, changed savg_cor.cor to default value and savg_cor.thresh to the default value, 
<li> on UnitSpec_0, changed learn to 0.01 from 0
<li> i think only non-default values are:
<ul><li> gain and vm in unitspecs
<li> norm_con_n in conspec
<li> decay states in layers (as appropriate)
<li> changed inhib type in hidden layer to get cleaner effects (based on what I was seeing was happening in hidden layer)
<li> to get better SOA effect, changed hidden inhib. to unit grp with gp_i and gp_g rather than layer and group inhib for layer -- this is actually kind of important</ul></ul>
<P>
</ul>
</body>
</html>
";
  };
  taDoc @[1] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
= Stroop Model =

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

You should see the network just as pictured in Figure 11.5 in the text.

* Begin by exploring the connectivity using r.wt

You will notice that all of the units for red versus green are connected in the way you would expect, with the exception of the connections between the hidden and output units.  Although we assume that people enter the Stroop task with more meaningful connections than the random ones we start with here (e.g., they are able to say \"Red\" and not \"Green\" when they represent red in the environment), we did not bother to preset these connections here because they become meaningful during the course of training on the task.

== Training ==

Next, let's look at the training environment patterns.

* Click on [[.T3Tab.StimFrequencies]] to view the data. 

You will see 2 tables. The top table provides the key to the bottom table, by indicating what units each box correponds to within the network (e.g. the first box in the color column corresponds to the \"g\" = green unit, the second box in the color column corresponds to the \"r\" = red unit, etc). Within the bottom table, you will see 4 rows, 2 for training the word reading pathway, and 2 for color naming (one event for each color and word).  The frequency of these events is controlled by the last column in the table. You can see that the word reading events have a frequency of 3, while the color naming events are at 2. This frequency difference causes word reading to be stronger than color naming.  Note that by using training to establish the strength of the different pathways, the model very naturally accounts for the MacLeod & Dunbar, 1988 training experiments.

(For further exploration, the relative frequency can be changed by modifying the arguments for [[.MakeTrainEnv]]  and running the program [[.MakeTrainEnv.Run()]].)

Now, let's train the network.

* View the training data graph [[.T3Tab.EpochOutputData]] to watch training proceed. Do Train: Init, Run in the [[.PanelTab.ControlPanel]]

You can see that even after the network learns to perform the task with no errors (black line asymptotes at 0 very early), the network continues to learn after reaching this hgh level of performance (as evidenced by the red line reflecting the average speed of response continuing down).

We next explore the differential weight strengths for the two pathways that develop as a result of training.  Although the observed weight differences are not huge, they are enough to produce the behavioral effects of word reading being dominant over color naming.

View the network at [[.T3Tab.StroopNet]], and select r.wt from the middle panel. Next, select the Interact button (the arrow button) on the far right of the right most frame. Click on the output units and note that the word reading pathway is stronger.  Similarly, press on the \"g\" and \"G\" hidden units in sequence, and note that the \"G\" (word reading) hidden unit has stronger weights overall.   

<hr>

'''Question 11.1 (a)''' <em> Report the weights for the \"g\" and \"G\" hidden units from their respective input, PFC, and output units (you need only report the \"gr\" output weights).  '''(b)''' At which layers in the network are the differences greatest?  '''(c)''' Can you explain this in terms of the error signals as they propagate through the network? </em>

<hr>

== Basic Stroop Task ==

Now, let's test the network on the Stroop task.  First, we will view the testing events.

* Look at the [[.T3Tab.Test_BothTasks]] tab to see the testing events.

You should see 6 rows, 3 for word reading and 3 for color naming. In the first 3 rows, you should see the control, conflict, and congruent conditions for word reading, all of which have the word reading PFC task unit clamped (the \"wr\" unit).  All patterns have the \"R\" word unit active. Control does not have any active color units, conflict adds the \"g\" (green) color unit active, and congruent adds the \"r\"  (red) color unit.

In rows 4-6, you should see the color naming events.  You should observe a similar pattern of   inputs for color naming.

Now, we can actually test the network.

* View the testing log with [[.T3Tab.TrialOutputData]], and do Test: Init, Run in the control panel.

You will see the response times (cycles of settling) plotted in the graph, which should resemble Figure 11.6 in the textbook.  The data points are plotted at X-axis values of 0, 1, and 2, corresponding to the Control, Conflict, and Congruent conditions, respectively. The different colored lines reflect color naming and word reading, respectively.  The purple labels indicate each data point.

If you compare this with the human data shown in Figure 1.3, you will see that the model reproduces all of the important characteristics of the human data as described previously: interference in the conflict condition of color naming, the imperviousness of word reading to different conditions, and the overall slowing of color naming.

Now, we can single-step through the testing events to get a better sense of what is going on. 

First, be sure you are viewing the network ([[.T3Tab.StroopNet]]), and that you are viewing activations.  Then, do a Test Init, Step.

Each StepTest of the process will advance one step through the three conditions of word reading in order (control, conflict, congruent) followed by the same for color naming.  For the word reading conditions, you should observe that the corresponding word reading hidden unit is rapidly activated, and that this then activates the corresponding output unit, with little effect of the color pathway inputs.  The critical condition of interest is the conflict color naming condition. 

<hr>

'''Question 11.2 (a)''' <em> Describe what happens in the network during the conflict color naming condition, paying particular attention to the activations of the hidden units.  '''(b)''' Explain how this leads to the observed slowing of response time (settling). </em>

<hr>

== SOA Timing Data ==

Another important set of data for the model to account for are the effects of differential stimulus onset times discussed previously (Glaser and Glaser, 1982).  To implement this test in the model, we simply present one stimulus for a specified number of cycles, and then add the other stimulus and measure the final response time (relative to the onset of the second stimulus).  We use five different SOA (stimulus onset asynchrony) values covering a range of 20 cycles on either side of the simultaneous condition.  For word reading, color starts out preceding the word by 20 cycles, then 16, 12, 8, and 4 cycles (all indicated by negative SOA), then color and word are presented simultaneously as in standard Stroop (0 SOA), and finally word precedes color by 4, 8, 12, 16, and 20 cycles (positive SOA). Similarly, for color naming, word initially precedes color (negative SOA), then word and color are presented simultaneously (0 SOA), and finally color precedes word (positive SOA).  To simplify the simulation, we run only the most important conditions -- conflict and congruent.

* To run the SOA test, first view [[.T3Tab.SOATestResults]], and then do SOA Run in the control panel.

The graph in the right panel should display the response time as a function of SOA on the X axis. You should see something like Figure 11.7 in the text when the test is complete -- because it is not possible to label the lines in the simulation, you should rely on the figure to decode what is going on.  The two solid lines represent the color naming conflict and congruent conditions.  The two dotted lines represent the word reading conflict and congruent conditions -- these lines basically fall on top of one another and so are not labeled separately, but the conflict condition line is slightly higher at the earliest SOA's.

By comparing the simulation data with the human data shown in Figure 11.4, you can see that the model's performance shows both commonalities and contrasts with the behavioral data.  We first consider the commonalities.  The model simulates several important features of the behavioral data.  Most importantly, the model shows that word reading is relatively impervious to color conditions (conflict vs. congruent), even when the colors precede the word inputs, as indicated by the similarity of the two dotted lines in the graph.  Thus, the dominant effect in the model is a strength-based competition -- the word reading pathway is sufficiently strong that even when it comes on later, it is relatively unaffected by competition from the weaker color naming pathway.  

Another important feature of the human data captured by the model is the elimination of the interference effect of words on color naming when the color precedes the word by a relatively long time (right hand side of the graph).  Thus, if the color pathway is given enough time to build up activation, it can drive the response without being affected by the word.

There are two important differences between the model and the human data, however.  One difference is that processing is relatively slowed across all conditions as the two inputs get closer to being presented simultaneously.  This is particularly evident in the two word reading conditions and in the congruent color naming condition, in the upward slope from -20 to 0 SOA, followed by a downward slope from 0 to 20. This effect can be attributed to the effects of competition -- when inputs are presented together, they compete with one another and thus slow processing.  This may be an artifact of the kWTA form of competition, as it was not found in the original Cohen, Dunbar, and McClelland (1990) model.

Another difference, which was present in that model, is the increasingly large interference effect for earlier word SOA's on color naming in the model, but not in people.  It appears that people are somehow able to reduce the word activation if it appears sufficiently early, thereby minimizing its interfering effects. Cohen, Dunbar, and McClelland (1990) suggested that people might be habituating to the word when it is presented early, reducing its influence.  However, this explanation appears unlikely given that the effects of the early word presentation are minimal even when the word is presented only 100 msec early, allowing little time for habituation. Further, this model and other models still fail to replicate the minimal effects of early word presentation even when habituation (accommodation) is added to the models.

An alternative possibility is that the minimal effects of early word presentation reflect a strategic use of perceptual (spatially mediated?) attentional mechanisms (like those explored in chapter 8) that can be engaged after identifying the stimulus as a word.  According to this account, once the word has been identified as such, it can be actively ignored, reducing its impact. Such mechanisms would not work when both stimuli are presented together because there would not be enough time to isolate the word without also processing its color.

== Effects of Frontal Damage ==

Now that we have seen that the model accounts for several important aspects of the normal data, we can assess the importance of the prefrontal (PFC) task units in the model by weakening their contribution to biasing the posterior processing pathways (i.e., the hidden layer units in the model).  The strength of this contribution can be manipulated using a weight scaling \"wt_scale\" parameter for the connections from the PFC to the Hidden layer.  This parameter is shown as thte first row of the overall control panel, with a default value of .8 (the right value, in the \"rel\" field).  Because the model is relatively sensitive, we only need to reduce this value to .75 to see an effect.  Note that this reduction in the impact of the PFC units is functionally equivalent to the gain manipulation performed by Cohen & Servan-Schreiber (1992).

* Reduce the PFC to Hidden wt_scale.rel parameter in the control panel from 0.85 to 0.75, and then view [[.T3Tab.TrialOutputData]], and do Test: Init, Run.

You should see that the model is now much slower for the conflict color naming condition, but not for any of the other conditions.  This is exactly the same pattern of data observed in frontal and schizophrenic patient populations Cohen & Servan-Schreiber (1992). Thus, we can see that the top-down activation coming from the PFC task units is specifically important for the controlled-processing necessary to overcome the prepotent word reading response.  Note that to fit the model to the actual patient response times, one must adjust for overall slowing effects that are not present in the model (see chapter 8 for a discussion of how to compare model and patient data).  

Although we have shown that reducing the PFC gain can produce the characteristic behavior of frontal patients and schizophrenics, it is still possible that other manipulations could cause this same pattern of behavior without specifically affecting the PFC.  In other words, the observed behavior may not be particularly diagnostic of PFC deficits.  For example, one typical side effect of neurological damage is that overall processing is slower -- what if this overall slowing had a differential impact on the color naming conflict condition?  To test this possibility in the model, let's reduce the dt_vm  parameter in the control panel, which determines the overall rate of settling in the model.

* Restore the PFC to Hidden wt_scale.rel field to 0.85, and then reduce the TestUnit dt.vm from 0.01 to 0.008. Make sure you are still viewing [[.T3Tab.TrialOutputData]], and do Test: Init, Run.

<hr>

'''Question 11.3''' <em>Compare the results of this overall slowing manipulation to the PFC gain manipulation performed previously.  Does slowing also produce the characteristic behavior seen in frontal and schizophrenic patients? </em>

<hr>

</body>
</html>
";
   html_text="<html><head></head><body>
<h1> Stroop Model </h1>
<p>
</p><ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
You should see the network just as pictured in Figure 11.5 in the text.
<p>
</p><ul><li> Begin by exploring the connectivity using r.wt
</li></ul>
You will notice that all of the units for red versus green are connected in the way you would expect, with the exception of the connections between the hidden and output units.  Although we assume that people enter the Stroop task with more meaningful connections than the random ones we start with here (e.g., they are able to say \"Red\" and not \"Green\" when they represent red in the environment), we did not bother to preset these connections here because they become meaningful during the course of training on the task.
<p>
</p><h2> Training </h2>
<p>
Next, let's look at the training environment patterns.
</p><p>
</p><ul><li> Click on <a href=\"ta:.T3Tab.StimFrequencies\">StimFrequencies</a> to view the data. 
</li></ul>
You will see 2 tables. The top table provides the key to the bottom table, by indicating what units each box correponds to within the network (e.g. the first box in the color column corresponds to the \"g\" = green unit, the second box in the color column corresponds to the \"r\" = red unit, etc). Within the bottom table, you will see 4 rows, 2 for training the word reading pathway, and 2 for color naming (one event for each color and word).  The frequency of these events is controlled by the last column in the table. You can see that the word reading events have a frequency of 3, while the color naming events are at 2. This frequency difference causes word reading to be stronger than color naming.  Note that by using training to establish the strength of the different pathways, the model very naturally accounts for the MacLeod &amp; Dunbar, 1988 training experiments.
<p>
(For further exploration, the relative frequency can be changed by modifying the arguments for <a href=\"ta:.MakeTrainEnv\">MakeTrainEnv</a>  and running the program <a href=\"ta:.MakeTrainEnv.Run()\">MakeTrainEnv.Run()</a>.)
</p><p>
Now, let's train the network.
</p><p>
</p><ul><li> View the training data graph <a href=\"ta:.T3Tab.EpochOutputData\">EpochOutputData</a> to watch training proceed. Do Train: Init, Run in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>
</li></ul>
You can see that even after the network learns to perform the task with no errors (black line asymptotes at 0 very early), the network continues to learn after reaching this hgh level of performance (as evidenced by the red line reflecting the average speed of response continuing down).
<p>
We next explore the differential weight strengths for the two pathways that develop as a result of training.  Although the observed weight differences are not huge, they are enough to produce the behavioral effects of word reading being dominant over color naming.
</p><p>
View the network at <a href=\"ta:.T3Tab.StroopNet\">StroopNet</a>, and select r.wt from the middle panel. Next, select the Interact button (the arrow button) on the far right of the right most frame. Click on the output units and note that the word reading pathway is stronger.  Similarly, press on the \"g\" and \"G\" hidden units in sequence, and note that the \"G\" (word reading) hidden unit has stronger weights overall.   
</p><p>
</p><hr>
<p>
 <b>Question 11.1 (a)</b>  <em> Report the weights for the \"g\" and \"G\" hidden units from their respective input, PFC, and output units (you need only report the \"gr\" output weights).   <b>(b)</b>  At which layers in the network are the differences greatest?   <b>(c)</b>  Can you explain this in terms of the error signals as they propagate through the network? </em>
</p><p>
</p><hr>
<p>
</p><h2> Basic Stroop Task </h2>
<p>
Now, let's test the network on the Stroop task.  First, we will view the testing events.
</p><p>
</p><ul><li> Look at the <a href=\"ta:.T3Tab.Test_BothTasks\">Test_BothTasks</a> tab to see the testing events.
</li></ul>
You should see 6 rows, 3 for word reading and 3 for color naming. In the first 3 rows, you should see the control, conflict, and congruent conditions for word reading, all of which have the word reading PFC task unit clamped (the \"wr\" unit).  All patterns have the \"R\" word unit active. Control does not have any active color units, conflict adds the \"g\" (green) color unit active, and congruent adds the \"r\"  (red) color unit.
<p>
In rows 4-6, you should see the color naming events.  You should observe a similar pattern of   inputs for color naming.
</p><p>
Now, we can actually test the network.
</p><p>
</p><ul><li> View the testing log with <a href=\"ta:.T3Tab.TrialOutputData\">TrialOutputData</a>, and do Test: Init, Run in the control panel.
</li></ul>
You will see the response times (cycles of settling) plotted in the graph, which should resemble Figure 11.6 in the textbook.  The data points are plotted at X-axis values of 0, 1, and 2, corresponding to the Control, Conflict, and Congruent conditions, respectively. The different colored lines reflect color naming and word reading, respectively.  The purple labels indicate each data point.
<p>
If you compare this with the human data shown in Figure 1.3, you will see that the model reproduces all of the important characteristics of the human data as described previously: interference in the conflict condition of color naming, the imperviousness of word reading to different conditions, and the overall slowing of color naming.
</p><p>
Now, we can single-step through the testing events to get a better sense of what is going on. 
</p><p>
First, be sure you are viewing the network (<a href=\"ta:.T3Tab.StroopNet\">StroopNet</a>), and that you are viewing activations.  Then, do a Test Init, Step.
</p><p>
Each StepTest of the process will advance one step through the three conditions of word reading in order (control, conflict, congruent) followed by the same for color naming.  For the word reading conditions, you should observe that the corresponding word reading hidden unit is rapidly activated, and that this then activates the corresponding output unit, with little effect of the color pathway inputs.  The critical condition of interest is the conflict color naming condition. 
</p><p>
</p><hr>
<p>
 <b>Question 11.2 (a)</b>  <em> Describe what happens in the network during the conflict color naming condition, paying particular attention to the activations of the hidden units.   <b>(b)</b>  Explain how this leads to the observed slowing of response time (settling). </em>
</p><p>
</p><hr>
<p>
</p><h2> SOA Timing Data </h2>
<p>
Another important set of data for the model to account for are the effects of differential stimulus onset times discussed previously (Glaser and Glaser, 1982).  To implement this test in the model, we simply present one stimulus for a specified number of cycles, and then add the other stimulus and measure the final response time (relative to the onset of the second stimulus).  We use five different SOA (stimulus onset asynchrony) values covering a range of 20 cycles on either side of the simultaneous condition.  For word reading, color starts out preceding the word by 20 cycles, then 16, 12, 8, and 4 cycles (all indicated by negative SOA), then color and word are presented simultaneously as in standard Stroop (0 SOA), and finally word precedes color by 4, 8, 12, 16, and 20 cycles (positive SOA). Similarly, for color naming, word initially precedes color (negative SOA), then word and color are presented simultaneously (0 SOA), and finally color precedes word (positive SOA).  To simplify the simulation, we run only the most important conditions -- conflict and congruent.
</p><p>
</p><ul><li> To run the SOA test, first view <a href=\"ta:.T3Tab.SOATestResults\">SOATestResults</a>, and then do SOA Run in the control panel.
</li></ul>
The graph in the right panel should display the response time as a function of SOA on the X axis. You should see something like Figure 11.7 in the text when the test is complete -- because it is not possible to label the lines in the simulation, you should rely on the figure to decode what is going on.  The two solid lines represent the color naming conflict and congruent conditions.  The two dotted lines represent the word reading conflict and congruent conditions -- these lines basically fall on top of one another and so are not labeled separately, but the conflict condition line is slightly higher at the earliest SOA's.
<p>
By comparing the simulation data with the human data shown in Figure 11.4, you can see that the model's performance shows both commonalities and contrasts with the behavioral data.  We first consider the commonalities.  The model simulates several important features of the behavioral data.  Most importantly, the model shows that word reading is relatively impervious to color conditions (conflict vs. congruent), even when the colors precede the word inputs, as indicated by the similarity of the two dotted lines in the graph.  Thus, the dominant effect in the model is a strength-based competition -- the word reading pathway is sufficiently strong that even when it comes on later, it is relatively unaffected by competition from the weaker color naming pathway.  
</p><p>
Another important feature of the human data captured by the model is the elimination of the interference effect of words on color naming when the color precedes the word by a relatively long time (right hand side of the graph).  Thus, if the color pathway is given enough time to build up activation, it can drive the response without being affected by the word.
</p><p>
There are two important differences between the model and the human data, however.  One difference is that processing is relatively slowed across all conditions as the two inputs get closer to being presented simultaneously.  This is particularly evident in the two word reading conditions and in the congruent color naming condition, in the upward slope from -20 to 0 SOA, followed by a downward slope from 0 to 20. This effect can be attributed to the effects of competition -- when inputs are presented together, they compete with one another and thus slow processing.  This may be an artifact of the kWTA form of competition, as it was not found in the original Cohen, Dunbar, and McClelland (1990) model.
</p><p>
Another difference, which was present in that model, is the increasingly large interference effect for earlier word SOA's on color naming in the model, but not in people.  It appears that people are somehow able to reduce the word activation if it appears sufficiently early, thereby minimizing its interfering effects. Cohen, Dunbar, and McClelland (1990) suggested that people might be habituating to the word when it is presented early, reducing its influence.  However, this explanation appears unlikely given that the effects of the early word presentation are minimal even when the word is presented only 100 msec early, allowing little time for habituation. Further, this model and other models still fail to replicate the minimal effects of early word presentation even when habituation (accommodation) is added to the models.
</p><p>
An alternative possibility is that the minimal effects of early word presentation reflect a strategic use of perceptual (spatially mediated?) attentional mechanisms (like those explored in chapter 8) that can be engaged after identifying the stimulus as a word.  According to this account, once the word has been identified as such, it can be actively ignored, reducing its impact. Such mechanisms would not work when both stimuli are presented together because there would not be enough time to isolate the word without also processing its color.
</p><p>
</p><h2> Effects of Frontal Damage </h2>
<p>
Now that we have seen that the model accounts for several important aspects of the normal data, we can assess the importance of the prefrontal (PFC) task units in the model by weakening their contribution to biasing the posterior processing pathways (i.e., the hidden layer units in the model).  The strength of this contribution can be manipulated using a weight scaling \"wt_scale\" parameter for the connections from the PFC to the Hidden layer.  This parameter is shown as thte first row of the overall control panel, with a default value of .8 (the right value, in the \"rel\" field).  Because the model is relatively sensitive, we only need to reduce this value to .75 to see an effect.  Note that this reduction in the impact of the PFC units is functionally equivalent to the gain manipulation performed by Cohen &amp; Servan-Schreiber (1992).
</p><p>
</p><ul><li> Reduce the PFC to Hidden wt_scale.rel parameter in the control panel from 0.85 to 0.75, and then view <a href=\"ta:.T3Tab.TrialOutputData\">TrialOutputData</a>, and do Test: Init, Run.
</li></ul>
You should see that the model is now much slower for the conflict color naming condition, but not for any of the other conditions.  This is exactly the same pattern of data observed in frontal and schizophrenic patient populations Cohen &amp; Servan-Schreiber (1992). Thus, we can see that the top-down activation coming from the PFC task units is specifically important for the controlled-processing necessary to overcome the prepotent word reading response.  Note that to fit the model to the actual patient response times, one must adjust for overall slowing effects that are not present in the model (see chapter 8 for a discussion of how to compare model and patient data).  
<p>
Although we have shown that reducing the PFC gain can produce the characteristic behavior of frontal patients and schizophrenics, it is still possible that other manipulations could cause this same pattern of behavior without specifically affecting the PFC.  In other words, the observed behavior may not be particularly diagnostic of PFC deficits.  For example, one typical side effect of neurological damage is that overall processing is slower -- what if this overall slowing had a differential impact on the color naming conflict condition?  To test this possibility in the model, let's reduce the dt_vm  parameter in the control panel, which determines the overall rate of settling in the model.
</p><p>
</p><ul><li> Restore the PFC to Hidden wt_scale.rel field to 0.85, and then reduce the TestUnit dt.vm from 0.01 to 0.008. Make sure you are still viewing <a href=\"ta:.T3Tab.TrialOutputData\">TrialOutputData</a>, and do Test: Init, Run.
</li></ul>
<hr>
<p>
 <b>Question 11.3</b>  <em>Compare the results of this overall slowing manipulation to the PFC gain manipulation performed previously.  Does slowing also produce the characteristic behavior seen in frontal and schizophrenic patients? </em>
</p><p>
</p><hr>
<p>


</p></body></html>";
  };
  taDoc @[2] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Stroop";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Stroop";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Stroop,CECN1 Projects,Emergent,.T3Tab.StimFrequencies,.MakeTrainEnv,.MakeTrainEnv.Run(),.T3Tab.EpochOutputData,.PanelTab.ControlPanel,.T3Tab.StroopNet,.T3Tab.Test BothTasks,.T3Tab.TrialOutputData\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Stroop - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Stroop\";
		var wgTitle = \"CECN1 Stroop\";
		var wgAction = \"view\";
		var wgArticleId = \"148\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 410;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Stroop skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Stroop</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#The_Stroop_Task\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">The Stroop Task</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Training\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Training</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Basic_Stroop_Task\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">Basic Stroop Task</span></a></li>
<li class=\"toclevel-2\"><a href=\"#SOA_Timing_Data\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">SOA Timing Data</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Effects_of_Frontal_Damage\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Effects of Frontal Damage</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"The_Stroop_Task\" id=\"The_Stroop_Task\"></a><h1> <span class=\"mw-headline\"> The Stroop Task </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/8/81/stroop.proj\" class=\"internal\" title=\"stroop.proj\">stroop.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p><br>
</p>
<ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
<p>You should see the network just as pictured in Figure 11.5 in the text.
</p>
<ul><li> Begin by exploring the connectivity using r.wt
</li></ul>
<p>You will notice that all of the units for red versus green are connected in the way you would expect, with the exception of the connections between the hidden and output units.  Although we assume that people enter the Stroop task with more meaningful connections than the random ones we start with here (e.g., they are able to say \"Red\" and not \"Green\" when they represent red in the environment), we did not bother to preset these connections here because they become meaningful during the course of training on the task.
</p>
<a name=\"Training\" id=\"Training\"></a><h2> <span class=\"mw-headline\"> Training </span></h2>
<p>Next, let's look at the training environment patterns.
</p>
<ul><li> Click on <a href=\"/CompCogNeuro/index.php?title=.T3Tab.StimFrequencies&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.StimFrequencies (page does not exist)\">.T3Tab.StimFrequencies</a> to view the data. 
</li></ul>
<p>You will see 2 tables. The top table provides the key to the bottom table, by indicating what units each box correponds to within the network (e.g. the first box in the color column corresponds to the \"g\" = green unit, the second box in the color column corresponds to the \"r\" = red unit, etc). Within the bottom table, you will see 4 rows, 2 for training the word reading pathway, and 2 for color naming (one event for each color and word).  The frequency of these events is controlled by the last column in the table. You can see that the word reading events have a frequency of 3, while the color naming events are at 2. This frequency difference causes word reading to be stronger than color naming.  Note that by using training to establish the strength of the different pathways, the model very naturally accounts for the MacLeod &amp; Dunbar, 1988 training experiments.
</p><p>(For further exploration, the relative frequency can be changed by modifying the arguments for <a href=\"/CompCogNeuro/index.php?title=.MakeTrainEnv&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".MakeTrainEnv (page does not exist)\">.MakeTrainEnv</a>  and running the program <a href=\"/CompCogNeuro/index.php?title=.MakeTrainEnv.Run()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".MakeTrainEnv.Run() (page does not exist)\">.MakeTrainEnv.Run()</a>.)
</p><p>Now, let's train the network.
</p>
<ul><li> View the training data graph <a href=\"/CompCogNeuro/index.php?title=.T3Tab.EpochOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.EpochOutputData (page does not exist)\">.T3Tab.EpochOutputData</a> to watch training proceed. Do Train: Init, Run in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\">.PanelTab.ControlPanel</a>
</li></ul>
<p>You can see that even after the network learns to perform the task with no errors (black line asymptotes at 0 very early), the network continues to learn after reaching this hgh level of performance (as evidenced by the red line reflecting the average speed of response continuing down).
</p><p>We next explore the differential weight strengths for the two pathways that develop as a result of training.  Although the observed weight differences are not huge, they are enough to produce the behavioral effects of word reading being dominant over color naming.
</p><p>View the network at <a href=\"/CompCogNeuro/index.php?title=.T3Tab.StroopNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.StroopNet (page does not exist)\">.T3Tab.StroopNet</a>, and select r.wt from the middle panel. Next, select the Interact button (the arrow button) on the far right of the right most frame. Click on the output units and note that the word reading pathway is stronger.  Similarly, press on the \"g\" and \"G\" hidden units in sequence, and note that the \"G\" (word reading) hidden unit has stronger weights overall.   
</p>
<hr>
<p><b>Question 11.1 (a)</b> <em> Report the weights for the \"g\" and \"G\" hidden units from their respective input, PFC, and output units (you need only report the \"gr\" output weights).  <b>(b)</b> At which layers in the network are the differences greatest?  <b>(c)</b> Can you explain this in terms of the error signals as they propagate through the network? </em>
</p>
<hr>
<a name=\"Basic_Stroop_Task\" id=\"Basic_Stroop_Task\"></a><h2> <span class=\"mw-headline\"> Basic Stroop Task </span></h2>
<p>Now, let's test the network on the Stroop task.  First, we will view the testing events.
</p>
<ul><li> Look at the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.Test_BothTasks&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.Test BothTasks (page does not exist)\">.T3Tab.Test_BothTasks</a> tab to see the testing events.
</li></ul>
<p>You should see 6 rows, 3 for word reading and 3 for color naming. In the first 3 rows, you should see the control, conflict, and congruent conditions for word reading, all of which have the word reading PFC task unit clamped (the \"wr\" unit).  All patterns have the \"R\" word unit active. Control does not have any active color units, conflict adds the \"g\" (green) color unit active, and congruent adds the \"r\"  (red) color unit.
</p><p>In rows 4-6, you should see the color naming events.  You should observe a similar pattern of   inputs for color naming.
</p><p>Now, we can actually test the network.
</p>
<ul><li> View the testing log with <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputData (page does not exist)\">.T3Tab.TrialOutputData</a>, and do Test: Init, Run in the control panel.
</li></ul>
<p>You will see the response times (cycles of settling) plotted in the graph, which should resemble Figure 11.6 in the textbook.  The data points are plotted at X-axis values of 0, 1, and 2, corresponding to the Control, Conflict, and Congruent conditions, respectively. The different colored lines reflect color naming and word reading, respectively.  The purple labels indicate each data point.
</p><p>If you compare this with the human data shown in Figure 1.3, you will see that the model reproduces all of the important characteristics of the human data as described previously: interference in the conflict condition of color naming, the imperviousness of word reading to different conditions, and the overall slowing of color naming.
</p><p>Now, we can single-step through the testing events to get a better sense of what is going on. 
</p><p>First, be sure you are viewing the network (<a href=\"/CompCogNeuro/index.php?title=.T3Tab.StroopNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.StroopNet (page does not exist)\">.T3Tab.StroopNet</a>), and that you are viewing activations.  Then, do a Test Init, Step.
</p><p>Each StepTest of the process will advance one step through the three conditions of word reading in order (control, conflict, congruent) followed by the same for color naming.  For the word reading conditions, you should observe that the corresponding word reading hidden unit is rapidly activated, and that this then activates the corresponding output unit, with little effect of the color pathway inputs.  The critical condition of interest is the conflict color naming condition. 
</p>
<hr>
<p><b>Question 11.2 (a)</b> <em> Describe what happens in the network during the conflict color naming condition, paying particular attention to the activations of the hidden units.  <b>(b)</b> Explain how this leads to the observed slowing of response time (settling). </em>
</p>
<hr>
<a name=\"SOA_Timing_Data\" id=\"SOA_Timing_Data\"></a><h2> <span class=\"mw-headline\"> SOA Timing Data </span></h2>
<p>Another important set of data for the model to account for are the effects of differential stimulus onset times discussed previously (Glaser and Glaser, 1982).  To implement this test in the model, we simply present one stimulus for a specified number of cycles, and then add the other stimulus and measure the final response time (relative to the onset of the second stimulus).  We use five different SOA (stimulus onset asynchrony) values covering a range of 20 cycles on either side of the simultaneous condition.  For word reading, color starts out preceding the word by 20 cycles, then 16, 12, 8, and 4 cycles (all indicated by negative SOA), then color and word are presented simultaneously as in standard Stroop (0 SOA), and finally word precedes color by 4, 8, 12, 16, and 20 cycles (positive SOA). Similarly, for color naming, word initially precedes color (negative SOA), then word and color are presented simultaneously (0 SOA), and finally color precedes word (positive SOA).  To simplify the simulation, we run only the most important conditions -- conflict and congruent.
</p>
<ul><li> To run the SOA test, first view <a href=\"/CompCogNeuro/index.php?title=.T3Tab.SOATestResults&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.SOATestResults (page does not exist)\">.T3Tab.SOATestResults</a>, and then do SOA Run in the control panel.
</li></ul>
<p>The graph in the right panel should display the response time as a function of SOA on the X axis. You should see something like Figure 11.7 in the text when the test is complete -- because it is not possible to label the lines in the simulation, you should rely on the figure to decode what is going on.  The two solid lines represent the color naming conflict and congruent conditions.  The two dotted lines represent the word reading conflict and congruent conditions -- these lines basically fall on top of one another and so are not labeled separately, but the conflict condition line is slightly higher at the earliest SOA's.
</p><p>By comparing the simulation data with the human data shown in Figure 11.4, you can see that the model's performance shows both commonalities and contrasts with the behavioral data.  We first consider the commonalities.  The model simulates several important features of the behavioral data.  Most importantly, the model shows that word reading is relatively impervious to color conditions (conflict vs. congruent), even when the colors precede the word inputs, as indicated by the similarity of the two dotted lines in the graph.  Thus, the dominant effect in the model is a strength-based competition -- the word reading pathway is sufficiently strong that even when it comes on later, it is relatively unaffected by competition from the weaker color naming pathway.  
</p><p>Another important feature of the human data captured by the model is the elimination of the interference effect of words on color naming when the color precedes the word by a relatively long time (right hand side of the graph).  Thus, if the color pathway is given enough time to build up activation, it can drive the response without being affected by the word.
</p><p>There are two important differences between the model and the human data, however.  One difference is that processing is relatively slowed across all conditions as the two inputs get closer to being presented simultaneously.  This is particularly evident in the two word reading conditions and in the congruent color naming condition, in the upward slope from -20 to 0 SOA, followed by a downward slope from 0 to 20. This effect can be attributed to the effects of competition -- when inputs are presented together, they compete with one another and thus slow processing.  This may be an artifact of the kWTA form of competition, as it was not found in the original Cohen, Dunbar, and McClelland (1990) model.
</p><p>Another difference, which was present in that model, is the increasingly large interference effect for earlier word SOA's on color naming in the model, but not in people.  It appears that people are somehow able to reduce the word activation if it appears sufficiently early, thereby minimizing its interfering effects. Cohen, Dunbar, and McClelland (1990) suggested that people might be habituating to the word when it is presented early, reducing its influence.  However, this explanation appears unlikely given that the effects of the early word presentation are minimal even when the word is presented only 100 msec early, allowing little time for habituation. Further, this model and other models still fail to replicate the minimal effects of early word presentation even when habituation (accommodation) is added to the models.
</p><p>An alternative possibility is that the minimal effects of early word presentation reflect a strategic use of perceptual (spatially mediated?) attentional mechanisms (like those explored in chapter 8) that can be engaged after identifying the stimulus as a word.  According to this account, once the word has been identified as such, it can be actively ignored, reducing its impact. Such mechanisms would not work when both stimuli are presented together because there would not be enough time to isolate the word without also processing its color.
</p>
<a name=\"Effects_of_Frontal_Damage\" id=\"Effects_of_Frontal_Damage\"></a><h2> <span class=\"mw-headline\"> Effects of Frontal Damage </span></h2>
<p>Now that we have seen that the model accounts for several important aspects of the normal data, we can assess the importance of the prefrontal (PFC) task units in the model by weakening their contribution to biasing the posterior processing pathways (i.e., the hidden layer units in the model).  The strength of this contribution can be manipulated using a weight scaling \"wt_scale\" parameter for the connections from the PFC to the Hidden layer.  This parameter is shown as thte first row of the overall control panel, with a default value of .8 (the right value, in the \"rel\" field).  Because the model is relatively sensitive, we only need to reduce this value to .75 to see an effect.  Note that this reduction in the impact of the PFC units is functionally equivalent to the gain manipulation performed by Cohen &amp; Servan-Schreiber (1992).
</p>
<ul><li> Reduce the PFC to Hidden wt_scale.rel parameter in the control panel from 0.8 to 0.75, and then view <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputData (page does not exist)\">.T3Tab.TrialOutputData</a>, and do Test: Init, Run.
</li></ul>
<p>You should see that the model is now much slower for the conflict color naming condition, but not for any of the other conditions.  This is exactly the same pattern of data observed in frontal and schizophrenic patient populations Cohen &amp; Servan-Schreiber (1992). Thus, we can see that the top-down activation coming from the PFC task units is specifically important for the controlled-processing necessary to overcome the prepotent word reading response.  Note that to fit the model to the actual patient response times, one must adjust for overall slowing effects that are not present in the model (see chapter 8 for a discussion of how to compare model and patient data).  
</p><p>Although we have shown that reducing the PFC gain can produce the characteristic behavior of frontal patients and schizophrenics, it is still possible that other manipulations could cause this same pattern of behavior without specifically affecting the PFC.  In other words, the observed behavior may not be particularly diagnostic of PFC deficits.  For example, one typical side effect of neurological damage is that overall processing is slower -- what if this overall slowing had a differential impact on the color naming conflict condition?  To test this possibility in the model, let's reduce the dt_vm  parameter in the control panel, which determines the overall rate of settling in the model.
</p>
<ul><li> Restore the PFC to Hidden wt_scale.rel field to 0.8, and then reduce the TestUnit dt.vm from 0.01 to 0.008. Make sure you are still viewing <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputData (page does not exist)\">.T3Tab.TrialOutputData</a>, and do Test: Init, Run.
</li></ul>
<hr>
<p><b>Question 11.3</b> <em>Compare the results of this overall slowing manipulation to the PFC gain manipulation performed previously.  Does slowing also produce the characteristic behavior seen in frontal and schizophrenic patients? </em>
</p>
<hr>

<!-- 
NewPP limit report
Preprocessor node count: 7/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:148-0!1!0!!en!2!edit=0 and timestamp 20090907221840 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Stroop\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Stroop</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Stroop\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Stroop&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Stroop&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Stroop&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Stroop\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Stroop\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Stroop\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Stroop&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Stroop&amp;oldid=410\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Stroop&amp;oldid=410&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Stroop&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 7 January 2009, at 10:22.</li>
					<li id=\"viewcount\">This page has been accessed 827 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.221 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="Overall control panel for the Stroop project";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="PFC to Hidden wt_scale";
     desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
     cust_desc=0;
     base=.projects[0].networks[0].specs[1].children[1]$$;
     mbr=LeabraConSpec::wt_scale;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="TestUnit dt";
     desc=" time constants (rate of updating): membrane potential (vm) and net input (net)<br>  integ: [Default: 1;0.5;0.001;0.0005]  overall rate constant for numerical integration -- affected by the timescale of the parameters and numerical stability issues -- typically 1 cycle = 1 ms, and if using ms normed units, this should be 1, otherwise 0.001 (1 ms in seconds) or possibly .5 or .0005 if there are stability issues<br>  vm: [Default: 0.1:0.357]  membrane potential rate constant -- reflects the capacitance of the neuron in principle -- biological default for AeEx spiking model C = 281 pF = 2.81 normalized = .356 rate constant<br>  net: [Default: 0.7]  net input time constant -- how fast to update net input (damps oscillations) -- generally reflects time constants associated with synaptic channels which are not modeled in the most abstract rate code models (set to 1 for detailed spiking models with more realistic synaptic currents)<br>  midpoint: [Default: false]  use the midpoint method in computing the vm value -- better avoids oscillations and allows a larger dt.vm parameter to be used<br>  d vm max: [Default: 0.02;0.025;100]  maximum change in vm at any timestep (limits blowup) -- this is a crude but effective safety valve for numerical integration problems<br>  vm eq cyc: [Default: 0]  number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation<br>  vm eq dt: [Default: 1]  time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value<br>  integ time:  1/integ rate constant = time constant for each cycle of updating for numerical integration<br>  vm time:  1/vm rate constant = time in cycles for vm to reach 1/e of asymptotic value<br>  net time:  1/net rate constant = time in cycles for net to reach 1/e of asymptotic value";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0].children[0]$$;
     mbr=LeabraUnitSpec::dt;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="UnitSpec act";
     desc=" activation function specs<br>  gelin:  compute rate-code activations directly off of the g_e excitatory conductance (i.e., net = netinput) compared to the g_e value that would put the unit right at its firing threshold (g_e_thr) -- this reproduces the empirical rate-code behavior of a discrete spiking network much better than computing off of the v_m - thr value -- important: when gelin is clicked, the membrane potential (v_m, and all other parameters relevant to it such as dt.vm) is completely irrelevant to the activation output of the unit -- all the other conductances (g_i, g_l, g_a, g_h) enter via their effects on the effective threshold (g_e_thr)<br>  thr: [Default: 0.25;0.5]  threshold value Theta (Q) for firing output activation (.5 is more accurate value based on AdEx biological parameters)<br>  gain: [Default: 600;80]  gain (gamma) of the sigmoidal rate-coded activation function -- 600 is default for gelin = false, 80 is default for gelin = true<br>  nvar: [Default: 0.005;0.01]  variance of the Gaussian noise kernel for convolving with XX1 in NOISY_XX1 -- 0.005 is default for geiln = false, 0.01 is default for gelin = true<br>  avg dt: [Default: 0.005]  time constant for integrating activation average (computed across trials)<br>  avg init: [Default: 0.15]  initial activation average value<br>  i thr:  [STD or NO_AH for da mod units) how to compute the inhibitory threshold for kWTA functions (what currents to include or exclude in determining what amount of inhibition would keep the unit just at threshold firing) -- for units with dopamine-like modulation using the a and h currents, NO_AH makes learning much more reliable because otherwise kwta partially compensates for the da modulation<br>    STD:  include all currents (except bias weights) in inhibitory threshold computation<br>    NO A:  exclude gc.a current: allows accommodation to knock out units from kwta active list, without other units coming in to take their place<br>    NO H:  exclude gc.h current: prevent hysteresis current from affecting inhibitory threshold computation<br>    NO AH:  exclude gc.a and gc.h currents: prevent both accommodation and hysteresis currents from affecting inhibitory threshold computation<br>    ALL:  include all currents INCLUDING bias weights";
     cust_desc=0;
     base=.projects[0].networks[0].specs[0]$$;
     mbr=LeabraUnitSpec::act;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="ConSpec lmix";
     desc=" mixture of hebbian & err-driven learning (note: no hebbian for CTLEABRA_XCAL)<br>  hebb:  [Default: .001] amount of hebbian learning (should be relatively small, can be effective at .0001)<br>  err:  [Default: .999] amount of error driven learning, automatically computed to be 1-hebb<br>  err sb: [Default: true]  apply exponential soft-bounding to the error learning component (applied in dWt)";
     cust_desc=0;
     base=.projects[0].networks[0].specs[1]$$;
     mbr=LeabraConSpec::lmix;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[4] {
     label="cycle updt view";
     desc=" boolean value";
     cust_desc=0;
     base=.projects[0].programs.gp[1][6].vars[0]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Train: Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][1]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Test: Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[1][2]$$;
     mth=Program::Init;
    };
    EditMthItem @[5] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][2]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[6] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][2]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[7] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][2]$;
     mth=Program::Stop;
    };
    EditMthItem @[8] {
     label="SOA Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[1][0]$$;
     mth=Program::Init;
    };
    EditMthItem @[9] {
     label="SOA Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[1][0]$;
     mth=Program::Run_Gui;
    };
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="Train_F3_2";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [10] "Gw";"Gw";"Gw";"Rw";"Rw";"Rw";"gc";"gc";"rc";"rc";
      };
     };
     float_Data @[1] {
      name="Colors";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 10] 0;0;0;0;0;0;0;0;0;0;
0;0;1;0;1;0;0;1;0;1;
      };
     };
     float_Data @[2] {
      name="Words";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 10] 1;0;1;0;1;0;0;1;0;1;
0;1;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[3] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 10] 1;0;1;0;1;0;0;1;0;1;
0;1;1;0;1;0;0;1;0;1;
      };
     };
     float_Data @[4] {
      name="PFC";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 10] 0;1;0;1;0;1;0;1;0;1;
0;1;1;0;1;0;1;0;1;0;
      };
     };
     float_Data @[5] {
      name="frequency";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [10] 3;3;3;3;3;3;2;2;2;2;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=5;
      val_type_fixed=0;
     };
    };
    name="Test_BothTasks";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [6] "Word_Ctrl";"Word_Conf";"Word_Cong";"Color_Ctrl";"Color_Conf";"Color_Cong";      };
     };
     float_Data @[1] {
      name="Colors";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 6] 0;0;1;0;0;1;0;1;0;1;
0;1;      };
     };
     float_Data @[2] {
      name="Words";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 6] 0;1;0;1;0;1;0;0;1;0;
0;1;      };
     };
     float_Data @[3] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 6] 0;1;0;1;0;1;0;1;0;1;
0;1;      };
     };
     float_Data @[4] {
      name="PFC";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 6] 0;1;0;1;0;1;1;0;1;0;
1;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=5;
      val_type_fixed=0;
     };
    };
    name="Test_SOA";
    desc="test the SOA effects -- generated each epoch";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [84] "P_cn_W_G_earlystim";"P_cn_W_G_latestim";"P_cn_W_G_earlystim";"P_cn_W_G_latestim";"P_cn_W_G_earlystim";"P_cn_W_G_latestim";"P_cn_W_G_earlystim";"P_cn_W_G_latestim";"P_cn_W_G_earlystim";"P_cn_W_G_latestim";
"P_cn_Both_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";
"P_cn_C_r_latestim";"P_cn_W_R_earlystim";"P_cn_W_R_latestim";"P_cn_W_R_earlystim";"P_cn_W_R_latestim";"P_cn_W_R_earlystim";"P_cn_W_R_latestim";"P_cn_W_R_earlystim";"P_cn_W_R_latestim";"P_cn_W_R_earlystim";
"P_cn_W_R_latestim";"P_cn_Both_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_cn_C_r_earlystim";"P_cn_C_r_latestim";
"P_cn_C_r_earlystim";"P_cn_C_r_latestim";"P_wr_C_g_earlystim";"P_wr_C_g_latestim";"P_wr_C_g_earlystim";"P_wr_C_g_latestim";"P_wr_C_g_earlystim";"P_wr_C_g_latestim";"P_wr_C_g_earlystim";"P_wr_C_g_latestim";
"P_wr_C_g_earlystim";"P_wr_C_g_latestim";"P_wr_Both_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";
"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_C_r_earlystim";"P_wr_C_r_latestim";"P_wr_C_r_earlystim";"P_wr_C_r_latestim";"P_wr_C_r_earlystim";"P_wr_C_r_latestim";"P_wr_C_r_earlystim";
"P_wr_C_r_latestim";"P_wr_C_r_earlystim";"P_wr_C_r_latestim";"P_wr_Both_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";
"P_wr_W_R_earlystim";"P_wr_W_R_latestim";"P_wr_W_R_earlystim";"P_wr_W_R_latestim";      };
     };
     float_Data @[1] {
      name="Colors";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 84] 0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;1;0;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;0;0;0;1;      };
     };
     float_Data @[2] {
      name="Words";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 84] 1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;0;0;1;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;0;
1;0;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;      };
     };
     float_Data @[3] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 84] 0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;      };
     };
     float_Data @[4] {
      name="PFC";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 84] 1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;1;0;1;0;1;0;
1;0;1;0;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;0;1;
0;1;0;1;0;1;0;1;      };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="SOA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [84] -20;-20;-16;-16;-12;-12;-8;-8;-4;-4;
0;4;4;8;8;12;12;16;16;20;
20;-20;-20;-16;-16;-12;-12;-8;-8;-4;
-4;0;4;4;8;8;12;12;16;16;
20;20;-20;-20;-16;-16;-12;-12;-8;-8;
-4;-4;0;4;4;8;8;12;12;16;
16;20;20;-20;-20;-16;-16;-12;-12;-8;
-8;-4;-4;0;4;4;8;8;12;12;
16;16;20;20;      };
     };
     int_Data @[6] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="max_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [84] 20;200;16;200;12;200;8;200;4;200;
200;4;200;8;200;12;200;16;200;20;
200;20;200;16;200;12;200;8;200;4;
200;200;4;200;8;200;12;200;16;200;
20;200;20;200;16;200;12;200;8;200;
4;200;200;4;200;8;200;12;200;16;
200;20;200;20;200;16;200;12;200;8;
200;4;200;200;4;200;8;200;12;200;
16;200;20;200;      };
     };
     String_Data @[7] {
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [84] "P_cn_conflict_SOA_-20";"P_cn_conflict_SOA_-20";"P_cn_conflict_SOA_-16";"P_cn_conflict_SOA_-16";"P_cn_conflict_SOA_-12";"P_cn_conflict_SOA_-12";"P_cn_conflict_SOA_-8";"P_cn_conflict_SOA_-8";"P_cn_conflict_SOA_-4";"P_cn_conflict_SOA_-4";
"P_cn_conflict_SOA_0";"P_cn_conflict_SOA_4";"P_cn_conflict_SOA_4";"P_cn_conflict_SOA_8";"P_cn_conflict_SOA_8";"P_cn_conflict_SOA_12";"P_cn_conflict_SOA_12";"P_cn_conflict_SOA_16";"P_cn_conflict_SOA_16";"P_cn_conflict_SOA_20";
"P_cn_conflict_SOA_20";"P_cn_congruent_SOA_-20";"P_cn_congruent_SOA_-20";"P_cn_congruent_SOA_-16";"P_cn_congruent_SOA_-16";"P_cn_congruent_SOA_-12";"P_cn_congruent_SOA_-12";"P_cn_congruent_SOA_-8";"P_cn_congruent_SOA_-8";"P_cn_congruent_SOA_-4";
"P_cn_congruent_SOA_-4";"P_cn_congruent_SOA_0";"P_cn_congruent_SOA_4";"P_cn_congruent_SOA_4";"P_cn_congruent_SOA_8";"P_cn_congruent_SOA_8";"P_cn_congruent_SOA_12";"P_cn_congruent_SOA_12";"P_cn_congruent_SOA_16";"P_cn_congruent_SOA_16";
"P_cn_congruent_SOA_20";"P_cn_congruent_SOA_20";"P_wr_conflict_SOA_-20";"P_wr_conflict_SOA_-20";"P_wr_conflict_SOA_-16";"P_wr_conflict_SOA_-16";"P_wr_conflict_SOA_-12";"P_wr_conflict_SOA_-12";"P_wr_conflict_SOA_-8";"P_wr_conflict_SOA_-8";
"P_wr_conflict_SOA_-4";"P_wr_conflict_SOA_-4";"P_wr_conflict_SOA_0";"P_wr_conflict_SOA_4";"P_wr_conflict_SOA_4";"P_wr_conflict_SOA_8";"P_wr_conflict_SOA_8";"P_wr_conflict_SOA_12";"P_wr_conflict_SOA_12";"P_wr_conflict_SOA_16";
"P_wr_conflict_SOA_16";"P_wr_conflict_SOA_20";"P_wr_conflict_SOA_20";"P_wr_congruent_SOA_-20";"P_wr_congruent_SOA_-20";"P_wr_congruent_SOA_-16";"P_wr_congruent_SOA_-16";"P_wr_congruent_SOA_-12";"P_wr_congruent_SOA_-12";"P_wr_congruent_SOA_-8";
"P_wr_congruent_SOA_-8";"P_wr_congruent_SOA_-4";"P_wr_congruent_SOA_-4";"P_wr_congruent_SOA_0";"P_wr_congruent_SOA_4";"P_wr_congruent_SOA_4";"P_wr_congruent_SOA_8";"P_wr_congruent_SOA_8";"P_wr_congruent_SOA_12";"P_wr_congruent_SOA_12";
"P_wr_congruent_SOA_16";"P_wr_congruent_SOA_16";"P_wr_congruent_SOA_20";"P_wr_congruent_SOA_20";      };
     };
     int_Data @[8] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cur_trialtype_num";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [84] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;3;3;3;3;3;3;3;
3;3;3;3;3;3;3;3;3;3;
3;3;3;3;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=1;
      val_type_fixed=0;
     };
     UserDataItem @[1] {
      name="MAT_VAL_TEXT";
      value 2 0=1;
      val_type_fixed=0;
     };
     UserDataItem @[2] {
      name="WIDTH";
      value 6 0=3.299999952316284;
      val_type_fixed=0;
     };
    };
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Colors";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 1] "g";"r";      };
     };
     String_Data @[1] {
      name="Words";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 1] "G";"R";      };
     };
     String_Data @[2] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 1] "gr";"rd";      };
     };
     String_Data @[3] {
      name="PFC";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 1] "cn";"wr";      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable_Group @.gp[0] {
    name="old";
    el_typ=DataTable;
    el_def=0;
    DataTable @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="N_ROWS";
       value 2 0=5;
       val_type_fixed=0;
      };
     };
     name="Test_WordRead";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [3] "Word_Ctrl";"Word_Conf";"Word_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;0;1;0;0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;1;0;1;0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;1;0;1;0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;1;0;1;0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="N_ROWS";
       value 2 0=5;
       val_type_fixed=0;
      };
     };
     name="Test_ColorName";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [3] "Color_Ctrl";"Color_Conf";"Color_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;1;0;1;0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;0;1;0;0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 0;1;0;1;0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 3] 1;0;1;0;1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[2] {
     name="Word_C_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_C_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[3] {
     name="Word_C_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_C_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[4] {
     name="Word_B_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_B_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[5] {
     name="Word_B_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_B_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[6] {
     name="Word_W_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_W_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[7] {
     name="Word_W_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Word_W_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[8] {
     name="Color_C_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_C_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[9] {
     name="Color_C_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_C_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[10] {
     name="Color_B_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_B_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[11] {
     name="Color_B_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_B_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[12] {
     name="Color_W_Conf";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_W_Conf";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
    DataTable @[13] {
     name="Color_W_Cong";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @[0] {
       name="Name";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [0]        };
       ar {
	name=;
	      [1] "Color_W_Cong";       };
      };
      float_Data @[1] {
       name="Colors";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;0;       };
      };
      float_Data @[2] {
       name="Words";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[3] {
       name="Output";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 0;1;       };
      };
      float_Data @[4] {
       name="PFC";
       col_flags=SAVE_ROWS|SAVE_DATA;
       is_matrix=1;
       cell_geom{ 2;1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name=;
	      [2] ;;       };
       ar {
	name=;
	      [2 1 1] 1;0;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
    };
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[9] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial_mod";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[10] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial_div";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      name="Output_act_m";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [2 1 0]       };
     };
     String_Data @[12] {
      name="trial_type";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="SOATestTrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[9] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="SOA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[10] {
      name="max_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[11] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cur_trialtype_num";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[2] {
    name="SOATestCycleOutputData";
    desc="mainly for debugging";
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[8] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="SOA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      name="max_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[10] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cycle";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      name="Hidden_g_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[12] {
      name="Hidden_r_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[13] {
      name="Hidden_G_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[14] {
      name="Hidden_R_net";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[15] {
      name="Hidden_g_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[16] {
      name="Hidden_r_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[17] {
      name="Hidden_G_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[18] {
      name="Hidden_R_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[3] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="SOATestTrialOutputDataFiltered";
    desc=;
    data {
     name="data";
     el_typ=DataColTp;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 60;60;60;60;60;60;60;60;60;60;
60;60;60;60;60;60;60;60;60;60;
60;60;60;60;60;60;60;60;60;60;
60;60;60;60;60;60;60;60;60;60;
60;60;60;60;      };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 1;1;1;1;1;0;1;1;1;1;
1;1;1;1;1;1;0;1;1;1;
1;1;1;1;1;1;1;0;1;1;
1;1;1;1;1;1;1;1;0;1;
1;1;1;1;      };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] "P_cn_W_G_latestim";"P_cn_W_G_latestim";"P_cn_W_G_latestim";"P_cn_W_G_latestim";"P_cn_W_G_latestim";"P_cn_Both_latestim";"P_cn_C_r_latestim";"P_cn_C_r_latestim";"P_cn_C_r_latestim";"P_cn_C_r_latestim";
"P_cn_C_r_latestim";"P_cn_W_R_latestim";"P_cn_W_R_latestim";"P_cn_W_R_latestim";"P_cn_W_R_latestim";"P_cn_W_R_latestim";"P_cn_Both_latestim";"P_cn_C_r_latestim";"P_cn_C_r_latestim";"P_cn_C_r_latestim";
"P_cn_C_r_latestim";"P_cn_C_r_latestim";"P_wr_C_g_latestim";"P_wr_C_g_latestim";"P_wr_C_g_latestim";"P_wr_C_g_latestim";"P_wr_C_g_latestim";"P_wr_Both_latestim";"P_wr_W_R_latestim";"P_wr_W_R_latestim";
"P_wr_W_R_latestim";"P_wr_W_R_latestim";"P_wr_W_R_latestim";"P_wr_C_r_latestim";"P_wr_C_r_latestim";"P_wr_C_r_latestim";"P_wr_C_r_latestim";"P_wr_C_r_latestim";"P_wr_Both_latestim";"P_wr_W_R_latestim";
"P_wr_W_R_latestim";"P_wr_W_R_latestim";"P_wr_W_R_latestim";"P_wr_W_R_latestim";      };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;      };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;1;1;      };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 170;169;168;167;166;165;155;146;137;130;
123;118;121;124;126;129;132;129;126;123;
120;116;101;103;105;107;109;112;108;104;
100;96;92;101;103;105;107;109;112;108;
104;100;96;92;      };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;      };
     };
     int_Data @[9] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="SOA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] -20;-16;-12;-8;-4;0;4;8;12;16;
20;-20;-16;-12;-8;-4;0;4;8;12;
16;20;-20;-16;-12;-8;-4;0;4;8;
12;16;20;-20;-16;-12;-8;-4;0;4;
8;12;16;20;      };
     };
     float_Data @[10] {
      name="max_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 200;200;200;200;200;200;200;200;200;200;
200;200;200;200;200;200;200;200;200;200;
200;200;200;200;200;200;200;200;200;200;
200;200;200;200;200;200;200;200;200;200;
200;200;200;200;      };
     };
     int_Data @[11] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="cur_trialtype_num";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [44] 0;0;0;0;0;0;0;0;0;0;
0;1;1;1;1;1;1;1;1;1;
1;1;2;2;2;2;2;2;2;2;
2;2;2;3;3;3;3;3;3;3;
3;3;3;3;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program_Group @.gp[0] {
   name="Training";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=.projects[0].networks[0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[0][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][1]$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=60;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="max_cycles_train";
      var_type=T_Int;
      int_val=60;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of cycles to settle for";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trg_max_act_stopcrit";
      var_type=T_Real;
      real_val=1;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stop settling if max of target act exceeds this value";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="maxda_stopcrit";
      var_type=T_Real;
      real_val=0.005;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stop settling if max of target act exceeds this value";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch";
      var_type=T_Int;
      int_val=60;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][1].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=-1;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][1].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="i";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[11] {
      name="curlayer";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=.projects[0].networks[0].layers[4]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[12] {
      name="LayerSpec_0";
      var_type=T_Object;
      object_type=LeabraLayerSpec;
      object_val=.projects[0].networks[0].specs[2]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[9]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[8]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[8]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
     ForLoop @[5] {
      desc="set each layer unit spec to train config (just for vm dt to be reasonable)";
      flags=NON_STD;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MemberAssign @[0] {
	desc=;
	flags=OFF|NON_STD;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	path="layers[i].unit_spec.spec";
	expr {
	 expr=".specs.TrainUnitSpec";
	};
	update_after=0;
       };
       AssignExpr @[1] {
	desc="assign the layer to the pointer";
	flags=NON_STD;
	result_var=.projects[0].programs.gp[0][1].vars[11]$$;
	expr {
	 expr="network.layers[i]";
	};
       };
       MethodCall @[2] {
	desc="assign the appropriate unit spec";
	flags=NON_STD;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[11]$;
	method=LeabraLayer::SetUnitSpec;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=UnitSpec_ptr;
	  type="UnitSpec*";
	  name="unitspec";
	  required=1;
	  def_val=;
	  expr {
	   expr=".TrainUnitSpec";
	  };
	 };
	};
       };
       PrintExpr @[3] {
	desc="print message to console about what we're doing";
	flags=OFF|NON_STD;
	expr {
	 expr="\"curlayer.name \" << curlayer.name << \" spec: \" << curlayer.unit_spec.spec.name";
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.size";
      };
      iter {
       expr="i++";
      };
     };
     Comment @[6] {
      desc="set network vars that control processing";
      flags=NON_STD;
     };
     MemberAssign @[7] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="cycle_max";
      expr {
       expr="max_cycles_train";
      };
      update_after=0;
     };
     MemberAssign @[8] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="trg_max_act_stopcrit";
      expr {
       expr="trg_max_act_stopcrit";
      };
      update_after=0;
     };
     MemberAssign @[9] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="maxda_stopcrit";
      expr {
       expr="maxda_stopcrit";
      };
      update_after=0;
     };
     Comment @[10] {
      desc="assign appropriate decay states on layerspec";
      flags=NON_STD;
     };
     AssignExpr @[11] {
      desc=;
      flags=NON_STD;
      result_var=.projects[0].programs.gp[0][1].vars[12]$$;
      expr {
       expr="network.specs.LayerSpec_0";
      };
     };
     MemberAssign @[12] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].vars[12]$;
      path="decay.event";
      expr {
       expr="1";
      };
      update_after=0;
     };
     MemberAssign @[13] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[0][1].vars[12]$;
      path="decay.phase";
      expr {
       expr="1";
      };
      update_after=0;
     };
     MethodCall @[14] {
      desc="updates children";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[12]$;
      method=taBase::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     PrintExpr @[15] {
      desc="print message to console about what we're doing";
      flags=OFF|NON_STD;
      expr {
       expr="\"Init from LeabraTrain results in: \" << endl <<
\"\\tunit spec: \" << curlayer.unit_spec.spec.name << endl <<
\"\\tnetwork.max_cycle: \" << network.cycle_max << endl <<
\"\\tnetwork.trg_max_act_stopcrit: \" << network.trg_max_act_stopcrit << endl <<
\"\\tnetwork.maxda_stopcrit: \" << network.maxda_stopcrit << endl <<
\"\\tlayerspec.decay.event: \" <<  LayerSpec_0.decay.event << endl << 
\"\\tlayerspec.decay.phase: \" <<  LayerSpec_0.decay.phase << endl";
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[9]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[9]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     IfElse @[3] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     AssignExpr @[4] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[4]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[5] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[4]$;
	counter=Network::epoch;
	update_after=1;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[6] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[9]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][2].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][2].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[4] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][2].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[0].programs.gp[0][2].args[1]$$;
      index_var=.projects[0].programs.gp[0][2].vars[4]$$;
      order_var=.projects[0].programs.gp[0][2].vars[0]$$;
      order=SEQUENTIAL;
      item_idx_list{ 0;1;2;3;4;5;6;7;8;9;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[7] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     MethodCall @[8] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][4]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[5] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][4].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][4].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][5]$$;
	targ_ld_init="*LeabraCycle*";
       };
       PrintExpr @[1] {
	desc="help to debug issues with stopcrit / maxda";
	flags=OFF;
	expr {
	 expr="\"phase: \" << network.phase << \"cycle: \" << cycle << \", maxda: \" << network.maxda << \", stopcrit: \" << network.maxda_stopcrit";
	};
       };
       NetCounterIncr @[2] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[3] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[4] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][5].args[0]$;
      update_var=.projects[0].programs.gp[0][5].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Colors";
	net_target=LAYER;
	layer_name="Colors";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Words";
	net_target=LAYER;
	layer_name="Words";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="PFC";
	net_target=LAYER;
	layer_name="PFC";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[4] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="trial_mod";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="trial_div";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="Output_act_m";
	computed=0;
	object_type=LeabraLayer;
	object=.projects[0].networks[0].layers[3]$$;
	variable="act_m";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="trial_type";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_STRING;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mod";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial %3 -- for plotting test and simplifying progs for test (represents the trial type: cntrl, conf, or cong)";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_div";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial /3 -- for plotting test and simplifying progs for test; represents trial task (word reading or color naming)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="trial_type";
      var_type=T_String;
      string_val="Cong";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial type (ctrl, conflict, congruent)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="num_conds";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="mod and div trial by this number to get appropriate plotting (should just be 3 by default, but if testing data table changes, then that could change)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     Comment @[2] {
      desc="kind of \"grouping\"  thing -- get similar functionality out of NetGroupedData, but just need it for testing, so just do it here";
      flags=;
     };
     AssignExpr @[3] {
      desc="get a counter for plotting";
      flags=NON_STD;
      result_var=.projects[0].programs.gp[0][7].vars[2]$$;
      expr {
       expr="network.trial % num_conds";
      };
     };
     AssignExpr @[4] {
      desc="create a different counter for plotting";
      flags=NON_STD;
      result_var=.projects[0].programs.gp[0][7].vars[3]$$;
      expr {
       expr="network.trial / num_conds";
      };
     };
     AssignExpr @[5] {
      desc="create a different counter for plotting";
      flags=NON_STD;
      result_var=.projects[0].programs.gp[0][7].vars[4]$$;
      expr {
       expr="network.trial_name.after(\"_\")";
      };
     };
     DataVarProg @[6] {
      desc=;
      flags=NON_STD;
      data_var=$.projects[0].programs.gp[0][7].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=1;
      var_1=$.projects[0].programs.gp[0][7].vars[2]$;
      var_2=$.projects[0].programs.gp[0][7].vars[3]$;
      var_3=$.projects[0].programs.gp[0][7].vars[4]$;
      var_4=NULL;
     };
     MethodCall @[7] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][3]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][3]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][8].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$.projects[0].programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val="hebb=0.1";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val="/Users/jrr/svn_sims/cecn/new_v4/chapter_11/stroophebb=0.1.00_0060.wts.gz";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0060";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="00";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val="hebb=0.1.00_0060";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[2]$$;
      obj=.projects[0].programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[1] {
   name="Testing";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraTestSOA";
    short_nm="TstSOA";
    tags="Leabra, Std";
    desc="Test the SOAs";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
     DynEnumType @[1] {
      name="TaskTypes";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="P_cn";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="P_wr";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[2] {
      name="TrialTypes";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="conflict";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="congruent";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[0][2]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[1][0].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="curTrialType";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[2]$$;
       value=1;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="curTask";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[1]$$;
       value=1;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="i";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used to loop over layers in int";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="max_cycles_test";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of cycles to settle for";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="trg_max_act_stopcrit";
      var_type=T_Real;
      real_val=0.5;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stop settling if max of target act exceeds this value";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="maxda_stopcrit";
      var_type=T_Real;
      real_val=-1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stop settling if da is lower than this number";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="curlayer";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=$.projects[0].networks[0].layers[4]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used to set unitspec";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="LayerSpec_0";
      var_type=T_Object;
      object_type=LeabraLayerSpec;
      object_val=$.projects[0].networks[0].specs[2]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used to set decay states";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][0].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     ForLoop @[1] {
      desc="set each layer unit spec to test config (just for vm dt to be good for testing)";
      flags=NON_STD;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="assign the layer to the pointer";
	flags=NON_STD;
	result_var=.projects[0].programs.gp[1][0].vars[9]$$;
	expr {
	 expr="network.layers[i]";
	};
       };
       MethodCall @[1] {
	desc="assign the appropriate unit spec";
	flags=NON_STD;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][0].vars[9]$;
	method=LeabraLayer::SetUnitSpec;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=UnitSpec_ptr;
	  type="UnitSpec*";
	  name="unitspec";
	  required=1;
	  def_val=;
	  expr {
	   expr=".TestUnitSpec";
	  };
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.size";
      };
      iter {
       expr="i++";
      };
     };
     Comment @[2] {
      desc="set network vars that control processing";
      flags=NON_STD;
     };
     MemberAssign @[3] {
      desc="assign network var to max_cycles_test (this is overwritten later)";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][0].args[0]$;
      path="cycle_max";
      expr {
       expr="max_cycles_test";
      };
      update_after=0;
     };
     MemberAssign @[4] {
      desc="assign the number to the network var";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][0].args[0]$;
      path="maxda_stopcrit";
      expr {
       expr="maxda_stopcrit";
      };
      update_after=0;
     };
     MemberAssign @[5] {
      desc="set what you want the threshold of response to be";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][0].args[0]$;
      path="trg_max_act_stopcrit";
      expr {
       expr="trg_max_act_stopcrit";
      };
      update_after=0;
     };
     Comment @[6] {
      desc="assign appropriate decay states on layerspec";
      flags=NON_STD;
     };
     AssignExpr @[7] {
      desc=;
      flags=NON_STD;
      result_var=.projects[0].programs.gp[1][0].vars[10]$$;
      expr {
       expr="network.specs.LayerSpec_0";
      };
     };
     MemberAssign @[8] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][0].vars[10]$;
      path="decay.event";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MemberAssign @[9] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][0].vars[10]$;
      path="decay.phase";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MethodCall @[10] {
      desc="need to do this to update children (could also do updatechildren)";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][0].vars[10]$;
      method=taBase::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     PrintExpr @[11] {
      desc="print message to console about what we're doing";
      flags=OFF|NON_STD;
      expr {
       expr="\"Init from LeabraTestSOA results in: \" << endl <<
\"\\tunit spec: \" << curlayer.unit_spec.spec.name << endl <<
\"\\tnetwork.max_cycle: \" << network.cycle_max << endl <<
\"\\tnetwork.trg_max_act_stopcrit: \" << network.trg_max_act_stopcrit << endl <<
\"\\tnetwork.maxda_stopcrit: \" << network.maxda_stopcrit << endl <<
\"\\tlayerspec.decay.event: \" <<  LayerSpec_0.decay.event << endl << 
\"\\tlayerspec.decay.phase: \" <<  LayerSpec_0.decay.phase << endl";
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MemberAssign @[0] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[1][0].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     ProgramCall @[1] {
      desc="run the epoch program (one epoch), passes our network and input_data";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[1][1]$$;
      targ_ld_init="*LeabraEpochGpData*";
     };
     ProgramCall @[2] {
      desc="processes the data so you can plot the RT to the late stimulus";
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      target=.projects[0].programs.gp[3][0]$$;
      targ_ld_init="*GetData*";
     };
    };
    step_prog=.projects[0].programs.gp[1][4]$$;
    step_n=1;
   };
   Program @[1] {
    name="LeabraEpochGpDataSOATest";
    short_nm="SOAEpcTst";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][2]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="item_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][1]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- if we want to reset it every epoch";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="group_index";
      var_type=T_Int;
      int_val=44;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="group number";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="item_index";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="item within the group";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="SOA";
      var_type=T_Real;
      real_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="SOA, set from datatable";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="max_cycles";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="max_cycles to settle, set from datatable";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="cur_trialtype_num";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="cur_trialtype_num, set from datatable (only needed for plotting)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter: note also needs to do this in regular running program";
      flags=;
      network_var=.projects[0].programs.gp[1][1].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][1].vars[2]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[1][1].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter";
      flags=;
      network_var=$.projects[0].programs.gp[1][1].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][1].vars[2]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[1][1].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][1].vars[3]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetGroupedDataLoop @[4] {
      desc="iterates over groups and items within groups";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       IfElse @[0] {
	desc="init activities at the beginning of a group";
	flags=NON_STD;
	cond {
	 expr="item_index==0";
	};
	true_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 MethodCall @[0] {
	  desc="init activities between SOA trials";
	  flags=NON_STD;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[1][1].args[0]$;
	  method=Network::Init_Acts;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
       DataVarProg @[1] {
	desc="get these vars from the input to set in the trialMon";
	flags=NON_STD;
	data_var=.projects[0].programs.gp[1][1].args[1]$$;
	set_data=0;
	row_spec=CUR_ROW;
	row_var=NULL;
	quiet=1;
	var_1=.projects[0].programs.gp[1][1].vars[7]$$;
	var_2=.projects[0].programs.gp[1][1].vars[8]$$;
	var_3=.projects[0].programs.gp[1][1].vars[9]$$;
	var_4=NULL;
       };
       OtherProgramVar @[2] {
	desc="assign these to the trial mon to keep in the output";
	flags=NON_STD;
	other_prog=.projects[0].programs.gp[1][8]$$;
	set_other=1;
	var_1=$.projects[0].programs.gp[1][1].vars[7]$;
	var_2=$.projects[0].programs.gp[1][1].vars[8]$;
	var_3=$.projects[0].programs.gp[1][1].vars[9]$;
	var_4=NULL;
       };
       MemberAssign @[3] {
	desc="set the max number of cycles from the var gotten from the datatable";
	flags=NON_STD;
	obj=$.projects[0].programs.gp[1][1].args[0]$;
	path="cycle_max";
	expr {
	 expr="max_cycles";
	};
	update_after=0;
       };
       ProgramCall @[4] {
	desc="call the trial process";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.projects[0].programs.gp[1][4]$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[5] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[1][1].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=$.projects[0].programs.gp[1][1].args[1]$;
      group_index_var=.projects[0].programs.gp[1][1].vars[5]$$;
      item_index_var=.projects[0].programs.gp[1][1].vars[6]$$;
      group_order_var=.projects[0].programs.gp[1][1].vars[0]$$;
      item_order_var=.projects[0].programs.gp[1][1].vars[1]$$;
      group_order=SEQUENTIAL;
      item_order=SEQUENTIAL;
      group_col=7;
      update_after=0;
      group_idx_list{ 0;2;4;6;8;10;11;13;15;17;19;21;23;25;27;29;31;32;34;36;38;40;42;44;46;48;50;52;53;55;57;59;61;63;65;67;69;71;73;74;76;78;80;82;      };
      item_idx_list{ 82;83;      };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][1].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][1].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[8] {
      desc="call the epoch monitor";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[1][10]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraBasicTest_NEpoch";
    short_nm="NEpcTst";
    tags="Leabra, Std";
    desc="Tests the network over the 6 trials of interest (cntrl, conflict, congruent for word reading and color naming)";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[0][1]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_test_epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="test_epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][2].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[1][2].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="test_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].train_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="max_cycles_test";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of cycles to settle for";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="trg_max_act_stopcrit";
      var_type=T_Real;
      real_val=0.5;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stop settling if max of target act exceeds this value";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="epoch";
      var_type=T_Int;
      int_val=62;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="epoch from network";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="curlayer";
      var_type=T_Object;
      object_type=LeabraLayer;
      object_val=$.projects[0].networks[0].layers[4]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="layer pointer used in init prog to set unit specs";
      init_from=NULL;
     };
     ProgVar @[11] {
      name="LayerSpec_0";
      var_type=T_Object;
      object_type=LeabraLayerSpec;
      object_val=$.projects[0].networks[0].specs[2]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="layerspec pointer used to set decay states";
      init_from=NULL;
     };
     ProgVar @[12] {
      name="maxda_stopcrit";
      var_type=T_Real;
      real_val=-1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used to set stopping criteria on network in init";
      init_from=NULL;
     };
     ProgVar @[13] {
      name="i";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used to loop over layers in init";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][2].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     IfElse @[1] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][2].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][2].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     ForLoop @[2] {
      desc="set each layer unit spec to test config (just for vm dt to be good for testing)";
      flags=NON_STD;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MemberAssign @[0] {
	desc=;
	flags=OFF|NON_STD;
	obj=$.projects[0].programs.gp[1][2].args[0]$;
	path="layers[i].unit_spec.spec";
	expr {
	 expr=".specs.TestUnitSpec";
	};
	update_after=0;
       };
       AssignExpr @[1] {
	desc="assign the layer to the pointer";
	flags=NON_STD;
	result_var=.projects[0].programs.gp[1][2].vars[10]$$;
	expr {
	 expr="network.layers[i]";
	};
       };
       MethodCall @[2] {
	desc="assign the appropriate unit spec";
	flags=NON_STD;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][2].vars[10]$;
	method=LeabraLayer::SetUnitSpec;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=UnitSpec_ptr;
	  type="UnitSpec*";
	  name="unitspec";
	  required=1;
	  def_val=;
	  expr {
	   expr=".TestUnitSpec";
	  };
	 };
	};
       };
       PrintExpr @[3] {
	desc="print message to console about what we're doing";
	flags=OFF|NON_STD;
	expr {
	 expr="\"curlayer.name \" << curlayer.name << \" spec: \" << curlayer.unit_spec.spec.name";
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.size";
      };
      iter {
       expr="i++";
      };
     };
     Comment @[3] {
      desc="set network vars that control processing";
      flags=NON_STD;
     };
     MemberAssign @[4] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      path="cycle_max";
      expr {
       expr="max_cycles_test";
      };
      update_after=0;
     };
     MemberAssign @[5] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      path="trg_max_act_stopcrit";
      expr {
       expr="trg_max_act_stopcrit";
      };
      update_after=0;
     };
     MemberAssign @[6] {
      desc=;
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      path="maxda_stopcrit";
      expr {
       expr="maxda_stopcrit";
      };
      update_after=0;
     };
     Comment @[7] {
      desc="assign appropriate decay states on layerspec";
      flags=NON_STD;
     };
     AssignExpr @[8] {
      desc=;
      flags=NON_STD;
      result_var=.projects[0].programs.gp[1][2].vars[11]$$;
      expr {
       expr="network.specs.LayerSpec_0";
      };
     };
     MemberAssign @[9] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][2].vars[11]$;
      path="decay.event";
      expr {
       expr="1";
      };
      update_after=0;
     };
     MemberAssign @[10] {
      desc="1 == init_state, 0 == do_nothing";
      flags=NON_STD;
      obj=$.projects[0].programs.gp[1][2].vars[11]$;
      path="decay.phase";
      expr {
       expr="1";
      };
      update_after=0;
     };
     MethodCall @[11] {
      desc="updates children";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][2].vars[11]$;
      method=taBase::UpdateAfterEdit;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     PrintExpr @[12] {
      desc="print message to console about what we're doing";
      flags=OFF|NON_STD;
      expr {
       expr="\"Init from BasicTest_NEpoch results in: \" << endl <<
\"\\tunit spec: \" << curlayer.unit_spec.spec.name << endl <<
\"\\tnetwork.max_cycle: \" << network.cycle_max << endl <<
\"\\tnetwork.trg_max_act_stopcrit: \" << network.trg_max_act_stopcrit << endl <<
\"\\tnetwork.maxda_stopcrit: \" << network.maxda_stopcrit << endl <<
\"\\tlayerspec.decay.event: \" <<  LayerSpec_0.decay.event << endl << 
\"\\tlayerspec.decay.phase: \" <<  LayerSpec_0.decay.phase << endl";
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[1][2].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     MemberAssign @[1] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[1][2].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     AssignExpr @[2] {
      desc="init test_epoch var to keep track of what the current epoch is";
      flags=;
      result_var=.projects[0].programs.gp[1][2].vars[1]$$;
      expr {
       expr="0";
      };
     };
     WhileLoop @[3] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][3]$$;
	targ_ld_init="*LeabraEpochTest*";
       };
       VarIncr @[1] {
	desc=;
	flags=;
	var=$.projects[0].programs.gp[1][2].vars[1]$;
	expr {
	 expr="1";
	};
       };
      };
      test {
       expr="test_epoch < max_test_epoch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraEpochTest";
    short_nm="EpcTst";
    tags="Leabra, Std";
    desc="this is different than TrainEpoch, because of sequential presentation, but it can call all the training stuff;";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=6;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[1][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][3].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[1][3].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[1][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][3].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[1][3].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][3].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[4] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.projects[0].programs.gp[1][4]$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[1][3].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[0].programs.gp[1][3].args[1]$$;
      index_var=.projects[0].programs.gp[1][3].vars[4]$$;
      order_var=.projects[0].programs.gp[1][3].vars[0]$$;
      order=SEQUENTIAL;
      item_idx_list{ 0;1;2;3;4;5;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][3].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][3].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraTrialTest";
    short_nm="TrlTst";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="SOATestCycleOutputData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[1][2]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[1][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][4].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[1][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][4].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=1;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][4].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[2] {
      desc=;
      flags=;
      cond {
       expr="input_data.name.contains(\"SOA\")";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ResetDataRows @[0] {
	desc="resets the cycle log";
	flags=NON_STD;
	data_var=.projects[0].programs.gp[1][4].vars[2]$$;
       };
      };
     };
     WhileLoop @[3] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][5]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[1][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[1][4].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=1;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][4].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[4] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][4].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[5] {
      desc=;
      flags=;
      cond {
       expr="input_data.name.contains(\"SOA\")";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="records data about the trial-level processing to a datatable for graphing/processing";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects[0].programs.gp[1][8]$;
	targ_ld_init="*LeabraTrialMonitor*";
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="records data about the trial-level processing to a datatable for graphing/processing";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][7]$;
	targ_ld_init="*LeabraTrialMonitor*";
       };
      };
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[1][4].args[0]$;
      update_var=.projects[0].programs.gp[1][4].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraSettleTest";
    short_nm="SttTst";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=132;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[1][5].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[1][5].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[1][5].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[1][5].vars[0]$;
      counter=Network::cycle;
      update_after=1;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[1][7]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[1][5].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[1][5].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][6]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[1][5].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[1][5].vars[0]$;
	counter=Network::cycle;
	update_after=1;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][5].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][5].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[1][5].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[1][5].args[0]$;
      update_var=.projects[0].programs.gp[1][5].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="LeabraCycleTest";
    short_nm="CycTst";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][6].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[1] {
      desc=;
      flags=;
      cond {
       expr="input_data.name.contains(\"SOA\")";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="monitors variables over each cycle period, reset each trial (could be phase, but this is a test, so doesn't matter)";
	flags=NON_STD;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=Network;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[1][9]$$;
	targ_ld_init="*LeabraCycleMonitor*";
       };
      };
     };
     NetUpdateView @[2] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[1][6].args[0]$;
      update_var=$.projects[0].programs.gp[1][6].vars[0]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][1]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Colors";
	net_target=LAYER;
	layer_name="Colors";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Words";
	net_target=LAYER;
	layer_name="Words";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="PFC";
	net_target=LAYER;
	layer_name="PFC";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[4] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[1][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][7].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][7].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraTrialMonitorSOA";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="SOA";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="max_cycles";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="cur_trialtype_num";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][1]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[1][8].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="SOA";
      var_type=T_Real;
      real_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="max_cycles";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="cur_trialtype_num";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     DataVarProg @[2] {
      desc="set these based on the values gotten from the input (via the epochGp Prog)";
      flags=NON_STD;
      data_var=$.projects[0].programs.gp[1][8].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=0;
      var_1=.projects[0].programs.gp[1][8].vars[2]$$;
      var_2=.projects[0].programs.gp[1][8].vars[3]$$;
      var_3=.projects[0].programs.gp[1][8].vars[4]$$;
      var_4=NULL;
     };
     MethodCall @[3] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[4] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][8].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="LeabraCycleMonitorSOA";
    short_nm="CycMnt";
    tags=;
    desc="monitors vars in the cycle process, useful for seeing initial conditions";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="cycle";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cycle";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="SOA";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_INT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="max_cycles";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="Hidden_g_net";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="Hidden_r_net";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[13] {
	name="Hidden_G_net";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[14] {
	name="Hidden_R_net";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="net";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[15] {
	name="Hidden_g_act";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[16] {
	name="Hidden_r_act";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[17] {
	name="Hidden_G_act";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[18] {
	name="Hidden_R_act";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][2]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][2]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[1][9].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][9].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][9].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     Comment @[2] {
      desc="keep track of net and act of hidden layer";
      flags=NON_STD;
     };
     MethodCall @[3] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[0][0].net";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_g_net\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[0][0].act";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_g_act\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[0][1].net";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_r_net\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[6] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[0][1].act";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_r_act\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[7] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[1][0].net";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_G_net\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[8] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[1][0].act";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_G_act\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[9] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[1][1].net";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_R_net\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[10] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.Hidden.units.gp[1][1].act";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"Hidden_R_act\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[11] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][9].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[12] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][9].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[10] {
    name="LeabraEpochMonitorSOA";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][3]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][3]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[1][10].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[1][10].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][10].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[1][10].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$.projects[0].programs.gp[1][10].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][10].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[2] {
   name="Environments";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   Program @[0] {
    name="MakeTrainEnv";
    short_nm="MTrnnv";
    tags=;
    desc="makes the training environment based on frequency arguments. Total number of trials is 2*(ReadFreq+ColorNameFreq).

Also has InitNamedUnits and access to TrainEnv and TestEnv in case you need to make the DataLegends again";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="N_ROWS";
	value 2 0=5;
	val_type_fixed=0;
       };
      };
      name="StimFrequencies";
      desc="this was the original datatable that was imported -- copied here, added frequencies to replicate to make actual training env.";
      data {
       name="data";
       el_typ=String_Data;
       el_def=0;
       String_Data @[0] {
	name="Name";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[4] "Gw";"Rw";"gc";"rc";	};
       };
       float_Data @[1] {
	name="Colors";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=1;
	cell_geom{ 2;1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[2] ;;	};
	ar {
	 name=;
		[2 1 4] 0;0;0;0;1;0;0;1;	};
       };
       float_Data @[2] {
	name="Words";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=1;
	cell_geom{ 2;1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[2] ;;	};
	ar {
	 name=;
		[2 1 4] 1;0;0;1;0;0;0;0;	};
       };
       float_Data @[3] {
	name="Output";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=1;
	cell_geom{ 2;1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[2] ;;	};
	ar {
	 name=;
		[2 1 4] 1;0;0;1;1;0;0;1;	};
       };
       float_Data @[4] {
	name="PFC";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=1;
	cell_geom{ 2;1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[2] ;;	};
	ar {
	 name=;
		[2 1 4] 0;1;0;1;1;0;1;0;	};
       };
       float_Data @[5] {
	name="frequency";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[4] 3;3;2;2;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="ReadFreq";
      var_type=T_Real;
      real_val=3;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="make this a frequency (e.g. an N)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="ColorNameFreq";
      var_type=T_Real;
      real_val=2;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="this is a frequency (e.g. an N)";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="StimFrequencies";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].programs.gp[2][0].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to original datatable with frequency information";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="frequency";
      var_type=T_Real;
      real_val=2;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="need this to assign frequency to the datatable via DataVarProg";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="rownum";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="needed to assign the correct frequency to the appropriate condition";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="TrainEnv";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      object_val=.projects[0].data.gp[0][3]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="Test_Env";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][1]$;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="just here to make a legend via InitNamedUnits";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     InitNamedUnits @[0] {
      desc=;
      flags=;
      input_data_var=.projects[0].programs.gp[2][0].vars[3]$$;
      unit_names_var=.projects[0].programs.gp[2][0].vars[4]$$;
      network_var=.projects[0].programs.gp[2][0].vars[6]$$;
      n_lay_name_chars=1;
      max_unit_chars=-1;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     Comment @[0] {
      desc="assign the appropriate frequencies based on the args, first do the reading frequencies";
      flags=;
     };
     AssignExpr @[1] {
      desc="get the frequency for the reading trials";
      flags=;
      result_var=.projects[0].programs.gp[2][0].vars[1]$$;
      expr {
       expr="ReadFreq";
      };
     };
     AssignExpr @[2] {
      desc="set rownum to the first row to assign green word reading unit frequency";
      flags=;
      result_var=.projects[0].programs.gp[2][0].vars[2]$$;
      expr {
       expr="0";
      };
     };
     DataVarProg @[3] {
      desc="assign green word reading frequency";
      flags=;
      data_var=.projects[0].programs.gp[2][0].vars[0]$$;
      set_data=1;
      row_spec=ROW_NUM;
      row_var=$.projects[0].programs.gp[2][0].vars[2]$;
      quiet=0;
      var_1=$.projects[0].programs.gp[2][0].vars[1]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     AssignExpr @[4] {
      desc="set rownum to the second row to assign red word reading unit frequency";
      flags=;
      result_var=$.projects[0].programs.gp[2][0].vars[2]$;
      expr {
       expr="1";
      };
     };
     DataVarProg @[5] {
      desc="assign red word reading frequency";
      flags=;
      data_var=$.projects[0].programs.gp[2][0].vars[0]$;
      set_data=1;
      row_spec=ROW_NUM;
      row_var=$.projects[0].programs.gp[2][0].vars[2]$;
      quiet=0;
      var_1=$.projects[0].programs.gp[2][0].vars[1]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     Comment @[6] {
      desc="assign color naming frequencies";
      flags=;
     };
     AssignExpr @[7] {
      desc="get the frequency for the  color naming trials";
      flags=;
      result_var=$.projects[0].programs.gp[2][0].vars[1]$;
      expr {
       expr="ColorNameFreq";
      };
     };
     AssignExpr @[8] {
      desc="set rownum to the third row to assign green color naming unit frequency";
      flags=;
      result_var=$.projects[0].programs.gp[2][0].vars[2]$;
      expr {
       expr="2";
      };
     };
     DataVarProg @[9] {
      desc="assign green color naming frequency";
      flags=;
      data_var=$.projects[0].programs.gp[2][0].vars[0]$;
      set_data=1;
      row_spec=ROW_NUM;
      row_var=$.projects[0].programs.gp[2][0].vars[2]$;
      quiet=0;
      var_1=$.projects[0].programs.gp[2][0].vars[1]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     AssignExpr @[10] {
      desc="set rownum to the third row to assign red color naming unit frequency";
      flags=;
      result_var=$.projects[0].programs.gp[2][0].vars[2]$;
      expr {
       expr="3";
      };
     };
     DataVarProg @[11] {
      desc="assign red color naming frequency";
      flags=;
      data_var=$.projects[0].programs.gp[2][0].vars[0]$;
      set_data=1;
      row_spec=ROW_NUM;
      row_var=$.projects[0].programs.gp[2][0].vars[2]$;
      quiet=0;
      var_1=$.projects[0].programs.gp[2][0].vars[1]$;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     Comment @[12] {
      desc="do the replication to make the training environment";
      flags=;
     };
     DataGenCall @[13] {
      desc=;
      flags=;
      result_var=NULL;
      object_type=taDataGen;
      method=taDataGen::ReplicateByFrequency;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="repl_output";
	required=1;
	def_val=;
	expr {
	 expr="TrainEnv";
	};
       };
       ProgArg @[1] {
	arg_type=const_DataTable_ptr;
	type="const DataTable*";
	name="data_list_in";
	required=1;
	def_val=;
	expr {
	 expr="StimFrequencies";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="total_number";
	required=1;
	def_val=;
	expr {
	 expr="2*(ReadFreq+ColorNameFreq)";
	};
       };
       ProgArg @[3] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="freq_col_nm";
	required=0;
	def_val="frequency";
	expr {
	 expr=;
	};
       };
       ProgArg @[4] {
	arg_type=bool;
	type="bool";
	name="renorm_freqs";
	required=0;
	def_val="true";
	expr {
	 expr=;
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="MakeSOATestEnv";
    short_nm="MSTstn";
    tags=;
    desc="loops through and makes all SOAs of a particular trial type of a particular task";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=DataTable;
     el_def=0;
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="Colors";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="C_g";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="C_r";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[1] {
      name="Words";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="W_G";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="W_R";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[2] {
      name="Output";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="O_gr";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="O_rd";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[3] {
      name="PFC";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="P_cn";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="P_wr";
	value=1;
	desc=;
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="TrialType";
      var_type=T_String;
      string_val="congruent";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="congruent or conflict";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="TaskType";
      var_type=T_String;
      string_val="P_wr";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="Task type = P_cn or P_wr; same as the enums";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="cur_trialtype_num";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="just used for plotting, if your calling by itself, probably can just have any value";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="resetrows";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="whether to reset the rows in the datatable -- useful if calling on its own";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="env";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][2]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable to create";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      object_val=$.projects[0].data.gp[0][3]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="unit names for setting values";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="MinSOA_neg";
      var_type=T_Int;
      int_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="max number of cycles color precedes word info";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="MaxSOA";
      var_type=T_Int;
      int_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="max number of cycles word info can precede color info";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="SOAincr";
      var_type=T_Int;
      int_val=4;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="increment to adjust between groups";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="SOA";
      var_type=T_Int;
      int_val=24;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current SOA within the loop";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="i";
      var_type=T_Int;
      int_val=24;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="curColor";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[2][1].types[0]$$;
       value=1;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="color for current set of trials";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="curWord";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[2][1].types[1]$$;
       value=1;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="word value for current set of trials";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="curOutput";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[2][1].types[2]$$;
       value=1;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current output value, will alway be rd";
      init_from=NULL;
     };
     ProgVar @[11] {
      name="curPFC";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[2][1].types[3]$$;
       value=1;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current PFC value assigned to TaskType";
      init_from=NULL;
     };
     ProgVar @[12] {
      name="Name";
      var_type=T_String;
      string_val="P_wr_W_R_latestim";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial name for datatable";
      init_from=NULL;
     };
     ProgVar @[13] {
      name="Group";
      var_type=T_String;
      string_val="P_wr_congruent_SOA_20";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="group name for datatable";
      init_from=NULL;
     };
     ProgVar @[14] {
      name="max_cycles";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="max cycles for datatable";
      init_from=NULL;
     };
     ProgVar @[15] {
      name="max_cycles_test";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="maximum number of cycles to settle for on latestims";
      init_from=NULL;
     };
     ProgVar @[16] {
      name="name_tail";
      var_type=T_String;
      string_val="W_R";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string for constructing trial name";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     InitNamedUnits @[0] {
      desc="used to init dyn enums for setting units";
      flags=;
      input_data_var=.projects[0].programs.gp[2][1].vars[0]$$;
      unit_names_var=.projects[0].programs.gp[2][1].vars[1]$$;
      network_var=.projects[0].programs.gp[2][1].vars[2]$$;
      n_lay_name_chars=1;
      max_unit_chars=-1;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     IfElse @[0] {
      desc="reset the rows in the data table if you want to (useful for just going through one trial type, or if this is run on its own)";
      flags=;
      cond {
       expr="resetrows";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ResetDataRows @[0] {
	desc="reset the data rows";
	flags=;
	data_var=$.projects[0].programs.gp[2][1].vars[0]$;
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     Comment @[1] {
      desc="assign which units should be active by default";
      flags=;
     };
     AssignExpr @[2] {
      desc="assign the task to be performed from the arg";
      flags=;
      result_var=.projects[0].programs.gp[2][1].vars[11]$$;
      expr {
       expr="TaskType";
      };
     };
     AssignExpr @[3] {
      desc="the output is always O_rd";
      flags=;
      result_var=.projects[0].programs.gp[2][1].vars[10]$$;
      expr {
       expr="O_rd";
      };
     };
     AssignExpr @[4] {
      desc="init everything to red, and then check to see if it's a conflict trial";
      flags=;
      result_var=.projects[0].programs.gp[2][1].vars[9]$$;
      expr {
       expr="W_R";
      };
     };
     AssignExpr @[5] {
      desc="init everything to red, and then check to see if it's a conflict trial";
      flags=;
      result_var=.projects[0].programs.gp[2][1].vars[8]$$;
      expr {
       expr="C_r";
      };
     };
     IfElse @[6] {
      desc="set color or word pathway to green if it's a conflict trial based on the task";
      flags=;
      cond {
       expr="TrialType==\"conflict\"";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       IfElse @[0] {
	desc="if it's color naming, then assign word to W_G, if not, assign color to C_g";
	flags=;
	cond {
	 expr="curPFC==P_cn";
	};
	true_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=;
	  result_var=$.projects[0].programs.gp[2][1].vars[9]$;
	  expr {
	   expr="W_G";
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=;
	  result_var=$.projects[0].programs.gp[2][1].vars[8]$;
	  expr {
	   expr="C_g";
	  };
	 };
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     ForLoop @[7] {
      desc="loop over SOAs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="assign the Group";
	flags=;
	result_var=.projects[0].programs.gp[2][1].vars[13]$$;
	expr {
	 expr="(string)curPFC + \"_\" + TrialType + \"_SOA_\" + SOA";
	};
       };
       IfElse @[1] {
	desc="if SOA==0, then just assign name for the latestim and go to late stim part, if SOA!=0 add the early stim part";
	flags=;
	cond {
	 expr="SOA==0";
	};
	true_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AssignExpr @[0] {
	  desc="assign the Name for the late stim";
	  flags=;
	  result_var=.projects[0].programs.gp[2][1].vars[12]$$;
	  expr {
	   expr="(string)curPFC + \"_Both_latestim\" ";
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 AddNewDataRow @[0] {
	  desc="add a row for the early stimulus";
	  flags=;
	  data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	 };
	 IfElse @[1] {
	  desc="if SOA is smaller than 0and color naming trial OR SOA > 0 and word reading trial, present word first, otherwise present color first";
	  flags=;
	  cond {
	   expr="(SOA<0 && curPFC==P_cn) ||
(SOA>0 && curPFC==P_wr)";
	  };
	  true_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   SetUnitsVar @[0] {
	    desc="sets units for the first stimulus of negative SOA";
	    flags=;
	    input_data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	    set_nm=1;
	    offset=NULL;
	    unit_1=$.projects[0].programs.gp[2][1].vars[9]$;
	    unit_2=$.projects[0].programs.gp[2][1].vars[10]$;
	    unit_3=$.projects[0].programs.gp[2][1].vars[11]$;
	    unit_4=NULL;
	   };
	   AssignExpr @[1] {
	    desc="assign the Name_tail so it can be used later";
	    flags=;
	    result_var=.projects[0].programs.gp[2][1].vars[16]$$;
	    expr {
	     expr="(string)curWord";
	    };
	   };
	  };
	  false_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   SetUnitsVar @[0] {
	    desc="sets units for the first stimulus of positive SOA for color naming";
	    flags=;
	    input_data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	    set_nm=1;
	    offset=NULL;
	    unit_1=$.projects[0].programs.gp[2][1].vars[8]$;
	    unit_2=$.projects[0].programs.gp[2][1].vars[10]$;
	    unit_3=$.projects[0].programs.gp[2][1].vars[11]$;
	    unit_4=NULL;
	   };
	   AssignExpr @[1] {
	    desc="assign the Name_tail so it can be used later";
	    flags=;
	    result_var=$.projects[0].programs.gp[2][1].vars[16]$;
	    expr {
	     expr="(string)curColor";
	    };
	   };
	  };
	 };
	 AssignExpr @[2] {
	  desc="assign the Name for the early stimulus";
	  flags=;
	  result_var=$.projects[0].programs.gp[2][1].vars[12]$;
	  expr {
	   expr="(string)curPFC + \"_\" + name_tail + \"_earlystim\" ";
	  };
	 };
	 AssignExpr @[3] {
	  desc="assign the max_cycles for the early stimulus";
	  flags=;
	  result_var=.projects[0].programs.gp[2][1].vars[14]$$;
	  expr {
	   expr="fabs(SOA)";
	  };
	 };
	 DataVarProg @[4] {
	  desc="assigns the SOA, Name, Group, and max_cycles to the datatable for the early stim";
	  flags=;
	  data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	  set_data=1;
	  row_spec=CUR_ROW;
	  row_var=NULL;
	  quiet=0;
	  var_1=.projects[0].programs.gp[2][1].vars[6]$$;
	  var_2=$.projects[0].programs.gp[2][1].vars[12]$;
	  var_3=$.projects[0].programs.gp[2][1].vars[13]$;
	  var_4=$.projects[0].programs.gp[2][1].vars[14]$;
	 };
	 DataVarProg @[5] {
	  desc="assigns the trialtype num in the datatable -- this is used for plotting, otherwise isn't important";
	  flags=;
	  data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	  set_data=1;
	  row_spec=CUR_ROW;
	  row_var=NULL;
	  quiet=0;
	  var_1=.projects[0].programs.gp[2][1].args[2]$$;
	  var_2=NULL;
	  var_3=NULL;
	  var_4=NULL;
	 };
	 AssignExpr @[6] {
	  desc="assign the Name for the late stimulus";
	  flags=;
	  result_var=$.projects[0].programs.gp[2][1].vars[12]$;
	  expr {
	   expr="(string)curPFC + \"_\" + name_tail + \"_latestim\" ";
	  };
	 };
	};
       };
       AddNewDataRow @[2] {
	desc="adds late stim";
	flags=;
	data_var=$.projects[0].programs.gp[2][1].vars[0]$;
       };
       SetUnitsVar @[3] {
	desc="sets units for full stimulus ";
	flags=;
	input_data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	set_nm=1;
	offset=NULL;
	unit_1=$.projects[0].programs.gp[2][1].vars[9]$;
	unit_2=$.projects[0].programs.gp[2][1].vars[10]$;
	unit_3=$.projects[0].programs.gp[2][1].vars[11]$;
	unit_4=$.projects[0].programs.gp[2][1].vars[8]$;
       };
       AssignExpr @[4] {
	desc="assign the max_cycles";
	flags=;
	result_var=$.projects[0].programs.gp[2][1].vars[14]$;
	expr {
	 expr="max_cycles_test";
	};
       };
       DataVarProg @[5] {
	desc="assigns the SOA, name, group, and max_cycles to the datable for the late stim";
	flags=;
	data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	set_data=1;
	row_spec=CUR_ROW;
	row_var=NULL;
	quiet=0;
	var_1=$.projects[0].programs.gp[2][1].vars[6]$;
	var_2=$.projects[0].programs.gp[2][1].vars[12]$;
	var_3=$.projects[0].programs.gp[2][1].vars[13]$;
	var_4=$.projects[0].programs.gp[2][1].vars[14]$;
       };
       DataVarProg @[6] {
	desc="assigns the trialtype_num for the late stim, only used for plotting";
	flags=;
	data_var=$.projects[0].programs.gp[2][1].vars[0]$;
	set_data=1;
	row_spec=CUR_ROW;
	row_var=NULL;
	quiet=0;
	var_1=$.projects[0].programs.gp[2][1].args[2]$;
	var_2=NULL;
	var_3=NULL;
	var_4=NULL;
       };
      };
      init {
       expr="SOA= (MinSOA_neg*-1)";
      };
      test {
       expr="SOA <= MaxSOA";
      };
      iter {
       expr="SOA+=SOAincr";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="MakeSOATestEnvAll";
    short_nm="MSTstn";
    tags=;
    desc="calls MakeSOATestEnv to make all the trial types of both tasks";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][2]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="data table to make";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="MinSOA_neg";
      var_type=T_Int;
      int_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="max number of cycles color precedes word info";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="MaxSOA";
      var_type=T_Int;
      int_val=20;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="max number of cycles word info can precede color info";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="SOAincr";
      var_type=T_Int;
      int_val=4;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="increment to adjust between groups";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     OtherProgramVar @[0] {
      desc="assigns the SOA control parameters to the sub prog that actually does the work";
      flags=;
      other_prog=.projects[0].programs.gp[2][1]$$;
      set_other=0;
      var_1=.projects[0].programs.gp[2][2].vars[1]$$;
      var_2=.projects[0].programs.gp[2][2].vars[2]$$;
      var_3=.projects[0].programs.gp[2][2].vars[3]$$;
      var_4=NULL;
     };
     ProgramCall @[1] {
      desc="color naming conflict, since it's first, it also resets the rows of the datatable";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="TrialType";
	required=1;
	def_val=;
	expr {
	 expr="\"conflict\"";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="TaskType";
	required=1;
	def_val=;
	expr {
	 expr="\"P_cn\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="cur_trialtype_num";
	required=1;
	def_val=;
	expr {
	 expr="0";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="resetrows";
	required=1;
	def_val=;
	expr {
	 expr="true";
	};
       };
      };
      target=$.projects[0].programs.gp[2][1]$;
      targ_ld_init="*MakeSOATestEnv*";
     };
     ProgramCall @[2] {
      desc="color naming congruent";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="TrialType";
	required=1;
	def_val=;
	expr {
	 expr="\"congruent\"";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="TaskType";
	required=1;
	def_val=;
	expr {
	 expr="\"P_cn\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="cur_trialtype_num";
	required=1;
	def_val=;
	expr {
	 expr="1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="resetrows";
	required=1;
	def_val=;
	expr {
	 expr="false";
	};
       };
      };
      target=$.projects[0].programs.gp[2][1]$;
      targ_ld_init="*MakeSOATestEnv*";
     };
     ProgramCall @[3] {
      desc="word reading conflict";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="TrialType";
	required=1;
	def_val=;
	expr {
	 expr="\"conflict\"";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="TaskType";
	required=1;
	def_val=;
	expr {
	 expr="\"P_wr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="cur_trialtype_num";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="resetrows";
	required=1;
	def_val=;
	expr {
	 expr="false";
	};
       };
      };
      target=$.projects[0].programs.gp[2][1]$;
      targ_ld_init="*MakeSOATestEnv*";
     };
     ProgramCall @[4] {
      desc="word reading congruent";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="TrialType";
	required=1;
	def_val=;
	expr {
	 expr="\"congruent\"";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="TaskType";
	required=1;
	def_val=;
	expr {
	 expr="\"P_wr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="cur_trialtype_num";
	required=1;
	def_val=;
	expr {
	 expr="3";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="resetrows";
	required=1;
	def_val=;
	expr {
	 expr="false";
	};
       };
      };
      target=$.projects[0].programs.gp[2][1]$;
      targ_ld_init="*MakeSOATestEnv*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[3] {
   name="Analysis";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   Program @[0] {
    name="GetData";
    short_nm="GeData";
    tags=;
    desc=;
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="InputData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="OutputData";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].data.gp[2][0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     DataSelectRowsProg @[0] {
      desc="filter for \"late stims\" -- only want to plot those";
      flags=;
      src_data_var=.projects[0].programs.gp[3][0].vars[0]$$;
      dest_data_var=.projects[0].programs.gp[3][0].vars[1]$$;
      select_spec {
       name="select_spec";
       ops {
	name=;
	el_typ=DataSelectEl;
	el_def=0;
	DataSelectEl @[0] {
	 col_name="trial_name";
	 on=1;
	 rel=CONTAINS;
	 use_var=0;
	 cmp 9 0="late";
	 var=NULL;
	 enable_var=NULL;
	};
       };
       comb_op=AND;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=0.9969268441200256;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAA0QAAAnUAAAMEAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="StroopNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=1;
	  net_text_xform {scale={x=0.7: y=0.7000006: z=0.7000006: }: rotate={x=1: y=0: z=0: rot=1.570796: }: translate={x=0.863206: y=-0.2423915: z=-1.000002: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[3].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=10: y=2: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.03;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="s.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    name="r.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    name="targ";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    name="wt_prjn";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[8] {
	    name="bias.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[9] {
	    name="v_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Colors=0;Words=0;Hidden=0;Output=0;PFC=0;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5135555: y=0.6623238: z=1.393857: };
	 orient {x=-1.000006: y=0: z=0: rot=0.1299993: };
	 focal_dist=1.807423;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="EpochOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][3]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][3].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][3].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=58: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="avg_sse";
	    m_data=.projects[0].data.gp[1][3].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.690683: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="cnt_err";
	    m_data=.projects[0].data.gp[1][3].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="avg_ext_rew";
	    m_data=.projects[0].data.gp[1][3].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="avg_cycles";
	    m_data=.projects[0].data.gp[1][3].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=58.7: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="epoch_time_tot";
	    m_data=.projects[0].data.gp[1][3].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="epoch_time_usr";
	    m_data=.projects[0].data.gp[1][3].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=59: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=59: };
	   range {min=0: max=59: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=1: max=1: };
	   range {min=0.99994: max=1.00005: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="avg_sse";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-19: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="avg_cycles";
	   fixed_range {fix_min=1: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=6e-19: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=1;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=1;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.493989: y=0.445: z=1.702407: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.714907;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="TrialOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="trial";
	    m_data=.projects[0].data.gp[1][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[1][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="group_name";
	    m_data=.projects[0].data.gp[1][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="phase_no";
	    m_data=.projects[0].data.gp[1][0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="minus_cycles";
	    m_data=.projects[0].data.gp[1][0].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=60: fix_max=1: max=200: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="sse";
	    m_data=.projects[0].data.gp[1][0].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="ext_rew";
	    m_data=.projects[0].data.gp[1][0].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="trial_mod";
	    m_data=.projects[0].data.gp[1][0].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="trial_div";
	    m_data=.projects[0].data.gp[1][0].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="Output_act_m";
	    m_data=.projects[0].data.gp[1][0].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="trial_type";
	    m_data=.projects[0].data.gp[1][0].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=5: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="trial_mod";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.2: max=2.2: };
	   range {min=-0.2: max=2.2: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="trial_mod";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="minus_cycles";
	   fixed_range {fix_min=1: min=60: fix_max=1: max=200: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=200: };
	   range {min=60: max=200: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="trial_name";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=COLOR_AXIS;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="trial_div";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.445: z=1.715456: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.727957;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[3] {
       name="SOATestResults";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[2][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[2][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[2][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="trial";
	    m_data=.projects[0].data.gp[2][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[2][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="group_name";
	    m_data=.projects[0].data.gp[2][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="phase_no";
	    m_data=.projects[0].data.gp[2][0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="minus_cycles";
	    m_data=.projects[0].data.gp[2][0].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="sse";
	    m_data=.projects[0].data.gp[2][0].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="ext_rew";
	    m_data=.projects[0].data.gp[2][0].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="SOA";
	    m_data=.projects[0].data.gp[2][0].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="max_cycles";
	    m_data=.projects[0].data.gp[2][0].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="cur_trialtype_num";
	    m_data=.projects[0].data.gp[2][0].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=43: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="SOA";
	   fixed_range {fix_min=0: min=-20: fix_max=0: max=20: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-20: max=20: };
	   range {min=-20: max=20: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   fixed_range {fix_min=0: min=-20: fix_max=0: max=20: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-20: max=20: };
	   range {min=-20: max=20: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="minus_cycles";
	   fixed_range {fix_min=0: min=92: fix_max=0: max=170: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=92: max=170: };
	   range {min=92: max=170: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="group_name";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=3: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=3: };
	   range {min=0: max=3: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=COLOR_AXIS;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="cur_trialtype_num";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=3: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=3: };
	   range {min=0: max=3: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.427578: y=0.4449999: z=1.719009: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.731509;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[4] {
       name="StimFrequencies";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].programs.gp[2][0].objs[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Colors";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Words";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="PFC";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[5] {
	    name="frequency";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=4;
	  view_range {min=0: max=3: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=6;
	  col_range {min=0: max=5: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[0][3]$;
FloatTransform @*(.m_transform) {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.9542376: y=1.125424: z=2.827496e-08: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Colors";
	    m_data=.projects[0].data.gp[0][3].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Words";
	    m_data=.projects[0].data.gp[0][3].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][3].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="PFC";
	    m_data=.projects[0].data.gp[0][3].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.9542376: y=1.125424: z=2.827496e-08: }: };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=3.3;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=1;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.553105: y=0.711712: z=1.914403: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.924403;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[5] {
       name="Test_BothTasks";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][1]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Colors";
	    m_data=.projects[0].data.gp[0][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Words";
	    m_data=.projects[0].data.gp[0][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][1].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    name="PFC";
	    m_data=.projects[0].data.gp[0][1].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=6;
	  view_range {min=0: max=5: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=4: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[0][3]$;
FloatTransform @*(.m_transform) {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.961102: y=1.13: z=2.704561e-08: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Colors";
	    m_data=$.projects[0].data.gp[0][3].data[0]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Words";
	    m_data=$.projects[0].data.gp[0][3].data[1]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Output";
	    m_data=$.projects[0].data.gp[0][3].data[2]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="PFC";
	    m_data=$.projects[0].data.gp[0][3].data[3]$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.961102: y=1.13: z=2.704561e-08: }: };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=3.3;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=1;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.55997: y=0.714: z=1.90635: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.91635;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7285992503166199;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="StroopNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="TrainUnitSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
      LeabraUnitSpec @[0] {
       name="TestUnitSpec";
       desc=;
       unique{ dt;       };
       children {
	name=;
	el_typ=LeabraUnitSpec;
	el_def=0;
       };
       act_range {min=0: max=1: range=1: scale=1: };
       bias_con_type=LeabraCon;
       bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
       sse_tol=0.5;
       act_fun=NOISY_XX1;
       act {gelin=0: thr=0.25: gain=50: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
       spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=4: eq_dt=0.02: };
       spike_misc {
	exp_slope=0.02;
	spk_thr=1.2;
	clamp_max_p=0.11;
	clamp_type=REGULAR;
	vm_r=0.3;
	vm_dend=0.3;
	vm_dend_dt=0.16;
	vm_dend_time=6.25;
       };
       opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
       maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
       clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
       vm_range {min=0: max=1: range=1: scale=1: };
       v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
       dt {integ=1: vm=0.01: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=100: net_time=1.428571: };
       act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
       g_bar {e=1: l=0.01: i=1: h=0.1: a=0.5: };
       e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
       hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
       adapt {
	on=0;
	dt=0.007;
	vm_gain=0.04;
	spike_gain=0.00805;
	interval=10;
	dt_time=142.8571;
       };
       depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
       syn_delay {
	on=0;
	delay=4;
       };
       da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
       noise_type=NO_NOISE;
       noise {name="": type=GAUSSIAN: mean=0: var=0.005: par=1: };
       noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
       noise_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=1;
	cur_val=0;
       };
      };
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[1].children[0]$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=50: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=4: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.01: i=1: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.005: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraConSpec @[1] {
     name="ConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="BiasSpec_0";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.02: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=1;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.05: err=0.95: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
      LeabraConSpec @[1] {
       name="FmPFC";
       desc=;
       unique{ wt_scale;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0.25: var=0: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=0.85: sem_extra=2: old=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=1;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.05: err=0.95: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {name="": type=UNIFORM: mean=0.25: var=0: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=1: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=1;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.05: err=0.95: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @[2] {
     name="LayerSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="HiddenLayer";
       desc=;
       unique{ kwta;gp_kwta;inhib_group;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=UNIT_GROUPS;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=2: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=1: gp_g=0.8: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_INHIB;
      kwta_pt=0.25;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=1: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    BaseSpec_Group @.gp[0] {
     name="LeabraPrjns";
     el_typ=TesselPrjnSpec;
     el_def=0;
     FullPrjnSpec @[0] {
      name="FullPrjnSpec_0";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=FullPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
     OneToOnePrjnSpec @[1] {
      name="Colors_Hidden";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     OneToOnePrjnSpec @[2] {
      name="Words_Hidden";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=2;
      send_start=0;
     };
     TesselPrjnSpec @[3] {
      name="Hidden_PFC";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=2: y=1: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
       TessEl @[1] {
	send_off {x=1: y=0: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     TesselPrjnSpec @[4] {
      name="PFC_Hidden";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=2: y=2: };
      wrap=1;
      send_scale {x=0.5: y=0.5: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=10: y=2: z=2: };
    LeabraLayer @[0] {
     name="Colors";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_act_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=1: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       name="g";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[2].projections[0]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       name="r";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="r";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 1] "g";"r";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.475: max=0.95: max_i=1: };
     acts_m {cmpt=1: avg=0.475: max=0.95: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=2.543116e+30;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Words";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=4: y=0: z=0: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_act_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=1: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       name="G";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[2].projections[1]$$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       name="R";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="R";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 1] "G";"R";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.475: max=0.95: max_i=1: };
     acts_m {cmpt=1: avg=0.475: max=0.95: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=6.994411e+28;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Hidden";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=1: z=1: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=1;
     gp_geom {x=2: y=1: n_not_xy=0: n=2: };
     gp_spc {x=1: y=0: };
     act_geom {x=5: y=1: n_not_xy=0: n=1: };
     scaled_act_geom {x=5: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Colors";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[0][1]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Words";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[1]$$;
       spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[0][2]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_PFC";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][4]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1].children[1]$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[3] {
       name="Fm_Output";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[3]$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][0]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=3;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=4: y=1: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraUnit_Group @.gp[0] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=1: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name="r";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.3625461: max=0.7250921: max_i=1: };
       acts_m {cmpt=1: avg=0.3625461: max=0.7250921: max_i=1: };
       phase_dif_ratio=0.995181;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=4.229733: k1_ithr=1.638498: ithr_r=0.9483592: ithr_diff=0.6126239: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name="g";
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 0;
	  units = {};
	  wt = {};
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[2]$$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[2].projections[3]$$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.25; 0.25; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[4].projections[0]$$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=.projects[0].networks[0].layers[3].projections[0]$$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.15;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.15;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name="r";
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 0;
	  units = {};
	  wt = {};
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.25; 0.25; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=1: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.15;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.15;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
      LeabraUnit_Group @.gp[1] {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=3: y=0: z=0: };
       unique_geom=0;
       geom {x=2: y=1: n_not_xy=0: n=2: };
       units_lesioned=0;
       output_name="R";
       netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
       i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
       acts_p {cmpt=1: avg=0.1979641: max=0.3959283: max_i=1: };
       acts_m {cmpt=1: avg=0.1979641: max=0.3959283: max_i=1: };
       phase_dif_ratio=0.0002294484;
       acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
       acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
       kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=2.963796: k1_ithr=0.1343082: ithr_r=3.094089: ithr_diff=0.9546838: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
       i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
       un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
       adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
       maxda=0;
       act_max_avg=0;
       misc_state=0;
       misc_state1=0;
       misc_state2=0;
       misc_state3=0;
       misc_float=0;
       misc_float1=0;
       misc_float2=0;
       LeabraUnit @[0] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name="G";
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 0;
	  units = {};
	  wt = {};
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {0; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.25; 0.25; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=0: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.15;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.15;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
       LeabraUnit @[1] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	};
	name="R";
	ext_flag=;
	targ=0;
	ext=0;
	act=0;
	net=0;
	recv {
	 name=;
	 el_typ=LeabraRecvCons;
	 el_def=0;
	 LeabraRecvCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	  other_idx=0;
	 };
	 { con_alloc = 0;
	  units = {};
	  wt = {};
	 };
	 LeabraRecvCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[2] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	  other_idx=0;
	 };
	 { con_alloc = 1;
	  units = {1; };
	  wt = {0.25; };
	 };
	 LeabraRecvCons @[3] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	  other_idx=0;
	 };
	 { con_alloc = 2;
	  units = {0; 1; };
	  wt = {0.25; 0.25; };
	 };
	};
	send {
	 name=;
	 el_typ=LeabraSendCons;
	 el_def=0;
	 LeabraSendCons @[0] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	  other_idx=0;
	 };
	 LeabraSendCons @[1] {
	  con_type=LeabraCon;
	  prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	  other_idx=0;
	 };
	};
	bias {
	 con_type=LeabraCon;
	 prjn=NULL;
	 other_idx=-1;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	n_recv_cons=4;
	pos {x=1: y=0: z=0: };
	act_eq=0;
	act_nd=0;
	act_avg=0.15;
	act_m=0;
	act_p=0;
	act_dif=0;
	act_m2=0;
	act_p2=0;
	act_dif2=0;
	avg_ss=0.15;
	avg_s=0.15;
	avg_m=0.15;
	avg_ml=0.15;
	avg_l=0.15;
	l_thr=0.45;
	davg=0;
	vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
	dav=0;
	maint_h=0;
	spk_amp=2;
       };
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="r_R";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 1 2 1] "g";"r";"G";"R";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2802551: max=0.7250921: max_i=0: };
     acts_m {cmpt=1: avg=0.2802551: max=0.7250921: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=2: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=2.635406: k1_ithr=1.508175: ithr_r=0.5581372: ithr_diff=0.4277259: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[2].children[0]$$: };
     hard_clamped=0;
     avg_l_avg=9.918391e-39;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[3] {
     name="Output";
     desc=;
     flags=;
     layer_type=TARGET;
     pos {x=8: y=0: z=0: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_act_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[2]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[3];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=1: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="gr";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=1;
	};
	{ con_alloc = 4;
	 units = {0; 1; 2; 3; };
	 wt = {0.25; 0.25; 0.25; 0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	 other_idx=3;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="rd";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=1;
	};
	{ con_alloc = 4;
	 units = {0; 1; 2; 3; };
	 wt = {0.25; 0.25; 0.25; 0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[3]$;
	 other_idx=3;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="rd";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 1] "gr";"rd";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2538819: max=0.5077638: max_i=1: };
     acts_m {cmpt=1: avg=0.2538819: max=0.5077638: max_i=1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=1.946294: k1_ithr=0.139973: ithr_r=2.632233: ithr_diff=0.9280823: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=9.935255e+27;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[4] {
     name="PFC";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=7: y=1: z=1: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_act_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[2]$;
       spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][3]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[2];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=1: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
      LeabraUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="cn";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.25; 0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
      LeabraUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="wr";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[4].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {2; 3; };
	 wt = {0.25; 0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[2]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="cn";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [2 1] "cn";"wr";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.475: max=0.95: max_i=0: };
     acts_m {cmpt=1: avg=0.475: max=0.95: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.5: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.01: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[2]$: };
     hard_clamped=0;
     avg_l_avg=1.037755e-38;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   train_mode=TEST;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name=;
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="train_time": start={usr=21025: sys=2554: tot=128894421889: }: end={usr=21563: sys=2606: tot=128894422485: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="epoch_time": start={usr=21624: sys=2612: tot=128894422881: }: end={usr=21638: sys=2614: tot=128894422896: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=1.077608493660589e-314;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=12;
   n_cons=28;
   max_size {x=10: y=2: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=1;
   ct_cycle=132;
   time_inc=1;
   cycle_max=60;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=0;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=0;
   avg_cycles=0;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=0;
   avg_send_pct=0;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=0.005;
   maxda=0;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=1;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
