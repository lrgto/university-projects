// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [2] {
    taDoc @[0] { };
    taDoc @[1] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  SelectEdit_Group @.edits = [3] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [1] {
	EditMbrItem @[0] { };
	EditMbrItem_Group @.gp[0] = [6] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	};
      };

      EditMthItem_Group @.mths = [4] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
      };
    };
    SelectEdit @[1] { 
      EditMbrItem_Group @.mbrs = [12] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem @[3] { };
	EditMbrItem @[4] { };
	EditMbrItem @[5] { };
	EditMbrItem @[6] { };
	EditMbrItem @[7] { };
	EditMbrItem @[8] { };
	EditMbrItem @[9] { };
	EditMbrItem @[10] { };
	EditMbrItem @[11] { };
      };

      EditMthItem_Group @.mths = [0] {
      };
    };
    SelectEdit @[2] { 
      EditMbrItem_Group @.mbrs = [3] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
	EditMbrItem_Group @.gp[0] = [7] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	};
	EditMbrItem_Group @.gp[1] = [11] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	  EditMbrItem @[7] { };
	  EditMbrItem @[8] { };
	  EditMbrItem @[9] { };
	  EditMbrItem @[10] { };
	};
	EditMbrItem_Group @.gp[2] = [5] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	};
      };

      EditMthItem_Group @.mths = [0] {
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [2] { 
      DataTable @[0] { 
    UserDataItem_List @*(.user_data_) {
	  UserDataItem @[0] { };
    };

	DataTableCols @.data = [4] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	  float_Data @[3] { };
	};
      };
      DataTable @[1] { 
    UserDataItem_List @*(.user_data_) {
	  UserDataItem @[0] { };
	  UserDataItem @[1] { };
	  UserDataItem @[2] { };
    };

	DataTableCols @.data = [3] {
	  String_Data @[0] { };
	  String_Data @[1] { };
	  String_Data @[2] { };
	};
      };
    };
    DataTable_Group @.gp[1] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [15] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	  float_Data @[12] { };
	  float_Data @[13] { };
	  float_Data @[14] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [13] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	  float_Data @[12] { };
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [1] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [6] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [20] {
	IfReturn @[0] { };
	Comment @[1] { };
	MiscCall @[2] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MiscCall @[3] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	RegisterArgs @[4] { };
	Comment @[5] { };
	PrintExpr @[6] { };
	MethodCall @[7] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
	MiscCall @[8] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	MiscCall @[9] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	ProgVarFmArg @[10] { };
	ProgVarFmArg @[11] { };
	Comment @[12] { };
	MethodCall @[13] { 
	  ProgArg_List @.meth_args = [4] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	  };
	};
	MethodCall @[14] { 
	  ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	  };
	};
	MethodCall @[15] { 
	  ProgArg_List @.meth_args = [4] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	  };
	};
	MethodCall @[16] { 
	  ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	  };
	};
	OtherProgramVar @[17] { };
	PrintExpr @[18] { };
	ProgramCall @[19] { 
	  ProgArg_List @.prog_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [5] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [7] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  If @[3] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	  AssignExpr @[4] { };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [11] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  ProgramCall @[3] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetDataLoop @[5] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  ProgramCall @[9] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[10] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [6] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[5] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [4] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  UserScript @[1] { };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [15] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	      NetMonItem @[13] { };
	      NetMonItem @[14] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [10] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[9] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [13] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [8] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  UserScript @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[1] = [1] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [5] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [7] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	      DynEnumItem @[2] { };
	      DynEnumItem @[3] { };
	      DynEnumItem @[4] { };
	      DynEnumItem @[5] { };
	      DynEnumItem @[6] { };
	    };
	  };
	  DynEnumType @[1] { 
	    DynEnumItem_List @.enums = [4] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	      DynEnumItem @[2] { };
	      DynEnumItem @[3] { };
	    };
	  };
	  DynEnumType @[2] { 
	    DynEnumItem_List @.enums = [1] {
	      DynEnumItem @[0] { };
	    };
	  };
	  DynEnumType @[3] { 
	    DynEnumItem_List @.enums = [6] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	      DynEnumItem @[2] { };
	      DynEnumItem @[3] { };
	      DynEnumItem @[4] { };
	      DynEnumItem @[5] { };
	    };
	  };
	  DynEnumType @[4] { 
	    DynEnumItem_List @.enums = [4] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	      DynEnumItem @[2] { };
	      DynEnumItem @[3] { };
	    };
	  };
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [8] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	};

	Function_List @.functions = [1] {
	  Function @[0] { 
	    ProgVar_List @.args = [2] {
	      ProgVar @[0] { };
	      ProgVar @[1] { };
	    };

	    ProgEl_List @.fun_code = [7] {
	      ProgVars @[0] { 
		ProgVar_List @.local_vars = [3] {
		  ProgVar @[0] { };
		  ProgVar @[1] { };
		  ProgVar @[2] { };
		};
	      };
	      MethodCall @[1] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      AssignExpr @[2] { };
	      AssignExpr @[3] { };
	      AssignExpr @[4] { };
	      IfElse @[5] { 
		ProgEl_List @.true_code = [2] {
		  SetUnitsVar @[0] { };
		  SetUnitsLit @[1] { };
		};

		ProgEl_List @.false_code = [2] {
		  SetUnitsVar @[0] { };
		  SetUnitsVar @[1] { };
		};
	      };
	      DoneWritingDataRow @[6] { };
	    };
	  };
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  InitNamedUnits @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ForLoop @[1] { 
	    ProgEl_List @.loop_code = [4] {
	      WhileLoop @[0] { 
		ProgEl_List @.loop_code = [4] {
		  RandomCall @[0] { 
		    ProgArg_List @.meth_args = [1] {
		      ProgArg @[0] { };
		    };
		  };
		  IfContinue @[1] { };
		  IfContinue @[2] { };
		  IfBreak @[3] { };
		};
	      };
	      RandomCall @[1] { 
		ProgArg_List @.meth_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      Switch @[2] { 
		ProgEl_List @.cases = [3] {
		  CaseBlock @[0] { 
		    ProgEl_List @.prog_code = [1] {
		      AssignExpr @[0] { };
		    };
		  };
		  CaseBlock @[1] { 
		    ProgEl_List @.prog_code = [0] {
		    };
		  };
		  CaseBlock @[2] { 
		    ProgEl_List @.prog_code = [2] {
		      AssignExpr @[0] { };
		      AssignExpr @[1] { };
		    };
		  };
		};
	      };
	      FunctionCall @[3] { 
		ProgArg_List @.fun_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	};
      };
    };
    Program_Group @.gp[2] = [1] { 
      Program @[0] { 
	ProgObjList @.objs = [2] {
	  DataTable @[0] { 
	    DataTableCols @.data = [6] {
	      String_Data @[0] { };
	      float_Data @[1] { };
	      float_Data @[2] { };
	      float_Data @[3] { };
	      float_Data @[4] { };
	      float_Data @[5] { };
	    };
	  };
	  DataTable @[1] { 
	    DataTableCols @.data = [2] {
	      float_Data @[0] { };
	      float_Data @[1] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  DataGroupProg @[0] { 
	    DataOpList @.ops = [6] {
	      DataGroupEl @[0] { };
	      DataGroupEl @[1] { };
	      DataGroupEl @[2] { };
	      DataGroupEl @[3] { };
	      DataGroupEl @[4] { };
	      DataGroupEl @[5] { };
	    };
	  };
	  DataGroupProg @[1] { 
	    DataOpList @.ops = [2] {
	      DataGroupEl @[0] { };
	      DataGroupEl @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [5] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [1] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [41] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		    ScaleRange @[4] { };
		    ScaleRange @[5] { };
		    ScaleRange @[6] { };
		    ScaleRange @[7] { };
		    ScaleRange @[8] { };
		    ScaleRange @[9] { };
		    ScaleRange @[10] { };
		    ScaleRange @[11] { };
		    ScaleRange @[12] { };
		    ScaleRange @[13] { };
		    ScaleRange @[14] { };
		    ScaleRange @[15] { };
		    ScaleRange @[16] { };
		    ScaleRange @[17] { };
		    ScaleRange @[18] { };
		    ScaleRange @[19] { };
		    ScaleRange @[20] { };
		    ScaleRange @[21] { };
		    ScaleRange @[22] { };
		    ScaleRange @[23] { };
		    ScaleRange @[24] { };
		    ScaleRange @[25] { };
		    ScaleRange @[26] { };
		    ScaleRange @[27] { };
		    ScaleRange @[28] { };
		    ScaleRange @[29] { };
		    ScaleRange @[30] { };
		    ScaleRange @[31] { };
		    ScaleRange @[32] { };
		    ScaleRange @[33] { };
		    ScaleRange @[34] { };
		    ScaleRange @[35] { };
		    ScaleRange @[36] { };
		    ScaleRange @[37] { };
		    ScaleRange @[38] { };
		    ScaleRange @[39] { };
		    ScaleRange @[40] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [13] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		    GraphColView @[12] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [15] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		    GraphColView @[12] { };
		    GraphColView @[13] { };
		    GraphColView @[14] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[3] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [6] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[4] { 
	      T3DataView_List @.children = [2] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [3] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [4] {
	DaModUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraLayerSpec @[1] { 
	  BaseSpec_Group @.children = [2] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	    LeabraLayerSpec @[1] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	FullPrjnSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraConSpec @[3] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraBiasSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [2] {
		SchedItem @[0] { };
		SchedItem @[1] { };
	      };
	    };
	  };

	  Schedule @.lrate_sched = [2] {
	    SchedItem @[0] { };
	    SchedItem @[1] { };
	  };
	};
	BaseSpec_Group @.gp[0] = [5] { 
	  DaModUnitSpec @[0] { 
	    BaseSpec_Group @.children = [1] {
	      DaModUnitSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};

		Schedule @.noise_sched = [0] {
		};
	      };
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	  DaModUnitSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	  DaModUnitSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	  MatrixUnitSpec @[3] { 
	    BaseSpec_Group @.children = [1] {
	      MatrixUnitSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};

		Schedule @.noise_sched = [0] {
		};
	      };
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	  DaModUnitSpec @[4] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[1] = [3] { 
	  LeabraConSpec @[0] { 
	    BaseSpec_Group @.children = [6] {
	      PVConSpec @[0] { 
		BaseSpec_Group @.children = [3] {
		  PVConSpec @[0] { 
		    BaseSpec_Group @.children = [1] {
		      PVConSpec @[0] { 
			BaseSpec_Group @.children = [0] {
			};

			Schedule @.lrate_sched = [0] {
			};
		      };
		    };

		    Schedule @.lrate_sched = [0] {
		    };
		  };
		  PVrConSpec @[1] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [0] {
		    };
		  };
		  NVConSpec @[2] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [0] {
		    };
		  };
		};

		Schedule @.lrate_sched = [0] {
		};
	      };
	      LeabraBiasSpec @[1] { 
		BaseSpec_Group @.children = [2] {
		  LeabraBiasSpec @[0] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		  MatrixBiasSpec @[1] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		};

		Schedule @.lrate_sched = [2] {
		  SchedItem @[0] { };
		  SchedItem @[1] { };
		};
	      };
	      LeabraConSpec @[2] { 
		BaseSpec_Group @.children = [2] {
		  LeabraConSpec @[0] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		  LeabraBiasSpec @[1] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		};

		Schedule @.lrate_sched = [2] {
		  SchedItem @[0] { };
		  SchedItem @[1] { };
		};
	      };
	      MatrixConSpec @[3] { 
		BaseSpec_Group @.children = [3] {
		  MatrixConSpec @[0] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		  MatrixBiasSpec @[1] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		  MatrixConSpec @[2] { 
		    BaseSpec_Group @.children = [1] {
		      MatrixConSpec @[0] { 
			BaseSpec_Group @.children = [0] {
			};

			Schedule @.lrate_sched = [2] {
			  SchedItem @[0] { };
			  SchedItem @[1] { };
			};
		      };
		    };

		    Schedule @.lrate_sched = [2] {
		      SchedItem @[0] { };
		      SchedItem @[1] { };
		    };
		  };
		};

		Schedule @.lrate_sched = [2] {
		  SchedItem @[0] { };
		  SchedItem @[1] { };
		};
	      };
	      LeabraConSpec @[4] { 
		BaseSpec_Group @.children = [0] {
		};

		Schedule @.lrate_sched = [2] {
		  SchedItem @[0] { };
		  SchedItem @[1] { };
		};
	      };
	      LeabraConSpec @[5] { 
		BaseSpec_Group @.children = [0] {
		};

		Schedule @.lrate_sched = [2] {
		  SchedItem @[0] { };
		  SchedItem @[1] { };
		};
	      };
	    };

	    Schedule @.lrate_sched = [2] {
	      SchedItem @[0] { };
	      SchedItem @[1] { };
	    };
	  };
	  MarkerConSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.lrate_sched = [0] {
	    };
	  };
	  LeabraConSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.lrate_sched = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[2] = [11] { 
	  ExtRewLayerSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  PVrLayerSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  PViLayerSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  LVeLayerSpec @[3] { 
	    BaseSpec_Group @.children = [2] {
	      LViLayerSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	      PatchLayerSpec @[1] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	    };
	  };
	  NVLayerSpec @[4] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  PVLVDaLayerSpec @[5] { 
	    BaseSpec_Group @.children = [1] {
	      SNcLayerSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	    };
	  };
	  PFCLayerSpec @[6] { 
	    BaseSpec_Group @.children = [1] {
	      PFCOutLayerSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	    };
	  };
	  MatrixLayerSpec @[7] { 
	    BaseSpec_Group @.children = [1] {
	      MatrixLayerSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	    };
	  };
	  SNrThalLayerSpec @[8] { 
	    BaseSpec_Group @.children = [1] {
	      SNrThalLayerSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};
	      };
	    };
	  };
	  PVLVDaLayerSpec @[9] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  LeabraLayerSpec @[10] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[3] = [8] { 
	  FullPrjnSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  GpOneToOnePrjnSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  UniformRndPrjnSpec @[3] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @[4] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  GpRndTesselPrjnSpec @[5] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_gp_offs = [1] {
	      GpTessEl @[0] { };
	    };
	  };
	  TesselPrjnSpec @[6] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [2] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	    };
	  };
	  PFCLVPrjnSpec @[7] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	};
      };

      Layer_Group @.layers = [3] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [3] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	    LeabraPrjn @[2] { };
	  };

	  Unit_Group @.units = [49] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [7] {
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [4] {
	  };
	};
	Layer_Group @.gp[0] = [8] { 
	  LeabraLayer @[0] { 
	    Projection_Group @.projections = [0] {
	    };

	    Unit_Group @.units = [1] {
	    };
	  };
	  LeabraLayer @[1] { 
	    Projection_Group @.projections = [2] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	    };

	    Unit_Group @.units = [4] {
	    };
	  };
	  LeabraLayer @[2] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [4] {
	    };
	  };
	  LeabraLayer @[3] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [4] {
	    };
	  };
	  LeabraLayer @[4] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [4] { 
	      };
	    };
	  };
	  LeabraLayer @[5] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [4] { 
	      };
	    };
	  };
	  LeabraLayer @[6] { 
	    Projection_Group @.projections = [2] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	    };

	    Unit_Group @.units = [4] {
	    };
	  };
	  LeabraLayer @[7] { 
	    Projection_Group @.projections = [5] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	      LeabraPrjn @[3] { };
	      LeabraPrjn @[4] { };
	    };

	    Unit_Group @.units = [1] {
	    };
	  };
	};
	Layer_Group @.gp[1] = [4] { 
	  LeabraLayer @[0] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [4] { 
	      };
	    };
	  };
	  LeabraLayer @[1] { 
	    Projection_Group @.projections = [6] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	      LeabraPrjn @[3] { };
	      LeabraPrjn @[4] { };
	      LeabraPrjn @[5] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [1] { 
	      };
	    };
	  };
	  LeabraLayer @[2] { 
	    Projection_Group @.projections = [5] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	      LeabraPrjn @[3] { };
	      LeabraPrjn @[4] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [28] { 
	      };
	    };
	  };
	  LeabraLayer @[3] { 
	    Projection_Group @.projections = [1] {
	      LeabraPrjn @[0] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [1] { 
	      };
	    };
	  };
	};
	Layer_Group @.gp[2] = [1] { 
	  LeabraLayer @[0] { 
	    Projection_Group @.projections = [3] {
	      LeabraPrjn @[0] { };
	      LeabraPrjn @[1] { };
	      LeabraPrjn @[2] { };
	    };

	    Unit_Group @.units = [0] {
	      LeabraUnit_Group @.gp[0] = [7] { 
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc="final sub 03/05: localist 220 kavg pt=.9 pviferlv bias=2 iw1
new avg_da rnd go based on softmax
snrthal rnd_go_in = .2; snr tie break thr = .2
ergo on mnt wt std params";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>

= PFC Maintenance and Updating Model (Store Ignore Recall) =

* GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can just always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of the middle panel.

'''Important:''' this model is changed signficantly from the one in the textbook, using a much more powerful version of the dynamic gating mechanism modulated by dopamine, based on the model described in [[http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly & Frank, 2006]] (actually this version is even more recent, and a paper on it is in preparation) -- the task is generally the same however, and the key conceptual points are likewise the same.

The network is configured with the input and output information at the top of the network instead of the usual convention of having the input at the bottom -- this is because all of the basal ganglia mechanisms associated with the gating system are located in an anatomically appropriate location below the cortical layers associated with the rest of the model.

The main processing of information in the model follows the usual path from Input to Hidden to Output.  However, to make appropriate responses based on the information that came on earlier trials, the Hidden layer needs access to the information maintained in the PFC (prefrontal cortex) layer.  The PFC will maintain information in an active state until it receives a gating signal from the basal ganglia gating system, at which point it will update to encode (and subsequently maintain) information from the current trial.  In this simple model, the PFC acts just like a copy of the sensory input information, by virtue of having direct one-to-one projections from the Input layer.  This makes it easy to see directly what the PFC is maintaining -- the model also functions very well if the PFC representations are distributed and learned, as is required for more complex tasks. Furthermore, to demonstate the basic functions of this network for this simple task, we use here only a single \"stripe\" such that PFC can maintain only a single piece of information in working memory. In more complex tasks, more information  can be maintained, and independently updated, in parallel stripes.

Now for a brief overview of the basal ganglia gating system (for complete details about these layers, see the  [[http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly and Frank, 2006]] paper (O'Reilly, R.C. & Frank, M.J. (2006). Making Working Memory Work: A Computational Model of Learning in the Frontal Cortex and Basal Ganglia. <i>Neural Computation, 18,</i> 283-328.)  (Note that some details in this model differ from that paper -- an updated paper is in preparation). For a more elaborated version of the basic BG gating mechanisms and simulations of  their contributions to various learning and decision making  phenomena, see [[http://ski.cog.brown.edu/pubs-abstr.html#Frank05|Frank, M.J. (2005)]] and [[http://ski.cog.brown.edu/pubs-abstr.html#Frank06|Frank, M.J. (2006)]]<i> Journal of Cognitive Neuroscience </i> and <i> Neural Networks </i>. Those simulations and others are available for emergent here:
[[http://ski.cog.brown.edu/BG_Projects/]]
 
* Matrix: this is the dynamic gating system representing the matrix units within the dorsal striatum of the basal ganglia.  The first half of the units within a stripe represent \"Go\", while remainder represent \"NoGo.\"  If overall more Go units fire, this will cause updating of the PFC, but if more NoGo units fire, this will prevent updating and cause the PFC to maintain its existing memory representation.
* SNrThal: represents the output of the basal ganglia system, abstracting across substantia nigra pars reticulata (SNr), globus pallidus, and Thalamus, which implement the gating signal contingent on relative Go-NoGo activity in the Matrix.  If there is more overall Go activity, then the SNrThal unit gets activated, providing bottom-up excitation and driving updating in PFC.
* PV* and LV* and friends at the very bottom layer of the network: these represent the inputs to the dopaminergic system, which provides reinforcement learning signals to train up the dynamic gating system in the basal ganglia.  The PV layers represent primary values of reward (i.e., actual externally-delivered reward values), while the LV layers represent learned (\"anticipated\") values -- together, they account for Pavlovian conditioning phenomena and associated dopaminergic firing data.  They represent an alternative to the TD reinforcement learning model described in Chapter 6, but produce qualitatively similar responses at the level of dopamine output. 
* VTA and SNc are the dopamine unit activities, computing reward  prediction errors. When outcomes are better (worse) than expected or states are predictive of reward (no reward), these units will increase (decrease) activity. For convenience, tonic (baseline) states are represented  here with zero values, so that phasic deviations above and  below this value are  seen as positive or negative activations. (Of course in the real system negative activations are not possible, but negative prediction errors are observed as a pause in dopamine unit activity, such that firing rate drops from baseline tonic levels). For this single-stripe model, there are no differences between VTA and SNc, but SNc projects  to Matrix units to provide the actual training signals. (In extended multi-stripe models, where multiple pieces of information can be stored in separate PFC stripes, the SNc encodes a stripe-wise prediction error signal that is modulated separately for each BG-PFC stripe. Whereas the LVe learns  the reward values of the network state as a whole, the Patch ('striosomes') learns reward values of states in each stripe, and reward prediction errors conveyed to the SNc units associated with that stripe). 

* To explore the model's connectivity, click on r.wt and on various units within the layers of the network.

Now, let's step through some trials to see how the task works.

* Switch back to viewing activations (act).  Do Init, Step Trial in the control panel.  Then press F5 or do View/Refresh on the main menu, which will display the names of the units.

The task commands (Store, Ignore, Recall) are chosen completely at random (subject to the constraint that you can't store until after a recall, and you can't recall until after a store)  so you could get either an ignore or a store input.  You should see either the S or I task control input, plus one of the stimuli (A-D) chosen at random. The target output response should also be active, as we're looking at the plus phase information (stepping by trials). 

Notice that if the SNrThal unit is active,  the PFC layer has just been updated to maintain this current input information.

* Hit Step Trial again.

You should now see a new input pattern. If the SNrThal gating signal is active again, then the PFC will again update its representations to reflect this new input. But if the SNrThal unit is not active (due to more overall NoGo activity), PFC will maintain its previously stored information.

* Keep hitting Step Trial and noticing the pattern of updating and maintenance of information in PFC, and how this is driven by the activation of the SNrThal unit (which in turn is driven by the Matrix Go vs. NoGo units, which in turn are being modulated by dopamine from the PVLV system to learn how to better control maintenance in the PFC!).

When you see a R (recall) trial, look at the VTA (dopamine) unit at the bottom layer.  If the network is somehow able to correctly recall (or guess!), then this unit will have a positive (yellow) activation, indicating a better-than expected performance.  Most likely, it instead will be teal blue and inverted, indicating a negative dopamine signal from worse-than expected performance (producing the wrong response).  This is the reinforcement training signal that controls the learning of the Matrix units, so that they can learn when information in PFC is predictive of reward (in which case that information should be updated in future trials), or whether having some information in PFC is not rewarding (in which case that information should not be updated and stored in future trials). It is the same learning mechanism that has been extensively investigated (and validated empirically) as a fundamental rule for learning to select actions in corticostriatal circuits (see Frank papers linked above), applied here to working memory. 

* You can continue to Step Trial and observe the dynamics of the network.  When your mind is sufficiently boggled by the complexity of this model, then go ahead and hit Run, and switch to the [[.T3Tab.EpochOutputData]] tab.

You will see various different values being plotted as the network learns:
* '''cnt_err''' (black line): shows the overall number of errors per epoch (one epoch is 100 trials in this case), which quickly drops to around 10-15, which is basically the number of recall trials (the others are quickly learned as they do not require any active maintenance).
* '''S_da''' (red line): shows the amount of dopamine delivered on Store trials, on average.  This may decrease early during training (the PVLV system has a novelty bias that provides early initial dopamine) but then start to increase as the network starts to get the recall trials correct, tracking the cnt_err performance (i.e., when error goes down, S_da goes up, indicating correct store trials that were reinforced).  This phasic dopamine signal during the Store trials is the key for allowing the striatal Matrix units to learn that storing information leads to subsequent rewards.  It results from the PVLV system recognizing that this pattern of PFC activation associated with Store information has been predictive of reward in the past (much like the TD simulations in chapter 6, only here the reward-predictive stimulus is not consistently provided to the network prior to a reward; rather the PFC state itself becomes predictive of reward contingent on the network's own performance). Critically, this dopamine signal does not just \"report\" that reward is predicted, but is used to drive Go learning in the striatum so that the basal ganglia system is more likely to update this Store information in the PFC (because doing so has less to a reward-predictive state in the past). 
* '''I_da''' (blue line): shows dopamine for Ignore trials, which just declines and stays around zero (note the units for da signals are on the y-axis on the right), because the network does not get any reliable reward associated with encoding ignore information into the PFC. Indeed there are periods when this value  drops below zero, indicating that storing the Ignore information in PFC is reliably predictive of a negative reward prediction error. This drop in dopamine trains the striatal NoGo units to become active in response to Ignore signals, preventing them from being updated in PFC, and thus protecting  the currently maintained information from interference. 
* '''R_da''' (green line): shows dopamine for Recall trials (when the network's recall performance is directly rewarded or punished).  As you can see, this value always tends to converge to a mean of zero, but with large fluctuations on either side.  This is because it reflects the ''difference from expectation'', and the system quickly adapts its expectations based on how it is actually doing.  Thus, the main signals to notice here are when the network suddenly starts doing better than on the previous epoch (cnt_err drops) -- this should be associated with a peak in R_da, whereas a sudden increase in errors (worse performance) results in a dip in R_da.

The network can take roughly 10-50 epochs or so to train (it will stop when cnt_err gets to 0). 

* Once it has trained to this criterion, you can switch back to viewing the network, and Step through trials to see that it is indeed performing correctly. Pay particular attention to the SNrThal activation and what the PFC is maintaining as a result.

'''NOTE:''' the following question is different than the one in the textbook.  Your instructor may have you skip this question (or not) -- be sure to check.

<hr>

'''Question 9.12 (a)''' <em> Report the relativel levels of DA unit firing to the S, I and R trials at the end of learning. '''(b)''' Explain why these differences arise, and how they contribute to helping the network solve the task. Now, turn the network display back on in the SIRnet tab, and step  through a trial using the Control Panel. '''(c)''' Report whether there is more Go or NoGo unit activity in the Striatum for a couple of different Store and Ignore trials. You should see that the SNrThal (BG gating output) unit is active only when there is more Go than NoGo activity. Explain how the differences in Go/NoGo  activity patterns arise. </em>

<hr>

Now we will see that the Matrix (striatum), which controls updating, and the PVLV reinforcement learning system, which learns the  reward-predictive value of states in the network, contribute differently to solving the overall problem. 

Click on s.wt in the SIRnet panel, and then click on individual S and I units in the Input layer to show the learned sending weights from these units to other layers in the network.  You should see greater weights from the Input Store unit to Matrix Go than to NoGo units, confirming that the Matrix learned Go to update the Store stimulus. The opposite should be true for the Ignore stimulus (you might have to change the color scale displaying the weight values in the SIRNet tab for this to be obvious). Next, click on the S and I units in the PFC layer, and you should see similarly, that  in this case the difference may be less clear.  This is because it is useful to update store signals when they are in the Input, but the network should not necessarily update when the Store signals are maintained in PFC (e.g., if the Input pattern is currently Ignore). Thus in this simple WM task, the Input pattern is most relevant for dictating when the Matrix should update or not.

Next, we examine whether this distinction between Input and PFC weights applies to the evaluation of reward value by the reinforcement learning system. Click again on the S and I units in the Input and PFC layers, while still viewing s.wt, and observe the weights into the LVe layer at the bottom of the network. This layer corresponds to a part of the amygdala, and reflects the learned value (LV) of reward that the reinforcement learning system attributes to its inputs (note that the RL system can evaluate reward values of both external inputs from the environment, but can also evaluate the value of its PFC internal states). Weights to the units in the LVe layer labeled \"1\" reflect that this layer assigns a high reward value to the sending unit. Similarly, stronger weights to the units labeled \"0\" reflect that this layer assings a low reward value to the sending unit.

<hr>

'''Question 9.12 cont'd: (d)''' <em> Report the sending (s.wt) weights from the S and I units in both the Input and PFC layers to the LVe layer. Are there qualitative differences between the learned reward value in the LVe layer of the Store input unit compared to that of the Store PFC unit? How about the Ignore weights from Input and PFC?  Based on the lecture notes and what you know about how this system learns, why do you think this might be?</em>

<hr>

* When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.

</body>
</html>
";
   html_text="<html><head></head><body>
<p>
</p><h1> PFC Maintenance and Updating Model (Store Ignore Recall) </h1>
<p>
</p><ul><li> GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can just always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of the middle panel.
</li></ul>
 <b>Important:</b>  this model is changed signficantly from the one in the textbook, using a much more powerful version of the dynamic gating mechanism modulated by dopamine, based on the model described in <a href=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06\">O'Reilly &amp; Frank, 2006</a> (actually this version is even more recent, and a paper on it is in preparation) -- the task is generally the same however, and the key conceptual points are likewise the same.
<p>
The network is configured with the input and output information at the top of the network instead of the usual convention of having the input at the bottom -- this is because all of the basal ganglia mechanisms associated with the gating system are located in an anatomically appropriate location below the cortical layers associated with the rest of the model.
</p><p>
The main processing of information in the model follows the usual path from Input to Hidden to Output.  However, to make appropriate responses based on the information that came on earlier trials, the Hidden layer needs access to the information maintained in the PFC (prefrontal cortex) layer.  The PFC will maintain information in an active state until it receives a gating signal from the basal ganglia gating system, at which point it will update to encode (and subsequently maintain) information from the current trial.  In this simple model, the PFC acts just like a copy of the sensory input information, by virtue of having direct one-to-one projections from the Input layer.  This makes it easy to see directly what the PFC is maintaining -- the model also functions very well if the PFC representations are distributed and learned, as is required for more complex tasks. Furthermore, to demonstate the basic functions of this network for this simple task, we use here only a single \"stripe\" such that PFC can maintain only a single piece of information in working memory. In more complex tasks, more information  can be maintained, and independently updated, in parallel stripes.
</p><p>
Now for a brief overview of the basal ganglia gating system (for complete details about these layers, see the  <a href=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06\">O'Reilly and Frank, 2006</a> paper (O'Reilly, R.C. &amp; Frank, M.J. (2006). Making Working Memory Work: A Computational Model of Learning in the Frontal Cortex and Basal Ganglia. <i>Neural Computation, 18,</i> 283-328.)  (Note that some details in this model differ from that paper -- an updated paper is in preparation). For a more elaborated version of the basic BG gating mechanisms and simulations of  their contributions to various learning and decision making  phenomena, see <a href=\"http://ski.cog.brown.edu/pubs-abstr.html#Frank05\">Frank, M.J. (2005)</a> and <a href=\"http://ski.cog.brown.edu/pubs-abstr.html#Frank06\">Frank, M.J. (2006)</a><i> Journal of Cognitive Neuroscience </i> and <i> Neural Networks </i>. Those simulations and others are available for emergent here:
<a href=\"http://ski.cog.brown.edu/BG_Projects/\">http://ski.cog.brown.edu/BG_Projects/</a>
 
</p><ul><li> Matrix: this is the dynamic gating system representing the matrix units within the dorsal striatum of the basal ganglia.  The first half of the units within a stripe represent \"Go\", while remainder represent \"NoGo.\"  If overall more Go units fire, this will cause updating of the PFC, but if more NoGo units fire, this will prevent updating and cause the PFC to maintain its existing memory representation.
</li><li> SNrThal: represents the output of the basal ganglia system, abstracting across substantia nigra pars reticulata (SNr), globus pallidus, and Thalamus, which implement the gating signal contingent on relative Go-NoGo activity in the Matrix.  If there is more overall Go activity, then the SNrThal unit gets activated, providing bottom-up excitation and driving updating in PFC.
</li><li> PV* and LV* and friends at the very bottom layer of the network: these represent the inputs to the dopaminergic system, which provides reinforcement learning signals to train up the dynamic gating system in the basal ganglia.  The PV layers represent primary values of reward (i.e., actual externally-delivered reward values), while the LV layers represent learned (\"anticipated\") values -- together, they account for Pavlovian conditioning phenomena and associated dopaminergic firing data.  They represent an alternative to the TD reinforcement learning model described in Chapter 6, but produce qualitatively similar responses at the level of dopamine output. 
</li><li> VTA and SNc are the dopamine unit activities, computing reward  prediction errors. When outcomes are better (worse) than expected or states are predictive of reward (no reward), these units will increase (decrease) activity. For convenience, tonic (baseline) states are represented  here with zero values, so that phasic deviations above and  below this value are  seen as positive or negative activations. (Of course in the real system negative activations are not possible, but negative prediction errors are observed as a pause in dopamine unit activity, such that firing rate drops from baseline tonic levels). For this single-stripe model, there are no differences between VTA and SNc, but SNc projects  to Matrix units to provide the actual training signals. (In extended multi-stripe models, where multiple pieces of information can be stored in separate PFC stripes, the SNc encodes a stripe-wise prediction error signal that is modulated separately for each BG-PFC stripe. Whereas the LVe learns  the reward values of the network state as a whole, the Patch ('striosomes') learns reward values of states in each stripe, and reward prediction errors conveyed to the SNc units associated with that stripe). 
</li></ul>
<ul><li> To explore the model's connectivity, click on r.wt and on various units within the layers of the network.
</li></ul>
Now, let's step through some trials to see how the task works.
<p>
</p><ul><li> Switch back to viewing activations (act).  Do Init, Step Trial in the control panel.  Then press F5 or do View/Refresh on the main menu, which will display the names of the units.
</li></ul>
The task commands (Store, Ignore, Recall) are chosen completely at random (subject to the constraint that you can't store until after a recall, and you can't recall until after a store)  so you could get either an ignore or a store input.  You should see either the S or I task control input, plus one of the stimuli (A-D) chosen at random. The target output response should also be active, as we're looking at the plus phase information (stepping by trials). 
<p>
Notice that if the SNrThal unit is active,  the PFC layer has just been updated to maintain this current input information.
</p><p>
</p><ul><li> Hit Step Trial again.
</li></ul>
You should now see a new input pattern. If the SNrThal gating signal is active again, then the PFC will again update its representations to reflect this new input. But if the SNrThal unit is not active (due to more overall NoGo activity), PFC will maintain its previously stored information.
<p>
</p><ul><li> Keep hitting Step Trial and noticing the pattern of updating and maintenance of information in PFC, and how this is driven by the activation of the SNrThal unit (which in turn is driven by the Matrix Go vs. NoGo units, which in turn are being modulated by dopamine from the PVLV system to learn how to better control maintenance in the PFC!).
</li></ul>
When you see a R (recall) trial, look at the VTA (dopamine) unit at the bottom layer.  If the network is somehow able to correctly recall (or guess!), then this unit will have a positive (yellow) activation, indicating a better-than expected performance.  Most likely, it instead will be teal blue and inverted, indicating a negative dopamine signal from worse-than expected performance (producing the wrong response).  This is the reinforcement training signal that controls the learning of the Matrix units, so that they can learn when information in PFC is predictive of reward (in which case that information should be updated in future trials), or whether having some information in PFC is not rewarding (in which case that information should not be updated and stored in future trials). It is the same learning mechanism that has been extensively investigated (and validated empirically) as a fundamental rule for learning to select actions in corticostriatal circuits (see Frank papers linked above), applied here to working memory. 
<p>
</p><ul><li> You can continue to Step Trial and observe the dynamics of the network.  When your mind is sufficiently boggled by the complexity of this model, then go ahead and hit Run, and switch to the <a href=\"ta:.T3Tab.EpochOutputData\">EpochOutputData</a> tab.
</li></ul>
You will see various different values being plotted as the network learns:
<ul><li>  <b>cnt_err</b>  (black line): shows the overall number of errors per epoch (one epoch is 100 trials in this case), which quickly drops to around 10-15, which is basically the number of recall trials (the others are quickly learned as they do not require any active maintenance).
</li><li>  <b>S_da</b>  (red line): shows the amount of dopamine delivered on Store trials, on average.  This may decrease early during training (the PVLV system has a novelty bias that provides early initial dopamine) but then start to increase as the network starts to get the recall trials correct, tracking the cnt_err performance (i.e., when error goes down, S_da goes up, indicating correct store trials that were reinforced).  This phasic dopamine signal during the Store trials is the key for allowing the striatal Matrix units to learn that storing information leads to subsequent rewards.  It results from the PVLV system recognizing that this pattern of PFC activation associated with Store information has been predictive of reward in the past (much like the TD simulations in chapter 6, only here the reward-predictive stimulus is not consistently provided to the network prior to a reward; rather the PFC state itself becomes predictive of reward contingent on the network's own performance). Critically, this dopamine signal does not just \"report\" that reward is predicted, but is used to drive Go learning in the striatum so that the basal ganglia system is more likely to update this Store information in the PFC (because doing so has less to a reward-predictive state in the past). 
</li><li>  <b>I_da</b>  (blue line): shows dopamine for Ignore trials, which just declines and stays around zero (note the units for da signals are on the y-axis on the right), because the network does not get any reliable reward associated with encoding ignore information into the PFC. Indeed there are periods when this value  drops below zero, indicating that storing the Ignore information in PFC is reliably predictive of a negative reward prediction error. This drop in dopamine trains the striatal NoGo units to become active in response to Ignore signals, preventing them from being updated in PFC, and thus protecting  the currently maintained information from interference. 
</li><li>  <b>R_da</b>  (green line): shows dopamine for Recall trials (when the network's recall performance is directly rewarded or punished).  As you can see, this value always tends to converge to a mean of zero, but with large fluctuations on either side.  This is because it reflects the  <i>difference from expectation</i> , and the system quickly adapts its expectations based on how it is actually doing.  Thus, the main signals to notice here are when the network suddenly starts doing better than on the previous epoch (cnt_err drops) -- this should be associated with a peak in R_da, whereas a sudden increase in errors (worse performance) results in a dip in R_da.
</li></ul>
The network can take roughly 10-50 epochs or so to train (it will stop when cnt_err gets to 0). 
<p>
</p><ul><li> Once it has trained to this criterion, you can switch back to viewing the network, and Step through trials to see that it is indeed performing correctly. Pay particular attention to the SNrThal activation and what the PFC is maintaining as a result.
</li></ul>
 <b>NOTE:</b>  the following question is different than the one in the textbook.  Your instructor may have you skip this question (or not) -- be sure to check.
<p>
</p><hr>
<p>
 <b>Question 9.12 (a)</b>  <em> Report the relativel levels of DA unit firing to the S, I and R trials at the end of learning.  <b>(b)</b>  Explain why these differences arise, and how they contribute to helping the network solve the task. Now, turn the network display back on in the SIRnet tab, and step  through a trial using the Control Panel.  <b>(c)</b>  Report whether there is more Go or NoGo unit activity in the Striatum for a couple of different Store and Ignore trials. You should see that the SNrThal (BG gating output) unit is active only when there is more Go than NoGo activity. Explain how the differences in Go/NoGo  activity patterns arise. </em>
</p><p>
</p><hr>
<p>
Now we will see that the Matrix (striatum), which controls updating, and the PVLV reinforcement learning system, which learns the  reward-predictive value of states in the network, contribute differently to solving the overall problem. 
</p><p>
Click on s.wt in the SIRnet panel, and then click on individual S and I units in the Input layer to show the learned sending weights from these units to other layers in the network.  You should see greater weights from the Input Store unit to Matrix Go than to NoGo units, confirming that the Matrix learned Go to update the Store stimulus. The opposite should be true for the Ignore stimulus (you might have to change the color scale displaying the weight values in the SIRNet tab for this to be obvious). Next, click on the S and I units in the PFC layer, and you should see similarly, that  in this case the difference may be less clear.  This is because it is useful to update store signals when they are in the Input, but the network should not necessarily update when the Store signals are maintained in PFC (e.g., if the Input pattern is currently Ignore). Thus in this simple WM task, the Input pattern is most relevant for dictating when the Matrix should update or not.
</p><p>
Next, we examine whether this distinction between Input and PFC weights applies to the evaluation of reward value by the reinforcement learning system. Click again on the S and I units in the Input and PFC layers, while still viewing s.wt, and observe the weights into the LVe layer at the bottom of the network. This layer corresponds to a part of the amygdala, and reflects the learned value (LV) of reward that the reinforcement learning system attributes to its inputs (note that the RL system can evaluate reward values of both external inputs from the environment, but can also evaluate the value of its PFC internal states). Weights to the units in the LVe layer labeled \"1\" reflect that this layer assigns a high reward value to the sending unit. Similarly, stronger weights to the units labeled \"0\" reflect that this layer assings a low reward value to the sending unit.
</p><p>
</p><hr>
<p>
 <b>Question 9.12 cont'd: (d)</b>  <em> Report the sending (s.wt) weights from the S and I units in both the Input and PFC layers to the LVe layer. Are there qualitative differences between the learned reward value in the LVe layer of the Store input unit compared to that of the Store PFC unit? How about the Ignore weights from Input and PFC?  Based on the lecture notes and what you know about how this system learns, why do you think this might be?</em>
</p><p>
</p><hr>
<p>
</p><ul><li> When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.
</li></ul>


</body></html>";
  };
  taDoc @[1] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_PFC_Maint_Updt";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_PFC_Maint_Updt";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 PFC Maint Updt,CECN1 Projects,Emergent,.T3Tab.EpochOutputData\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 PFC Maint Updt - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_PFC_Maint_Updt\";
		var wgTitle = \"CECN1 PFC Maint Updt\";
		var wgAction = \"view\";
		var wgArticleId = \"125\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 400;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_PFC_Maint_Updt skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 PFC Maint Updt</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<a name=\"PFC_Maintenance_and_Updating\" id=\"PFC_Maintenance_and_Updating\"></a><h1> <span class=\"mw-headline\"> PFC Maintenance and Updating </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/e/e4/pfc_maint_updt.proj\" class=\"internal\" title=\"pfc maint updt.proj\">pfc_maint_updt.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p><p><b>IMPORTANT:</b> This model is significantly different in its implementational details (different gating mechanism) from the original one described in the textbook.  The question at the end is also different, but getting at the same overall issues.
</p>
<ul><li> GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can just always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of the middle panel.
</li></ul>
<p><b>Important:</b> this model is changed signficantly from the one in the textbook, using a much more powerful version of the dynamic gating mechanism modulated by dopamine, based on the model described in [<a href=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly\" class=\"external text\" title=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly\" rel=\"nofollow\">&amp; Frank, 2006</a>] -- the task is generally the same however, and the key conceptual points are likewise the same.
</p><p>The network is configured with the input and output information at the top of the network instead of the usual convention of having the input at the bottom -- this is because all of the basal ganglia mechanisms associated with the gating system are located in an anatomically appropriate location below the cortical layers associated with the rest of the model.
</p><p>The main processing of information in the model follows the usual path from Input to Hidden to Output.  However, to make appropriate responses based on the information that came on earlier trials, the Hidden layer needs access to the information maintained in the PFC (prefrontal cortex) layer.  The PFC will maintain information in an active state until it receives a gating signal from the basal ganglia gating system, at which point it will update to encode (and subsequently maintain) information from the current trial.  In this simple model, the PFC acts just like a copy of the sensory input information, by virtue of having direct one-to-one projections from the Input layer.  This makes it easy to see directly what the PFC is maintaining -- the model also functions very well if the PFC representations are distributed and learned, as is required for more complex tasks.
</p><p>Now for a brief overview of the basal ganglia gating system (for complete details about these layers, see the  [<a href=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly\" class=\"external text\" title=\"http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly\" rel=\"nofollow\">and Frank, 2006</a>] paper (O'Reilly, R.C. &amp; Frank, M.J. (2006). Making Working Memory Work: A Computational Model of Learning in the Frontal Cortex and Basal Ganglia. <i>Neural Computation, 18,</i> 283-328.)
</p>
<ul><li> Matrix: this is the dynamic gating system representing the matrix units within the dorsal striatum of the basal ganglia.  Every even-index unit within a stripe represents \"Go\", while the odd-index units represent \"NoGo.\"  If overall more Go units fire, this will cause updating of the PFC, but if more NoGo units fire, this will prevent updating and cause the PFC to maintain its existing memory representation.
</li><li> SNrThal: represents the output of the basal ganglia system, abstracting across substantia nigra pars reticulata (SNr), globus pallidus, and Thalamus, which implement the gating signal contingent on relative Go-NoGo activity in the Matrix.  If there is more overall Go activity, then the SNrThal unit gets activated, providing bottom-up excitation and driving updating in PFC.
</li><li> PV* and LV* and friends at the very bottom layer of the network: these represent the dopaminergic system, which provides reinforcement learning signals to train up the dynamic gating system in the basal ganglia.  The PV layers represent primary values of reward (i.e., actual externally-delivered reward values), while the LV layers represent learned (\"anticipated\") values -- together, they account for Pavlovian conditioning phenomena and associated dopaminergic firing data.  They represent an alternative to the TD reinforcement learning model described in Chapter 6.
</li></ul>
<ul><li> To explore the model's connectivity, click on r.wt and on various units within the layers of the network.
</li></ul>
<p>Now, let's step through some trials to see how the task works.
</p>
<ul><li> Switch back to viewing activations (act).  Do Init, Step in the control panel.  Then press F5 or do View/Refresh on the main menu, which will display the names of the units.
</li></ul>
<p>Unlike the model described in the textbook, the task commands (Store, Ignore, Recall) are chosen completely at random (subject to the constraint that you can't store until after a recall, and you can't recall until after a store)  so you could get either an ignore or a store input.  You should see either the S or I task control input, plus one of the stimuli (A-D) chosen at random. The target output response should also be active, as we're looking at the plus phase information (stepping by trials). 
</p><p>Notice that if the SNrThal unit is active,  the PFC layer has just been updated to maintain this current input information.
</p>
<ul><li> Hit Step again.
</li></ul>
<p>You should now see a new input pattern. If the SNrThal gating signal is active again, then the PFC will again update its representations to reflect this new input. But if the SNrThal unit is not active (due to more overall NoGo activity), PFC will maintain its previously stored information.
</p>
<ul><li> Keep hitting Step and noticing the pattern of updating and maintenance of information in PFC, and how this is driven by the activation of the SNrThal unit (which in turn is driven by the Matrix Go vs. NoGo units, which in turn are being modulated by dopamine from the PVLV system to learn how to better control maintenance in the PFC!).
</li></ul>
<p>When you see a R (recall) trial, look at the DA unit in the back of the bottom layer.  If the network is somehow able to correctly recall (or guess!), then this unit will have a positive (yellow) activation, indicating a better-than expected performance.  Most likely, it instead will be teal blue and inverted, indicating a negative dopamine signal from worse-than expected performance (producing the wrong response).  This is the reinforcement training signal that controls the learning of the Matrix units, so that they can learn when information in PFC is predictive of reward (in which case that information should be updated in future trials), or whether having some information in PFC is not rewarding (in which case that information should not be updated and stored in future trials). 
</p>
<ul><li> You can continue to Step and observe the dynamics of the network.  When your mind is sufficiently boggled by the complexity of this model, then go ahead and hit Run, and switch to the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.EpochOutputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.EpochOutputData (page does not exist)\">.T3Tab.EpochOutputData</a> tab.
</li></ul>
<p>You will see various different values being plotted as the network learns:
</p>
<ul><li> <b>cnt_err</b> (black line): shows the overall number of errors per epoch (one epoch is 100 trials in this case), which quickly drops to around 10-15, which is basically the number of recall trials (the others are quickly learned as they do not require any active maintenance).
</li><li> <b>S_da</b> (red line): shows the amount of dopamine delivered on Store trials, on average.  This should decrease at the start (the PVLV system has a novelty bias that provides early initial dopamine) but then start to increase as the network starts to get the recall trials correct, tracking the cnt_err performance (i.e., when error goes down, S_da goes up, indicating correct store trials that were reinforced).  This dopamine signal delivered to the Store trials is the key for allowing the Matrix units to learn that storing information leads to subsequent rewards.  It results from the PVLV system recognizing that, if the basal ganglia system does fire Go and update the Store information into the PFC, this pattern of activation in PFC has been associated with reward in the past, and thus some dopamine should be delivered to reinforce the updating of that store information.
</li><li> <b>I_da</b> (blue line): shows dopamine for Ignore trials, which just delines and stays around zero, because the network does not get any reliable reward associated with encoding ignore information into the PFC.
</li><li> <b>R_da</b> (green line): shows dopamine for Recall trials (when the network's recall performance is directly rewarded or punished).  As you can see, this value always tends to converge to a mean of zero, but with very large fluctuations on either side.  This is because it reflects the <i>difference from expectation</i>, and the system quickly adapts its expectations based on how it is actually doing.  Thus, the main signals to notice here are when the network suddenly starts doing better than on the previous epoch (cnt_err drops) -- this should be associated with a peak in R_da, whereas a sudden increase in errors (worse performance) results in a dip in R_da.
</li></ul>
<p>The network can take roughly 30-100 epochs or so to train (it will stop when cnt_err gets to 0). 
</p>
<ul><li> Once it has trained to this criterion, you can switch back to viewing the network, and Step through trials to see that it is indeed performing correctly. Pay particular attention to the SNrThal activation and what the PFC is maintaining as a result.
</li></ul>
<p><b>NOTE:</b> the following question is different than the one in the textbook.  Your instructor may have you skip this question (or not) -- be sure to check.
</p>
<hr>
<p><b>Question 9.12 (a)</b> <em> Report the relativel levels of DA unit firing to the S, I and R trials at the end of learning. <b>(b)</b> Explain why these differences arise, and how they contribute to helping the network solve the task. Now, turn the network display back on in the SIRnet tab, and step  through a trial using the Control Panel. <b>(c)</b> Report whether there is more Go or NoGo unit activity in the Striatum for a couple of different Store and Ignore trials. You should see that the SNrThal (BG gating output) unit is active only when there is more Go than NoGo activity. Explain how the differences in Go/NoGo  activity patterns arise. </em>
</p>
<hr>
<p>Now we will see that the Matrix (striatum), which controls updating, and the PVLV reinforcement learning system, contribute differently to solving the overall problem. 
</p><p>Click on s.wt in the SIRnet panel, and then click on individual S and I units in the Input layer to show the learned sending weights from these units to other layers in the network.  You should see greater weights from the Input Store unit to Matrix Go than to NoGo units, confirming that the Matrix learned Go to update the Store stimulus. The opposite should be true for the Ignore stimulus (you might have to change the color scale displaying the weight values in the SIRNet tab for this to be obvious). Next, click on the S and I units in the PFC layer, and you should see similarly, that  in this case the difference may be less clear.  This is because it is useful to update store signals when they are in the Input, but the network should not necessarily update when the Store signals are maintained in PFC (e.g., if the Input pattern is currently Ignore). Thus in this simple WM task, the Input pattern is most relevant for dictating when the Matrix should update or not.
</p><p>Next, we examine whether this distinction between Input and PFC weights applies to the evaluation of reward value by the reinforcement learning system. Click again on the S and I units in the Input and PFC layers, while still viewing s.wt, and observe the weights into the LVe layer at the bottom right of the network. This layer corresponds to a part of the amygdala, and reflects the learned value (LV) of reward that the reinforcement learning system attributes to its inputs (note that the RL system can evaluate reward values of both external inputs from the environment, but can also evaluate the value of its PFC internal states). Weights to the units in the LVe layer labeled \"1\" reflect that this layer assigns a high reward value to the sending unit. Similarly, stronger weights toe the units labeled \"0\" reflect that this layer assings a low reward value to the sending unit.
</p>
<hr>
<p><b>Question 9.12 cont'd: (d)</b> <em> Report the sending (s.wt) weights from the S and I units in both the Input and PFC layers to the LVe layer. Are there qualitative differences between the learned reward value in the LVe layer of the Store input unit compared to that of the Store PFC unit? How about the Ignore weights from Input and PFC?  Based on the lecture notes and what you know about how this system learns, why do you think this might be?</em>
</p>
<hr>
<ul><li> When you are done with this simulation, you can either close this project in preparation for loading the next project, or you can quit completely from the simulator.
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 3/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:125-0!1!0!!en!2!edit=0 and timestamp 20090907093800 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_PFC_Maint_Updt\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_PFC_Maint_Updt</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_PFC_Maint_Updt\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_PFC_Maint_Updt&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_PFC_Maint_Updt&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_PFC_Maint_Updt&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_PFC_Maint_Updt\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_PFC_Maint_Updt\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_PFC_Maint_Updt\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_PFC_Maint_Updt&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_PFC_Maint_Updt&amp;oldid=400\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+PFC+Maint+Updt&amp;oldid=400&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+PFC+Maint+Updt&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 7 January 2009, at 09:11.</li>
					<li id=\"viewcount\">This page has been accessed 811 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.202 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_0";
   auto_open=0;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="overall control panel for pfc_maint_updt project";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="cycle updt_view";
     desc=" boolean value";
     cust_desc=0;
     base=.projects[0].programs.gp[0][5].vars[0]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="SIRNet phase no";
      desc=" phase as an ordinal number (regular phase is Phase enum)";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=LeabraNetwork::phase_no;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="SIRNet phase";
      desc=" type of settling phase<br>  MINUS PHASE:  minus phase<br>  PLUS PHASE:  plus phase";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=LeabraNetwork::phase;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="SIRNet trial";
      desc=" trial counter: number of external input patterns that have been presented in the current epoch (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="SIRNet trial name";
      desc=" name associated with the current trial (e.g., name of input pattern, typically set by a LayerWriter)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="SIRNet sse";
      desc=" sum squared error over the network, for the current external input pattern";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::sse;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="SIRNet epoch";
      desc=" epoch counter: number of times a complete set of training patterns has been presented (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::epoch;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][1]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Stop;
    };
   };
  };
  SelectEdit @[1] {
   name="PVLV";
   auto_edit=0;
   desc=;
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="pvi lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[0]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="lve lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[0].children[0]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="lvi lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[0].children[0].children[0]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[3] {
     label="pve rew";
     desc=" misc reward computation specifications<br>  err val: [Default: 0]  reward value for errors (when network does not respond correctly)<br>  norew val: [Default: 0.5]  reward value when no feedback information is present<br>  rew val: [Default: 1]  reward value for correct responses (positive rewards)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][0]$$;
     mbr=ExtRewLayerSpec::rew;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[4] {
     label="vta da";
     desc=" parameters for the pvlv da computation<br>  da gain: [Default: 0:2]  multiplier for dopamine values<br>  tonic da: [Default: 0]  set a tonic 'dopamine' (DA) level (offset to add to da values)<br>  pv gain: [Default: 1;0.1;0.5]  extra gain modulation of PV generated DA -- it can be much larger in general than lv so sometimes it is useful to turn it down (e.g., in new version of PBWM)<br>  add pv lv: [Default: false]  for cases where reward is expected/delivered, add PV and LV dopamine signals (otherwise, only use PV signal)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][5]$$;
     mbr=PVLVDaLayerSpec::da;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[5] {
     label="pvr lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[0].children[1]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[6] {
     label="nv lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[0].children[2]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[7] {
     label="pvi pv";
     desc=" misc parameters for the PV computation<br>  min pvi: [Default: 0.4]  minimum pvi value -- PVi is not allowed to go below this value for the purposes of computing the PV delta value: pvd = PVe - MAX(PVi,min_pvi)<br>  pvi scale min:  if both the PVe and PVi values are below min_pvi, then scale the result by (PVi/min_pvi) -- as PVi gets lower, meaning that it expects to be doing poorly, then punish the system less (but still punish it)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][2]$$;
     mbr=PViLayerSpec::pv;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[8] {
     label="lve lv";
     desc=" misc parameters controlling the LV computation (note: only the LVe instance of these parameters are used)<br>  min lvi: [Default: 0.1;0.4]  minimum lvi value -- LVi is not allowed to go below this value for the purposes of computing the LV delta value: lvd = LVe - MAX(LVi,min_lvi)<br>  lvi scale min:  if both the LVe and LVi values are below min_lvi, then scale the result by (LVi/min_lvi) -- as LVi gets lower, meaning that it expects to be doing poorly, then punish the system less (but still punish it)<br>  lrn pv only: [Default: true]  only compute weight changes on trials where primary rewards are expected or actually received -- the target PV value is only presented on such trials, but if this flag is off, it actually learns on other trials, but with whatever plus phase activation state happens to arise";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][3]$$;
     mbr=LVeLayerSpec::lv;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[9] {
     label="pvr pv detect";
     desc=" primary reward value detection spec: detect if a primary reward is expected based on PVr value<br>  thr: [Default: 0.7]  threshold on PVr value, above which PV is considered present (i.e., reward) -- PVr learns a 1 for all reward-valence cases, regardless of value, and .5 for reward absent";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][1]$$;
     mbr=PVrLayerSpec::pv_detect;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[10] {
     label="nv nv";
     desc=" novelty value specs<br>  da gain: [Default: 0:1]  gain for novelty value dopamine signal<br>  val thr: [Default: 0.1]  threshold for value (training value is 0) -- value is zero below this threshold";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][4]$$;
     mbr=NVLayerSpec::nv;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[11] {
     label="vta da";
     desc=" parameters for the pvlv da computation<br>  da gain: [Default: 0:2]  multiplier for dopamine values<br>  tonic da: [Default: 0]  set a tonic 'dopamine' (DA) level (offset to add to da values)<br>  pv gain: [Default: 1;0.1;0.5]  extra gain modulation of PV generated DA -- it can be much larger in general than lv so sometimes it is useful to turn it down (e.g., in new version of PBWM)<br>  add pv lv: [Default: false]  for cases where reward is expected/delivered, add PV and LV dopamine signals (otherwise, only use PV signal)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][9]$$;
     mbr=PVLVDaLayerSpec::da;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
  };
  SelectEdit @[2] {
   name="PBWM";
   auto_edit=1;
   desc=;
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="matrix g_bar";
     desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[0][3]$$;
     mbr=LeabraUnitSpec::g_bar;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="matrix lmix";
     desc=" mixture of hebbian & err-driven learning (note: no hebbian for CTLEABRA_XCAL)<br>  hebb:  [Default: .001] amount of hebbian learning (should be relatively small, can be effective at .0001)<br>  err:  [Default: .999] amount of error driven learning, automatically computed to be 1-hebb<br>  err sb: [Default: true]  apply exponential soft-bounding to the error learning component (applied in dWt)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[1][0].children[3]$$;
     mbr=LeabraConSpec::lmix;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="matrix xcal";
     desc=" XCAL (eXtended Contrastive Attractor Learning) learning parameters<br>  s mix: [Default: 0.9]  how much the short (plus phase) versus medium (trial) time-scale factor contributes to the synaptic activation term for learning -- s_mix just makes sure that plus-phase states are sufficiently long/important (e.g., dopamine) to drive strong positive learning to these states -- if 0 then svm term is also negated -- but vals < 1 are needed to ensure that when unit is off in plus phase (short time scale) that enough medium-phase trace remains to drive appropriate learning<br>  thr l mix: [Default: 0.001:1.0]  [0.01 to 0.008 std] amount that long time-scale average contributes to the adaptive learning threshold -- this is the self-organizing BCM-like homeostatic component of learning -- remainder is thr_m_mix -- medium (trial-wise) time scale contribution, which reflects pure error-driven learning<br>  d rev: [Default: 0.1]  proportional point within LTD range where magnitude reverses to go back down to zero at zero -- err-driven svm component does better with smaller values, and BCM-like mvl component does better with larger values -- 0.15 is a compromise<br>  d gain: [Default: 1]  multiplier on LTD values relative to LTP values -- generally do not change from 1<br>  d thr: [Default: 0.0001]  minimum LTD threshold value below which no weight change occurs -- small default value is mainly to optimize computation for the many values close to zero associated with inactive synapses";
     cust_desc=0;
     base=$.projects[0].networks[0].specs.gp[1][0].children[3]$;
     mbr=LeabraConSpec::xcal;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem_Group @.gp[0] {
     name="PFC";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="pfc g_bar";
      desc=" [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels<br>  e:  Excitatory (glutamatergic synaptic sodium (Na) channel)<br>  l:  Constant leak (potassium, K+) channel <br>  i:  inhibitory<br>  h:  hysteresis (Ca)<br>  a:  accomodation (k)";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[0][2]$$;
      mbr=LeabraUnitSpec::g_bar;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="pfc_m gate";
      desc=" parameters controlling the gating of pfc units<br>  graded out go: [Default: true]  use actual activation level of output Go signal to drive output activation level<br>  clear decay: [Default: 0.9]  how much to decay the activation state for units in the stripe when the maintenance is cleared -- simulates a phasic inhibitory burst (GABA-B?) from the gating pulse<br>  go learn base: [Default: 0.05]  how much PFC learning occurs in the absence of go gating modulation -- 1 minus this is how much happens with go gating -- determines how far plus phase activations used in learning can deviate from minus-phase activation state: plus phase act_nd = act_m + (go_learn_base + (1-go_learn_base) * gate_act) * (act - act_m)<br>  mid minus min:  minimum number of cycles before computing any gating -- acts like an STN-like function -- must be < network mid_minus_cycle<br>  max maint:  a hard upper-limit on how long the PFC can maintain -- anything over this limit will be cleared. set to 0 for motor areas that do not maintain but use maintenance gating to scope the set of possible responses<br>  out go clear: [Default: true]  an output Go clears the maintenance currents at the end of the trial -- only for reward trials (signalled by PVr) -- you use it, you lose it..";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[2][6]$$;
      mbr=PFCLayerSpec::gate;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="to_pfc lrate";
      desc="PFC requires a slower learning rate in general, around .005 if go_learn_base is set to default of .06, otherwise .001 for go_learn_base of 1";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[1][0].children[2]$$;
      mbr=LeabraConSpec::lrate;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="fm_pfc_mnt wt scale";
      desc="If SNrThal_out kwta k value is low (i.e., few output stripes activated in general), set wt_scale.rel to a lower value to compensate in balance between mnt and out projections";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[1][0].children[4]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="fm_pfc_out wt scale";
      desc="If SNrThal_out kwta k value is low (i.e., few output stripes activated in general), set wt_scale.rel to a lower value to compensate in balance between mnt and out projections";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[1][0].children[5]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="pfc_o gp kwta";
      desc="If SNrThal_out kwta k value is low (i.e., few output stripes activated in general), set dif_act_pct and act_pct to a lower value to compensate in balance between mnt and out projections";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[2][6].children[0]$$;
      mbr=LeabraLayerSpec::gp_kwta;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[6] {
      label="pfc_self wt scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[1][2]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[1] {
     name="Matrix";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="matrix matrix";
      desc=" misc parameters for the matrix layer<br>  da gain: [Default: 0:2]  overall gain for da modulation of matrix units for the purposes of learning (ONLY) -- bias da is set directly by gate_bias params -- also, this value is in addition to other 'upstream' gain parameters, such as vta.da.gain -- it is recommended that you leave those upstream parameters at 1.0 and adjust this parameter, as it also modulates rnd_go.nogo.da which is appropriate<br>  bias gain: [Default: 0.1]  overall gain factor for the gating biases as they are translated into multipliers on the net input values of Go vs. NoGo units -- allows the bias values to be expressed in standardized relative units and then overall impact can be dialed with this setting<br>  bias pos gain: [Default: 0]  extra multiplicative gain for positive bias terms -- it is in general not great to increase netinput levels on units beyond their natural values, so setting this to zero (default) puts all the bias work on decreasing the relative netinputs for the non-favored population (biologically can be going into a down state)<br>  mnt only:  set to true if there is only a MAINT matrix layer -- affects the way that rnd go is computed -- should also have PFCLayerSpec.gate.max_maint = 0";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[2][7]$$;
      mbr=MatrixLayerSpec::matrix;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="matrix gate bias";
      desc=" gating biases depending on different conditions in the network -- helps to get the network performing appropriately for basic maintenance functions, to then be reinforced or overridden by learning<br>  out rew go: [Default: 1]  (Weak) for OUTPUT stripes with active maintenance on reward trials (e.g., recall/output trials -- signalled by PVr), amount Go bias (favors Go over NoGo) to encourage the output gating units to respond -- see out_empty_nogo for empty (non-maintaining) stripes<br>  out norew nogo: [Default: 1:2]  (Strong) for all OUTPUT stripes (empty or maintaining) on non-reward trials (i.e., store, not recall trials -- signalled by PVr), amount of NoGo bias (favors NoGo over Go) to discourage output gating -- is not generally useful to output gate on store trials<br>  out empty nogo: [Default: 5]  (Very Strong) for OUTPUT stripes that are not maintaining anything, on reward trials (e.g., recall/output trials -- signalled by PVr), amount of NoGo bias (favors NoGo over Go) to discourage output gating if there is nothing being maintained to output gate<br>  mnt rew nogo: [Default: 5]  (Very Strong) for all MAINT stripes (empty or maintaining) on reward trials (e.g., recall/output trials -- signalled by PVr), amount of NoGo bias (favors NoGo over Go) -- adds to any mnt_mnt_nogo -- in general it is not useful to fire maint gating on recall/output trials (see pfc.gate spec -- can prevent entirely with flag there)<br>  mnt mnt nogo: [Default: 0]  for MAINT stripes that are maintaining on non-reward trials (i.e., store, not recall trials -- signalled by PVr), amount of NoGo bias (favors NoGo over Go) -- although this is useful for maintenance, it can get in the way of replacing outdated information, and so overall a null bias of 0 seems best<br>  mnt empty go: [Default: 0]  for empty MAINT stripes on non-reward trials (i.e., store, not recall trials -- signalled by PVr), amount of Go bias (favors Go over NoGo) -- provides a bias for encoding and maintaining new information -- keeping this at 0 allows system to be 'unbaised' in its selection of what to gate in, which appears to be useful in general";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[2][7]$;
      mbr=MatrixLayerSpec::gate_bias;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="matrix rnd_go";
      desc=" matrix random Go firing for nogo firing stripes case<br>  nogo thr: [Default: 20]  threshold of number of nogo firing in a row that will trigger NoGo random go firing<br>  rng eq thr: [Default: true]  set the nogo_rng value to be the same as nogo_thr -- this generally makes sense and is characteristic of the Poisson distribution, and reduces the number of parameters to confront..<br>  nogo rng: [Default: 20]  range of trials with nogo firing beyond nogo_thr to allow before engaging random go firing -- sets a new effective threshold after each nogo random go as nogo_thr + Random::IntZeroN(nogo_rng)<br>  nogo da: [Default: 10]  strength of DA for driving learning of random Go units -- does not affect performance, only learning<br>  nogo noise: [Default: 0;0.02]  use .02 when using -- noise value to apply to a randomly selected subset of k Go units to get them activated during a random Go event";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[2][7]$;
      mbr=MatrixLayerSpec::rnd_go;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="matrix noise";
      desc="For MAINT Matrix, default noise level is 5.0e-5 (.00005)";
      cust_desc=1;
      base=$.projects[0].networks[0].specs.gp[0][3]$;
      mbr=LeabraUnitSpec::noise;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="matrix noise adapt";
      desc=" how to adapt the noise variance (var) value<br>  trial fixed:  keep the same noise value over the entire trial -- prevents noise from being washed out and produces a stable effect that can be better used for learning -- this is strongly recommended for most learning situations<br>  k pos noise:  a special kind of trial_fixed noise, where k units (according to computed kwta function) chosen at random (permuted list) are given a positive noise.var value of noise, while the remainder get nothing -- approximates a k-softmax in some respects<br>  mode:  how to adapt noise variance over time<br>    FIXED NOISE:  no adaptation of noise: remains fixed at the noise.var value in the unit spec<br>    SCHED CYCLES:  use noise_sched over cycles of settling<br>    SCHED EPOCHS:  use noise_sched over epochs of learning<br>    PVLV PVI:  use PVLV PVi reward prediction values -- predicts primary value (PV) and inhibits it (i) -- only if a PVLV config is in place -- appropriate for output-oriented layers that are important for generating responses associated with rewards<br>    PVLV LVE:  use PVLV LVe reward prediction values -- learned value excitatory reward associations -- this can be active outside the time when primary rewards are expected, and is appropriate for working memory or other internal or sensory-oriented processing<br>    PVLV MIN:  use the minimum of PVi and LVe values -- an overall worst case appraisal of the state of the system<br>  min pct: [Default: 0.5]  minimum noise as a percentage (proportion) of overall maximum noise value (which is noise.var in unit spec)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[0][3]$;
      mbr=LeabraUnitSpec::noise_adapt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[5] {
      label="matrix_out noise";
      desc="For OUTPUT Matrix, default noise level is (.005)";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[0][3].children[0]$$;
      mbr=LeabraUnitSpec::noise;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[6] {
      label="matrix_out noise adapt";
      desc=" how to adapt the noise variance (var) value<br>  trial fixed:  keep the same noise value over the entire trial -- prevents noise from being washed out and produces a stable effect that can be better used for learning -- this is strongly recommended for most learning situations<br>  k pos noise:  a special kind of trial_fixed noise, where k units (according to computed kwta function) chosen at random (permuted list) are given a positive noise.var value of noise, while the remainder get nothing -- approximates a k-softmax in some respects<br>  mode:  how to adapt noise variance over time<br>    FIXED NOISE:  no adaptation of noise: remains fixed at the noise.var value in the unit spec<br>    SCHED CYCLES:  use noise_sched over cycles of settling<br>    SCHED EPOCHS:  use noise_sched over epochs of learning<br>    PVLV PVI:  use PVLV PVi reward prediction values -- predicts primary value (PV) and inhibits it (i) -- only if a PVLV config is in place -- appropriate for output-oriented layers that are important for generating responses associated with rewards<br>    PVLV LVE:  use PVLV LVe reward prediction values -- learned value excitatory reward associations -- this can be active outside the time when primary rewards are expected, and is appropriate for working memory or other internal or sensory-oriented processing<br>    PVLV MIN:  use the minimum of PVi and LVe values -- an overall worst case appraisal of the state of the system<br>  min pct: [Default: 0.5]  minimum noise as a percentage (proportion) of overall maximum noise value (which is noise.var in unit spec)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[0][3].children[0]$;
      mbr=LeabraUnitSpec::noise_adapt;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[7] {
      label="matrix lrate";
      desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[1][0].children[3]$;
      mbr=LeabraConSpec::lrate;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[8] {
      label="matrix_out lrate";
      desc="Default OUTPUT Matrix lrate is .1";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[1][0].children[3].children[2]$$;
      mbr=LeabraConSpec::lrate;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[9] {
      label="matrix_out rnd";
      desc=" Weight randomization specification. Note that NONE means no value at all, not the mean, and should be used if some other source is setting the weights, e.g., from a projectionspec or loading from a file etc<br>  type:  type of random variable to generate<br>    UNIFORM:  uniform with var = range on either side of the mean<br>    BINOMIAL:  binomial with var = p, par = n<br>    POISSON:  poisson with lambda = var<br>    GAMMA:  gamma with var and par = stages<br>    GAUSSIAN:  normal with var<br>    NONE:  just the mean<br>  mean:  mean of random distribution<br>  var:  'varibility' parameter for the random numbers (gauss = standard deviation, not variance; uniform = half-range)<br>  par:  extra parameter for distribution (depends on each one)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[1][0].children[3].children[2]$;
      mbr=ConSpec::rnd;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[10] {
      label="mtx_fm_pfc wt_scale";
      desc=" scale effective weight values to control the overall strength of a projection -- relative shifts balance among different projections, while absolute is a direct multipler<br>  abs: [Default: 1]  absolute scaling (not subject to normalization: directly multiplies weight values)<br>  rel:  [Default: 1] relative scaling that shifts balance between different projections (subject to normalization across all other projections into unit)<br>  sem extra: [Default: 2]  standard-error-of-the-mean (SEM) extra value to add to the average expected number of active connections to receive, for purposes of computing scaling factors with partial connectivity -- for 25% layer activity, binomial SEM = sqrt(p(1-p)) = .43, so 3x = 1.3 so 2 is a reasonable default, but can use different value to make scaling work better<br>  old: [Default: false]  use old way of computing netinput scaling factors -- please convert projects to using the new way (as of version 5.1.0) -- only affects connections with < full connectivity: does a much better job of normalizing these cases, and you should be able to just have abs/rel = 1 with no diff_act_pct on layer and it should just work -- see wiki for full docs and equations";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[1][0].children[3].children[0]$$;
      mbr=LeabraConSpec::wt_scale;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[2] {
     name="SNrThal";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="snr_thal kwta";
      desc=" desired activity level over entire layer (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)<br>  k from:  how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q<br>    USE K:  use the k specified directly<br>    USE PCT:  use the percentage pct to compute the k as a function of layer size<br>    USE PAT K:  use the activity level of the current event pattern (k = of units > pat_q)<br>  k:  desired number of active units in the layer<br>  pct:  desired proportion of activity (used to compute a k value based on layer size, .25 std)<br>  pat q: [Default: 0.2;0.5]  threshold for pat_k based activity level: add to k if ext > pat_q<br>  diff act pct: [Default: false]  if true, use different actual percent activity for overall layer activation<br>  act pct:  actual percent activity to put in kwta.pct field of layer<br>  gp i:  compute inhibition including all of the layers in the same group, or unit groups within the layer: each items computed inhib vals are multipled by gp_g scaling, then MAX'd, and each item's inhib is the MAX of this pooled MAX value and its original own value<br>  gp g:  how much this item (layer or unit group) contributes to the pooled layer group values";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[2][8]$$;
      mbr=LeabraLayerSpec::kwta;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="snrthal_out kwta";
      desc="Set OUTPUT kwta to a lower percent than MAINT kwta -- typically around 25% or so -- depends on how many different things PFC needs to maintain (lower the % for more maintenance demands)";
      cust_desc=1;
      base=.projects[0].networks[0].specs.gp[2][8].children[0]$$;
      mbr=LeabraLayerSpec::kwta;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="snrthal inhib";
      desc="Default is KWTA_AVG_INHIB with kwta_pt = .8 -- more competition but with some flexibility from avg-based computation";
      cust_desc=1;
      base=$.projects[0].networks[0].specs.gp[2][8]$;
      mbr=LeabraLayerSpec::inhib;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="snrthal snrthal";
      desc=" misc specs for snrthal layer<br>  net off: [Default: 0]  netinput offset -- how much to add to each unit's baseline netinput -- positive values make it more likely that some stripe will always fire, even if it has a net nogo activation state in the matrix -- very useful for preventing all nogo situations -- if net_off is .2 then act.gain should be 600, if net_off is 0 then act.gain should be 20 (dynamic range is diff)<br>  go thr: [Default: 0.5]  threshold in snrthal activation required to trigger a Go gating event<br>  rnd go inc: [Default: 0.1:0.2]  how much to add to the net input for a random-go signal triggered in corresponding matrix layer?<br>  leak: [Default: 1]  a leak-like term for the netinput computation -- just a constant added to the denominator in computing net input: (go - nogo) / (go + nogo + leak)";
      cust_desc=0;
      base=$.projects[0].networks[0].specs.gp[2][8]$;
      mbr=SNrThalLayerSpec::snrthal;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[4] {
      label="snc snc";
      desc=" misc params for SNc layer<br>  stripe lv pct: [Default: 0.5]  proportion of total LV dopamine value determined by stripe-wise LV signals from the patch layer -- remainder is from global LV signal<br>  global lv pct:  1 - stripe_lv_pct -- proportion of total LV dopamine value determined by global LV signals";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[2][5].children[0]$$;
      mbr=SNcLayerSpec::snc;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=5;
      val_type_fixed=0;
     };
    };
    name="Train";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [100] "S_C";"R_C";"S_D";"I_D";"I_C";"R_D";"I_A";"S_C";"I_D";"I_D";
"R_C";"S_B";"I_C";"R_B";"S_D";"R_D";"I_D";"I_C";"I_A";"I_A";
"S_C";"I_D";"R_C";"I_D";"I_D";"I_B";"I_B";"S_D";"I_A";"R_D";
"S_C";"I_B";"R_C";"S_D";"I_D";"R_D";"S_A";"R_A";"I_A";"I_B";
"I_A";"S_D";"I_C";"R_D";"I_D";"I_D";"S_C";"I_D";"R_C";"S_D";
"I_A";"R_D";"S_C";"R_C";"S_B";"I_B";"I_A";"R_B";"I_D";"I_A";
"I_B";"I_B";"S_D";"R_D";"I_D";"I_D";"I_A";"I_D";"I_A";"S_B";
"I_A";"R_B";"I_C";"I_B";"S_D";"I_D";"I_B";"R_D";"I_C";"I_A";
"S_B";"I_A";"R_B";"S_D";"R_D";"I_C";"I_C";"S_C";"R_C";"S_A";
"I_D";"I_A";"R_A";"S_B";"I_B";"R_B";"I_D";"S_B";"I_B";"I_B";
      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 1 100] 1;0;0;0;0;1;0;0;0;1;
0;0;0;0;1;0;0;0;0;0;
1;0;1;0;0;0;0;1;0;1;
0;0;0;1;0;0;0;1;0;0;
0;0;0;1;0;1;0;0;0;1;
0;0;0;0;1;0;0;1;0;0;
0;0;1;0;1;0;0;0;0;1;
0;0;1;0;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;0;0;0;0;1;0;
0;0;0;0;1;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
1;0;0;0;1;0;0;1;0;1;
0;0;0;0;1;0;1;0;0;0;
1;0;0;0;0;1;0;0;1;0;
0;0;0;1;0;0;1;0;0;0;
0;0;1;0;0;0;0;1;0;1;
0;0;0;0;1;0;1;0;0;1;
0;0;0;1;0;0;1;0;0;1;
0;0;0;0;0;1;0;1;0;1;
0;0;0;0;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;1;0;
0;1;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;1;
0;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;1;
0;0;0;0;1;0;0;1;0;0;
0;1;0;1;0;0;0;1;0;0;
0;0;0;1;0;1;0;0;0;1;
0;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;1;0;0;0;
0;1;1;0;0;0;0;1;0;0;
1;0;0;0;0;1;0;0;1;0;
0;0;0;1;0;0;0;0;0;1;
0;1;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;0;0;0;1;
0;0;0;1;0;0;0;0;1;0;
0;0;1;0;0;0;1;0;0;1;
0;0;0;1;0;1;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;1;0;1;0;1;0;0;0;
0;1;0;0;1;0;0;0;1;0;
0;1;0;0;1;0;0;0;0;0;
1;0;0;1;0;0;0;0;0;1;
0;0;0;0;1;0;1;0;0;0;
0;1;0;1;0;1;0;0;0;0;
1;0;0;0;0;1;0;1;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;1;0;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;1;
0;0;1;0;0;1;0;0;1;0;
0;0;0;0;1;0;1;0;0;0;
0;1;0;1;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;1;0;0;1;0;1;0;0;0;
1;0;0;0;1;0;0;0;1;0;
1;0;0;0;0;0;1;0;0;0;
0;1;0;0;0;0;0;1;0;0;
1;0;0;0;0;0;1;0;0;0;
1;0;0;1;0;0;0;1;0;1;
0;0;0;0;1;0;0;0;1;0;
0;0;0;1;0;0;1;0;0;0;
0;1;0;0;0;0;1;0;1;0;
1;0;0;0;0;0;1;0;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;1;0;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;1;1;
0;0;0;1;0;0;0;1;0;0;
1;0;0;0;1;0;0;1;0;0;
      };
     };
     float_Data @[2] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 4;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [4 1 100] 0;0;1;0;0;0;1;0;0;0;
0;1;0;0;0;1;0;0;1;0;
0;0;0;1;1;0;0;0;0;0;
1;0;0;0;0;1;0;0;0;1;
0;0;1;0;0;1;0;0;0;0;
1;0;0;1;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
1;0;1;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;1;0;0;
1;0;0;0;0;1;0;0;0;1;
0;1;0;0;0;1;0;0;0;0;
0;1;1;0;0;0;0;0;0;1;
0;0;1;0;0;1;0;0;0;0;
1;0;0;0;0;1;0;0;0;1;
0;0;0;1;1;0;0;0;1;0;
0;0;1;0;0;0;0;1;0;0;
1;0;0;0;0;0;0;1;0;0;
1;0;0;0;0;1;0;0;0;1;
0;0;0;1;0;0;1;0;0;0;
0;1;0;0;1;0;0;0;0;1;
1;0;0;0;0;0;0;1;0;0;
1;0;0;0;1;0;0;1;0;0;
0;1;0;0;1;0;0;0;0;1;
0;0;0;0;0;1;1;0;0;0;
0;1;0;0;0;1;0;0;0;0;
0;1;0;0;0;1;0;0;0;1;
0;0;0;1;1;0;0;0;0;0;
0;1;1;0;0;0;0;1;0;0;
1;0;0;0;0;1;0;0;0;0;
1;0;0;1;0;0;0;0;0;1;
0;0;0;1;0;1;0;0;0;0;
0;1;0;0;1;0;1;0;0;0;
0;1;0;0;1;0;0;0;0;1;
0;0;0;0;0;1;0;0;0;1;
0;0;1;0;0;0;1;0;0;0;
1;0;0;0;1;0;1;0;0;0;
0;0;0;1;1;0;0;0;1;0;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;0;0;1;0;1;
0;0;0;1;0;0;0;1;0;0;
      };
     };
     float_Data @[3] {
      name="RewTarg";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 100] 0;1;0;0;0;1;0;0;0;0;
1;0;0;1;0;1;0;0;0;0;
0;0;1;0;0;0;0;0;0;1;
0;0;1;0;0;1;0;1;0;0;
0;0;0;1;0;0;0;0;1;0;
0;1;0;1;0;0;0;1;0;0;
0;0;0;1;0;0;0;0;0;0;
0;1;0;0;0;0;0;1;0;0;
0;0;1;0;1;0;0;0;1;0;
0;0;1;0;0;1;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=1;
      val_type_fixed=0;
     };
     UserDataItem @[1] {
      name="MAT_VAL_TEXT";
      value 2 0=1;
      val_type_fixed=0;
     };
     UserDataItem @[2] {
      name="WIDTH";
      value 6 0=3.299999952316284;
      val_type_fixed=0;
     };
    };
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 7;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [7 1 1] "S";"I";"R";"A";"B";"C";"D";      };
     };
     String_Data @[1] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 4;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [4 1 1] "A";"B";"C";"D";      };
     };
     String_Data @[2] {
      name="RewTarg";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 1] "rew_targ";      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;5;
5;5;5;5;5;5;5;5;5;      };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;61;62;63;64;65;66;67;68;      };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] "S_C";"R_C";"S_D";"I_D";"I_C";"R_D";"I_A";"S_C";"I_D";"I_D";
"R_C";"S_B";"I_C";"R_B";"S_D";"R_D";"I_D";"I_C";"I_A";"I_A";
"S_C";"I_D";"R_C";"I_D";"I_D";"I_B";"I_B";"S_D";"I_A";"R_D";
"S_C";"I_B";"R_C";"S_D";"I_D";"R_D";"S_A";"R_A";"I_A";"I_B";
"I_A";"S_D";"I_C";"R_D";"I_D";"I_D";"S_C";"I_D";"R_C";"S_D";
"I_A";"R_D";"S_C";"R_C";"S_B";"I_B";"I_A";"R_B";"I_D";"I_A";
"I_B";"I_B";"S_D";"R_D";"I_D";"I_D";"I_A";"I_D";"I_A";      };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] "S";"R";"S";"I";"I";"R";"I";"S";"I";"I";
"R";"S";"I";"R";"S";"R";"I";"I";"I";"I";
"S";"I";"R";"I";"I";"I";"I";"S";"I";"R";
"S";"I";"R";"S";"I";"R";"S";"R";"I";"I";
"I";"S";"I";"R";"I";"I";"S";"I";"R";"S";
"I";"R";"S";"R";"S";"I";"I";"R";"I";"I";
"I";"I";"S";"R";"I";"I";"I";"I";"I";      };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;      };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 35;35;35;35;35;35;35;35;35;35;
35;35;35;35;35;35;35;35;35;35;
35;35;35;35;35;35;35;35;35;60;
35;35;35;35;35;35;35;35;35;35;
35;35;35;60;35;35;35;35;35;35;
35;60;35;35;35;35;35;60;35;35;
35;35;35;60;35;35;35;35;35;      };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0;1.9140711;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1.7545495;
0;0;0;0;0;0;0;1.9272115;0;0;
0;0;0;1.7699199;0;0;0;0;0;0;
0;2.0965545;0;1.9034524;0;0;0;1.7863935;0;0;
0;0;0;1.0599486;0;0;0;0;0;      };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] -1.1;0;-1.1;-1.1;-1.1;1;-1.1;-1.1;-1.1;-1.1;
1;-1.1;-1.1;1;-1.1;1;-1.1;-1.1;-1.1;-1.1;
-1.1;-1.1;1;-1.1;-1.1;-1.1;-1.1;-1.1;-1.1;0;
-1.1;-1.1;1;-1.1;-1.1;1;-1.1;0;-1.1;-1.1;
-1.1;-1.1;-1.1;0;-1.1;-1.1;-1.1;-1.1;1;-1.1;
-1.1;0;-1.1;0;-1.1;-1.1;-1.1;0;-1.1;-1.1;
-1.1;-1.1;-1.1;0;-1.1;-1.1;-1.1;-1.1;-1.1;      };
     };
     float_Data @[9] {
      name="DA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.087135851;-0.40151769;-0.27537969;-0.00045441091;0.0022136867;0.59879816;-0.012886494;-0.0015107095;7.4952841e-05;4.1723251e-07;
0.54186147;0.32877082;-0.0014482141;0.24031627;0.038336933;0.44024226;0.068992257;0.005179882;-0.087058634;-4.1723251e-07;
0.10654077;-0.0007044673;0.33574277;0.11948425;-5.364418e-07;0;0;-0.031443596;-0.10092661;-0.55713844;
0.12031746;-0.0008327961;0.36461735;0.10160369;-0.0061851144;0.36177951;0.14164001;-0.69992906;-0.23471299;-0.0010157526;
0.0010146648;0.097166464;0.00099700689;-0.50235015;-0.1779927;-5.8114529e-06;0.20462099;-0.0002527833;0.50145733;-0.05550763;
-0.17920536;-0.41994664;0.24171305;-0.5833891;0.2854926;0.000238657;-0.5547756;-0.4024269;-0.28013903;0.00059576333;
-0.00059480965;-8.3446503e-07;0.091650635;-0.40271607;-0.21017337;-3.606081e-06;-0.069365591;-0.00059552491;0.00059480965;      };
     };
     float_Data @[10] {
      name="PVe";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.5;0;0.5;0.5;0.5;1;0.5;0.5;0.5;0.5;
1;0.5;0.5;1;0.5;1;0.5;0.5;0.5;0.5;
0.5;0.5;1;0.5;0.5;0.5;0.5;0.5;0.5;0;
0.5;0.5;1;0.5;0.5;1;0.5;0;0.5;0.5;
0.5;0.5;0.5;0;0.5;0.5;0.5;0.5;1;0.5;
0.5;0;0.5;0;0.5;0.5;0.5;0;0.5;0.5;
0.5;0.5;0.5;0;0.5;0.5;0.5;0.5;0.5;      };
     };
     float_Data @[11] {
      name="PVi";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.49848232;0.38158992;0.49633026;0.4986932;0.49879819;0.26141816;0.49916878;0.49881855;0.49990052;0.49990359;
0.45804211;0.50418627;0.50299287;0.7626766;0.4988164;0.55857414;0.50021166;0.50039989;0.49922979;0.49925855;
0.50037044;0.50050884;0.66476607;0.50079149;0.50076711;0.50082272;0.50080073;0.49954966;0.49931282;0.55645126;
0.5008648;0.50075978;0.63614243;0.49966195;0.500314;0.63853449;0.50066859;0.70059764;0.49813861;0.49773446;
0.49820492;0.49825656;0.4998166;0.50216675;0.49904755;0.49905506;0.49971518;0.50024921;0.49879187;0.4978202;
0.49827719;0.41822383;0.50118446;0.58457357;0.50301921;0.5020752;0.49757311;0.28974727;0.49729526;0.49720007;
0.49688238;0.49694622;0.49728394;0.28204027;0.4988713;0.49888742;0.49737886;0.49759325;0.49747205;      };
     };
     float_Data @[12] {
      name="LVe";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.59360456;0;0.23106483;0.23033588;0.23280284;1;0.46488425;0.49108869;0.49114832;0.49114832;
1;0.85418493;0.85255957;1;0.5490194;1;0.58140707;0.58687687;0.46488425;0.46488419;
0.60331607;0.60258299;1;0.63116711;0.63116658;0.63116658;0.63116658;0.60181212;0.46488425;0;
0.63203508;0.63116747;1;0.61638808;0.60983133;1;0.65865791;0;0.24130395;0.24028897;
0.24130322;0.37685686;0.37780756;0;0.33376336;0.33375725;0.5390361;0.5387432;1;0.4576259;
0.24130395;0;0.75615919;0;0.81485456;0.81478143;0.2052456;0;0.19250058;0.19308074;
0.19250114;0.19250035;0.32351467;0;0.2992996;0.29929534;0.19308144;0.19250114;0.19308074;      };
     };
     float_Data @[13] {
      name="LVi";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.50646871;0;0.50644451;0.50616997;0.50642323;1;0.47777075;0.50548589;0.50547057;0.50547016;
1;0.52541411;0.52523696;1;0.51068246;1;0.51241481;0.51270473;0.47777075;0.4777711;
0.50966221;0.5096336;1;0.51168287;0.51168287;0.51168287;0.51168287;0.51377201;0.47777075;0;
0.51171762;0.51168281;1;0.5147844;0.51441276;1;0.5170179;0;0.47601694;0.47601771;
0.4760173;0.51440448;0.51435816;0;0.51175606;0.51175576;0.51241362;0.51237351;1;0.51313353;
0.47601694;0;0.51444614;0;0.52936196;0.52905017;0.47428995;0;0.47263959;0.472624;
0.47263923;0.47263926;0.51200294;0;0.50947297;0.50947231;0.472624;0.47263923;0.472624;      };
     };
     float_Data @[14] {
      name="absDA";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [69] 0.087135851;0.40151769;0.27537969;0.00045441091;0.0022136867;0.59879816;0.012886494;0.0015107095;7.4952841e-05;4.1723251e-07;
0.54186147;0.32877082;0.0014482141;0.24031627;0.038336933;0.44024226;0.068992257;0.005179882;0.087058634;4.1723251e-07;
0.10654077;0.0007044673;0.33574277;0.11948425;5.364418e-07;0;0;0.031443596;0.10092661;0.55713844;
0.12031746;0.0008327961;0.36461735;0.10160369;0.0061851144;0.36177951;0.14164001;0.69992906;0.23471299;0.0010157526;
0.0010146648;0.097166464;0.00099700689;0.50235015;0.1779927;5.8114529e-06;0.20462099;0.0002527833;0.50145733;0.05550763;
0.17920536;0.41994664;0.24171305;0.5833891;0.2854926;0.000238657;0.5547756;0.4024269;0.28013903;0.00059576333;
0.00059480965;8.3446503e-07;0.091650635;0.40271607;0.21017337;3.606081e-06;0.069365591;0.00059552491;0.00059480965;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0;1;2;3;4;      };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.52402747;0.28379008;0.14435108;0.19008911;0.23383562;      };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 35;17;10;12;14;      };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.37037036;0.41666666;0.61538464;0.5;0.44;      };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 41.299999;37.869999;37.27;37.259998;36.52;      };
     };
     float_Data @[6] {
      name="Leabra_cur_lrate";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.0099999998;0.0099999998;0.0099999998;0.0099999998;0.0099999998;      };
     };
     float_Data @[7] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     float_Data @[8] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     float_Data @[9] {
      name="I_da";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] -0.038330212;-0.096187778;-0.051781934;0.011004623;-0.020897178;      };
     };
     float_Data @[10] {
      name="S_da";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.065801747;0.16290599;0.066168286;-0.026186779;0.048404917;      };
     };
     float_Data @[11] {
      name="R_da";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] -0.083285406;-0.055868942;0.047035161;-0.0071382723;-0.065323599;      };
     };
     float_Data @[12] {
      name="S_I_diff";
      col_flags=SAVE_ROWS|SAVE_DATA|CALC;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr="S_da - I_da";
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [5] 0.10413196;0.25909376;0.11795022;-0.037191402;0.069302097;      };
     };
    };
    data_flags=SAVE_ROWS|HAS_CALCS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="LeabraStartup";
   short_nm="Start";
   tags="Leabra, Startup";
   desc="run project in the background (replaces leabra_startup.css)
command line is: emergent -nogui -ni -p <project name>.proj [epochs=xxx] [batches=xxx] [tag=xxx]";
   flags=NO_STOP_STEP|STARTUP_RUN;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="datatable with training patterns -- not used by this program, but passed to train program";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="batch";
     var_type=T_Object;
     object_type=Program;
     object_val=.projects[0].programs.gp[0][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="tag";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="log_dir";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="log_file_nm";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][1]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="TrialOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    IfReturn @[0] {
     desc="don't run if running in the gui!";
     flags=;
     cond {
      expr="taMisc::gui_active";
     };
    };
    Comment @[1] {
     desc="add our special args from command line";
     flags=;
    };
    MiscCall @[2] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taMisc;
     method=taMisc::AddArgName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="flag";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"tag=\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"FileTag\"";
       };
      };
     };
    };
    MiscCall @[3] {
     desc=;
     flags=;
     result_var=NULL;
     object_type=taMisc;
     method=taMisc::AddArgName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="flag";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"logdir=\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="name";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"LogDir\"";
       };
      };
     };
    };
    RegisterArgs @[4] {
     desc="This is KEY!!! actuall processes all args, including those from ProgVarFmArg guys below";
     flags=;
    };
    Comment @[5] {
     desc="Initialize and set variables from args";
     flags=;
    };
    PrintExpr @[6] {
     desc=;
     flags=;
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
    };
    MethodCall @[7] {
     desc=;
     flags=;
     result_var=NULL;
     obj=.projects[0].programs[0].vars[0]$$;
     method=Program::Init;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
    MiscCall @[8] {
     desc=;
     flags=;
     result_var=.projects[0].programs[0].vars[1]$$;
     object_type=taMisc;
     method=taMisc::FindArgByName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"FileTag\"";
       };
      };
     };
    };
    MiscCall @[9] {
     desc=;
     flags=;
     result_var=.projects[0].programs[0].vars[2]$$;
     object_type=taMisc;
     method=taMisc::FindArgByName;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"LogDir\"";
       };
      };
     };
    };
    ProgVarFmArg @[10] {
     desc=;
     flags=;
     prog=$.projects[0].programs.gp[0][1]$;
     var_name="max_epoch";
     arg_name="epochs";
    };
    ProgVarFmArg @[11] {
     desc=;
     flags=;
     prog=$.projects[0].programs.gp[0][0]$;
     var_name="max_batch";
     arg_name="batches";
    };
    Comment @[12] {
     desc="Set log files";
     flags=;
    };
    MethodCall @[13] {
     desc="last arg is to include dmem proc number";
     flags=;
     result_var=.projects[0].programs[0].vars[3]$$;
     obj=.projects[0].programs[0].vars[4]$$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="ext";
       required=1;
       def_val=;
       expr {
	expr="\".epc.dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       expr {
	expr="log_dir";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       expr {
	expr="false";
       };
      };
     };
    };
    MethodCall @[14] {
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[4]$;
     method=DataTable::SaveDataLog;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       expr {
	expr="true";
       };
      };
     };
    };
    MethodCall @[15] {
     desc="last arg is to include dmem proc number";
     flags=OFF;
     result_var=$.projects[0].programs[0].vars[3]$;
     obj=.projects[0].programs[0].vars[5]$$;
     method=taBase::GetFileNameFmProject;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="ext";
       required=1;
       def_val=;
       expr {
	expr="\".trl.dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="tag";
       required=0;
       def_val="\"\"";
       expr {
	expr="tag";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="subdir";
       required=0;
       def_val="\"\"";
       expr {
	expr="log_dir";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_no";
       required=0;
       def_val="false";
       expr {
	expr="true";
       };
      };
     };
    };
    MethodCall @[16] {
     desc="last arg is to restrict log to dmem_proc = 0";
     flags=OFF;
     result_var=NULL;
     obj=$.projects[0].programs[0].vars[5]$;
     method=DataTable::SaveDataLog;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="const taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       expr {
	expr="log_file_nm";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="append";
       required=0;
       def_val="false";
       expr {
	expr="false";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="dmem_proc_0";
       required=0;
       def_val="true";
       expr {
	expr="false";
       };
      };
     };
    };
    OtherProgramVar @[17] {
     desc=;
     flags=;
     other_prog=.projects[0].programs.gp[0][9]$$;
     set_other=1;
     var_1=$.projects[0].programs[0].vars[1]$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    PrintExpr @[18] {
     desc=;
     flags=;
     expr {
      expr="\"Running: \" << batch.name";
     };
    };
    ProgramCall @[19] {
     desc=;
     flags=;
     prog_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       expr {
	expr="network";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="input_data";
       required=1;
       def_val=;
       expr {
	expr="input_data";
       };
      };
     };
     target=$.projects[0].programs.gp[0][0]$;
     targ_ld_init="*LeabraBatch*";
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags=;
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][1]$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 1762279555;-1994455733;-1542445361;-356645916;-597743321;780894009;-1968328061;-124422676;480079443;-1838419512;1568767676;1679107484;281271293;770387934;-243683164;-1390604046;-1860690240;-699927397;-596584438;274795680;1047239476;1693388697;1322352398;51324930;1097980642;-2143037784;2135599916;-666133028;845848599;140408880;1692867342;-1911442422;-762556600;-153654344;-2118020119;-118153510;-903459647;830347951;-1848562127;1084589382;-1366191061;551052630;-789249768;-100801838;-549235295;-841843945;-1519107310;338822527;1998987851;-1838472861;-288877449;-955374089;345017720;-150665075;1249009212;-482815160;2039185359;34646655;-112575659;-77304023;-1337764402;-66124359;471059616;-995009697;-748599412;-1114258772;-1408832280;-974474603;-649806990;1283747034;1820140973;1581050147;2126064818;-723554840;-1285152511;-1710579334;-2132611932;-894028853;1175483958;-482143486;2141784245;4506453;452759003;311110330;1843094966;-1124134776;-1136566072;538790409;711722725;1485981106;-1528345863;-952244126;57644961;613612514;1375163016;-1082269332;2085605062;1553339364;-14784837;1526660859;-840670458;1161543262;-1844710687;1810321142;-1203415333;-1161534202;1017577214;1833601185;1038452620;99378857;-204213733;1574263783;-1096460242;-1398843955;208773661;1667332836;1484589517;673647089;-1387272821;890953860;693975180;-790742091;-1080298168;-70098771;-58768606;2064196994;-1169954771;22331914;1754130546;277299424;758413538;-1869438035;-784581745;2037738177;-1397498298;684004699;-2018762641;-2093080438;1252236850;-644106838;1917132089;2121236389;986193986;67505305;-1219503635;-676666660;-772941427;-148515943;-2124421546;426038201;-802911853;788026983;1057502779;-1562380064;1153180612;-473855404;-356178961;-1418430279;715961701;-721838472;-710387161;178574549;381744555;424046618;-1283578650;-2067885415;-1042167091;-952155667;-1413521010;-393647899;765688168;-1353740621;1352074625;-1006195667;101223636;1049166931;564404335;-769313924;-843757363;303953913;55973617;-1344993590;-282806882;838315176;-625670400;-1623105560;679809548;-1048802441;-1125115520;-1829854457;1049034423;345206258;496952122;1709158563;322265772;1754397343;-485986534;-1418250590;1889807846;44547050;-1423745510;620165185;-166610065;1111473767;2094314762;-1407495900;-985769268;-2385030;-1004070771;-479023401;1402629750;-632535866;-297300083;586195419;1619726141;1017651075;130452103;254273308;1999645414;1833405694;-693626761;1083423393;596132350;-435881963;2035525518;-1953127604;-2054148952;-898721291;197223666;-51358113;-1785901262;175173335;-901756229;-564006015;-1467767500;1003754809;-1164517015;-1441385692;1781236972;-876001424;-1781875633;970752082;-286751924;-1691740642;674477568;-2100506891;307287913;-1391776156;-1912085194;1999782525;231512038;508298425;-812392711;-1736391777;-1463340305;-1856836224;224413514;-131548365;311331570;2134267005;-485903888;615727332;1588502266;181800206;382838158;-1590603761;-1465480405;-1001596616;1731151955;-1785107609;-1413255961;-274496408;-800226745;-383333915;1269022416;-596696440;119669995;1266332876;-540669193;-2119506085;2108352565;1411215773;-592556122;585611828;-813806688;1220744044;-1638465505;1143837072;1876428885;1727807045;45282806;1475719473;1209112852;-445602962;1088475175;-1591708123;-1608876661;-1839146698;1960740526;-1264071882;-1872887632;1616087399;2135346284;-1387266768;862758890;-1088390525;-1897505001;525910396;2012459808;-1880533446;-1581580978;-580412365;1371951144;-515730842;475975699;-1555610694;140718292;705673441;-62170365;1517152319;5754806;-1765320177;506625379;549090386;2014168990;1184684544;781421739;1395327934;-2093829469;-1291869234;-132657978;1398552580;-511719355;1535212267;2034416032;-1945016620;-1430251074;800310397;561933219;-1813007454;236093300;-542286311;-1854403688;-339214567;-14511974;-1472991562;-1641577890;-354571353;734756112;1487268013;-1347626694;1610132599;1889612270;-455435348;1566119021;-1626940417;693776693;1230882894;-262451311;1989773313;-1403344536;-564882885;-1725585022;907108587;1814429987;1636279767;-484576036;1760949354;-607931737;-2125774811;2098606037;-131771369;-1656430248;171709431;-266071831;967698377;-182057787;-1174939241;-783509949;-1419802437;-2048199815;509338628;325262098;85217689;-1478618147;-1302777988;-1945359304;1913552485;1712808696;-1946136894;-1920740538;-672284837;-946170048;-507147784;1940112529;1673371227;537109774;2530835;274303501;-1601213008;841517770;2144001347;-532701540;-279597746;2141623797;-1935360295;1126138109;777568515;1399046855;620875703;1944118221;1547046167;-236064438;771703914;1480112496;-407526348;1359755859;-1253644805;-874906145;-689969809;1846563136;-860694198;903269491;1280128518;-628027029;929335217;152978303;931699142;-1080450358;-1556987243;-828893631;1505237945;1317038408;1577098366;1165407949;-12760017;640064272;-1280917755;1244995193;696991503;-166205021;-959066663;1987699388;-409429172;-1652846873;-981799146;419795463;-863412862;801304229;1277261274;-1908231127;-471262790;1774856385;164681093;-1806996417;-1873192232;953517002;-2109072773;-726256505;-1919328801;-1110946051;-817454232;809483781;1945741000;-1220583395;-347437812;-1392212035;-106445010;-1224496235;-1872264344;-1374645080;1421845225;1377922912;1131600926;754348309;-1823351772;-81382694;2000106106;-668483739;-790226147;-182598986;1357099082;960082553;1637166240;2032387689;1025700077;1681056871;186168357;573170049;2059076302;-403577707;2111665945;-1899768220;97136171;-492422171;216906157;1642256433;763428065;-782291017;-922671113;-209561288;684378428;1851163298;713017158;553129622;-1408159449;169357971;1419878650;768071683;780588588;-284947110;1630332700;-332352143;1315936763;1497664420;1414096668;-1762708107;977127672;699728862;378427037;-1395838215;1176138256;435231679;-1707988122;247440512;-534484851;-1372372972;807276733;1140638113;-508099023;1122252236;2037313780;980103101;1929444518;1126829817;174236143;589024355;353214504;-634545694;-1669455648;2072636742;-27877856;-910024467;-877109755;607670398;-927125033;1058741958;-929751999;-1933477330;-102055551;1572531312;643744700;-2075732140;1149893911;377201112;-1790217117;1655952753;1144792925;5227898;-1367526063;1379170031;718949399;-2089200059;503057206;-857058174;-80518630;-713812205;-1198216313;789895857;1662649102;1850687013;-796865937;1209510616;1404275418;1260518821;-190720013;1207542768;634431830;2135676720;1567367576;819143841;776904394;-410729992;-1794319026;-845873852;-1203507636;2037826832;180935424;-1150195380;1849379859;-442980504;-21015930;1111997897;458615353;919399375;263442942;1397016970;-791942868;-1266276127;-419127578;-1843511375;401272568;1381696050;-981849222;-2033849831;-518335996;-601121247;-540829751;1391197970;2215904;1421206978;1343095634;814988579;712399924;-1921632534;1935528943;-302973618;1086138058;2012214145;1668977643;-1679124546;-2065335399;49068437;-976685256;      };
      mti=624;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=500;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][1].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][1].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[6]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     If @[3] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
     AssignExpr @[4] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[5] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=1;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[6] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=.projects[0].programs.gp[0][4]$$;
    step_n=1;
   };
   Program @[2] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=69;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=69;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[0].programs.gp[0][2].vars[3]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[1]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$.projects[0].programs.gp[0][2].vars[3]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     ProgramCall @[3] {
      desc=;
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[1][0]$$;
      targ_ld_init="*SIR1Env*";
     };
     MethodCall @[4] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[2]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[5] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$.projects[0].programs.gp[0][2].args[0]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[0].programs.gp[0][2].args[1]$$;
      index_var=.projects[0].programs.gp[0][2].vars[4]$$;
      order_var=.projects[0].programs.gp[0][2].vars[0]$$;
      order=SEQUENTIAL;
      item_idx_list{ 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50;51;52;53;54;55;56;57;58;59;60;61;62;63;64;65;66;67;68;69;70;71;72;73;74;75;76;77;78;79;80;81;82;83;84;85;86;87;88;89;90;91;92;93;94;95;96;97;98;99;      };
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     IfElse @[6] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[8] {
      desc=;
      flags=NON_STD;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable;
	type="DataTable*";
	name="trial_mon_data";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
      };
      target=.projects[0].programs.gp[2][0]$$;
      targ_ld_init="*TrialAnal*";
     };
     ProgramCall @[9] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     MethodCall @[10] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[3]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[3] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][4]$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[5] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=35;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=35;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][4].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][4].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][5]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][5].args[0]$;
      update_var=$.projects[0].programs.gp[0][5].vars[0]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags=;
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="RewTarg";
	net_target=LAYER;
	layer_name="RewTarg";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[3] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     UserScript @[1] {
      desc="group_name = action ";
      flags=NON_STD;
      script {
       expr="network.group_name = network.trial_name.before(\"_\");";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraTrialMonitorPVLV";
    short_nm="TrlMon";
    tags=;
    desc="monitor trial-level data from the network";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="DA";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="PVe";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="PVi";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="LVe";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[13] {
	name="LVi";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[14] {
	name="absDA";
	computed=1;
	object_type=LeabraLayer;
	object=NULL;
	variable="dav";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data.";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.VTA.units[0].act_p";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"DA\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[3] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.PVe.units[0].act_p";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"PVe\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.PVi.units[0].act_m";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"PVi\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.LVe.units.Leaf(0).act_p";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"LVe\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[6] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="network.layers.LVi.units.Leaf(0).act_p";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"LVi\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[7] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="fabs(network.layers.VTA.units[0].act_p)";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"absDA\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[8] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[9] {
      desc="only functional for dmem projects: synchronizes trial data across processes";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraEpochMonitorPVLV";
    short_nm="EpcMon";
    tags=;
    desc="monitor epoch-level data from the network";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="Leabra_cur_lrate";
	computed=0;
	object_type=LeabraConSpec;
	object=.projects[0].networks[0].specs[3]$$;
	variable="cur_lrate";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="S_da";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="I_da";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="R_da";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="S_I_diff";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][1]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][8].objs[0]$$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="grouped_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].programs.gp[2][0].objs[0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="abs_da_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[0].programs.gp[2][0].objs[1]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="tmp_val";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc=;
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data.";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     UserScript @[3] {
      desc="set the timing information from the epoch timer";
      flags=;
      script {
       expr="epoch_mon_data.SetDataByName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\");
epoch_mon_data.SetDataByName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\");

";
      };
     };
     MethodCall @[4] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::SetDataByName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="data";
	required=1;
	def_val=;
	expr {
	 expr="grouped_data.GetValColName(\"DA_mean\", 0)";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ch_nm";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"I_da\"";
	};
       };
      };
     };
     MethodCall @[5] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::SetDataByName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="data";
	required=1;
	def_val=;
	expr {
	 expr="grouped_data.GetValColName(\"DA_mean\", 1)";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ch_nm";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"R_da\"";
	};
       };
      };
     };
     MethodCall @[6] {
      desc=;
      flags=NON_STD;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::SetDataByName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="data";
	required=1;
	def_val=;
	expr {
	 expr="grouped_data.GetValColName(\"DA_mean\", 2)";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ch_nm";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"S_da\"";
	};
       };
      };
     };
     MethodCall @[7] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[2]$$;
      obj=.projects[0].programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[1] {
   name="SIREnv";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   Program @[0] {
    name="SIR1Env";
    short_nm="SIR1En";
    tags=;
    desc="store ignore recall working memory task environment -- supports 1item in memory at a time";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="Input";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="I_S";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="I_I";
	value=1;
	desc=;
       };
       DynEnumItem @[2] {
	name="I_R";
	value=2;
	desc=;
       };
       DynEnumItem @[3] {
	name="I_A";
	value=3;
	desc=;
       };
       DynEnumItem @[4] {
	name="I_B";
	value=4;
	desc=;
       };
       DynEnumItem @[5] {
	name="I_C";
	value=5;
	desc=;
       };
       DynEnumItem @[6] {
	name="I_D";
	value=6;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[1] {
      name="Output";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="O_A";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="O_B";
	value=1;
	desc=;
       };
       DynEnumItem @[2] {
	name="O_C";
	value=2;
	desc=;
       };
       DynEnumItem @[3] {
	name="O_D";
	value=3;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[2] {
      name="RewTarg";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="R_rew_targ";
	value=0;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[3] {
      name="Stims";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="No_Stim";
	value=-1;
	desc=;
       };
       DynEnumItem @[1] {
	name="S_A";
	value=0;
	desc=;
       };
       DynEnumItem @[2] {
	name="S_B";
	value=1;
	desc=;
       };
       DynEnumItem @[3] {
	name="S_C";
	value=2;
	desc=;
       };
       DynEnumItem @[4] {
	name="S_D";
	value=3;
	desc=;
       };
       DynEnumItem @[5] {
	name="N_Stims";
	value=4;
	desc=;
       };
      };
      bits=0;
     };
     DynEnumType @[4] {
      name="Actions";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="S";
	value=0;
	desc=;
       };
       DynEnumItem @[1] {
	name="I";
	value=1;
	desc=;
       };
       DynEnumItem @[2] {
	name="R";
	value=2;
	desc=;
       };
       DynEnumItem @[3] {
	name="N_Actions";
	value=3;
	desc=;
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="the data table to render the training patterns into";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="n_per_epc";
      var_type=T_Int;
      int_val=100;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="number of randomly generated trials to make per epoch (100 is default)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="n_stims";
      var_type=T_Int;
      int_val=4;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="number of stimuli to choose from (max of 4) ";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="n_store";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="number of stimuli to store at any given time (2 is max, 1 is easier)";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="cur_s_stim";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[3]$$;
       value=2;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stim currently stored";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="stim";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=$.projects[0].programs.gp[1][0].types[3]$;
       value=2;
      };
      objs_ptr=0;
      flags=USED|EDIT_VAL;
      reference=0;
      desc="current stim -- used internally";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="action";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[1][0].types[4]$$;
       value=1;
      };
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current action -- used internally";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="ev";
      var_type=T_Int;
      int_val=100;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="event counter";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      object_val=.projects[0].data.gp[0][1]$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="used by InitNamedUnits to setup enums and network, etc";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
     Function @[0] {
      desc=;
      flags=;
      name="MakeEvent";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name=;
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="stim_no";
	var_type=T_DynEnum;
	dyn_enum_val {
	 enum_type=$.projects[0].programs.gp[1][0].types[3]$;
	 value=-1;
	};
	objs_ptr=0;
	flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="act_no";
	var_type=T_DynEnum;
	dyn_enum_val {
	 enum_type=$.projects[0].programs.gp[1][0].types[4]$;
	 value=-1;
	};
	objs_ptr=0;
	flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
      fun_code {
       name=;
       el_typ=ProgVars;
       el_def=0;
       ProgVars @[0] {
	desc=;
	flags=;
	local_vars {
	 name=;
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="input_stim";
	  var_type=T_DynEnum;
	  dyn_enum_val {
	   enum_type=.projects[0].programs.gp[1][0].types[0]$$;
	   value=0;
	  };
	  objs_ptr=0;
	  flags=NULL_CHECK|LOCAL_VAR|USED;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="input_action";
	  var_type=T_DynEnum;
	  dyn_enum_val {
	   enum_type=$.projects[0].programs.gp[1][0].types[0]$;
	   value=0;
	  };
	  objs_ptr=0;
	  flags=NULL_CHECK|LOCAL_VAR|USED;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="output_stim";
	  var_type=T_DynEnum;
	  dyn_enum_val {
	   enum_type=.projects[0].programs.gp[1][0].types[1]$$;
	   value=0;
	  };
	  objs_ptr=0;
	  flags=NULL_CHECK|LOCAL_VAR|USED;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	desc=;
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[1][0].args[0]$$;
	method=DataTable::AddBlankRow;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       AssignExpr @[2] {
	desc="input stim start after actions";
	flags=;
	result_var=.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[0]$$;
	expr {
	 expr="stim_no + N_Actions";
	};
       };
       AssignExpr @[3] {
	desc=;
	flags=;
	result_var=.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[2]$$;
	expr {
	 expr="stim_no";
	};
       };
       AssignExpr @[4] {
	desc=;
	flags=;
	result_var=.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[1]$$;
	expr {
	 expr="act_no";
	};
       };
       IfElse @[5] {
	desc="recall?";
	flags=;
	cond {
	 expr="act_no >= R";
	};
	true_code {
	 name=;
	 el_typ=SetUnitsVar;
	 el_def=0;
	 SetUnitsVar @[0] {
	  desc="set only action on input, and stim on output";
	  flags=;
	  input_data_var=$.projects[0].programs.gp[1][0].args[0]$;
	  set_nm=1;
	  offset=NULL;
	  unit_1=$.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[1]$;
	  unit_2=$.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[2]$;
	  unit_3=NULL;
	  unit_4=NULL;
	 };
	 SetUnitsLit @[1] {
	  desc=;
	  flags=;
	  input_data_var=$.projects[0].programs.gp[1][0].args[0]$;
	  set_nm=0;
	  offset=0;
	  unit_1 {
	   enum_type=.projects[0].programs.gp[1][0].types[2]$$;
	   value=0;
	  };
	  unit_2 {
	   enum_type=NULL;
	   value=-1;
	  };
	  unit_3 {
	   enum_type=NULL;
	   value=-1;
	  };
	  unit_4 {
	   enum_type=NULL;
	   value=-1;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=SetUnitsVar;
	 el_def=0;
	 SetUnitsVar @[0] {
	  desc="set stim and action on input";
	  flags=;
	  input_data_var=$.projects[0].programs.gp[1][0].args[0]$;
	  set_nm=1;
	  offset=NULL;
	  unit_1=$.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[1]$;
	  unit_2=$.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[0]$;
	  unit_3=NULL;
	  unit_4=NULL;
	 };
	 SetUnitsVar @[1] {
	  desc="set stim on output";
	  flags=;
	  input_data_var=$.projects[0].programs.gp[1][0].args[0]$;
	  set_nm=0;
	  offset=NULL;
	  unit_1=$.projects[0].programs.gp[1][0].functions[0].fun_code[0].local_vars[2]$;
	  unit_2=NULL;
	  unit_3=NULL;
	  unit_4=NULL;
	 };
	};
       };
       DoneWritingDataRow @[6] {
	desc=;
	flags=;
	data_var=$.projects[0].programs.gp[1][0].args[0]$;
       };
      };
     };
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     InitNamedUnits @[0] {
      desc=;
      flags=;
      input_data_var=$.projects[0].programs.gp[1][0].args[0]$;
      unit_names_var=.projects[0].programs.gp[1][0].vars[7]$$;
      network_var=.projects[0].programs.gp[1][0].args[1]$$;
      n_lay_name_chars=1;
      max_unit_chars=-1;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[1][0].vars[3]$$;
      expr {
       expr="No_Stim";
      };
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[1][0].args[0]$;
      method=DataTable::RemoveAllRows;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ForLoop @[1] {
      desc=;
      flags=;
      loop_code {
       name=;
       el_typ=AssignExpr;
       el_def=0;
       WhileLoop @[0] {
	desc=;
	flags=;
	loop_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	 RandomCall @[0] {
	  desc=;
	  flags=;
	  result_var=.projects[0].programs.gp[1][0].vars[5]$$;
	  object_type=Random;
	  method=Random::IntZeroN;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=int;
	    type="int";
	    name="n";
	    required=1;
	    def_val=;
	    expr {
	     expr="N_Actions";
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  desc="don't store if already full!";
	  flags=;
	  cond {
	   expr="(action == S && cur_s_stim != No_Stim)";
	  };
	 };
	 IfContinue @[2] {
	  desc="can't recall if not stored!";
	  flags=;
	  cond {
	   expr="(action == R && cur_s_stim == No_Stim)";
	  };
	 };
	 IfBreak @[3] {
	  desc=;
	  flags=;
	  cond {
	   expr="true";
	  };
	 };
	};
	test {
	 expr="true";
	};
       };
       RandomCall @[1] {
	desc=;
	flags=;
	result_var=.projects[0].programs.gp[1][0].vars[4]$$;
	object_type=Random;
	method=Random::IntMinMax;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="min";
	  required=1;
	  def_val=;
	  expr {
	   expr="S_A";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="max";
	  required=1;
	  def_val=;
	  expr {
	   expr="N_Stims";
	  };
	 };
	};
       };
       Switch @[2] {
	desc=;
	flags=;
	switch_var=$.projects[0].programs.gp[1][0].vars[5]$;
	cases {
	 name=;
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   AssignExpr @[0] {
	    desc=;
	    flags=;
	    result_var=$.projects[0].programs.gp[1][0].vars[3]$;
	    expr {
	     expr="stim";
	    };
	   };
	  };
	  case_val {
	   expr="S";
	  };
	 };
	 CaseBlock @[1] {
	  desc="nothing to do here";
	  flags=OFF;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	  };
	  case_val {
	   expr="I";
	  };
	 };
	 CaseBlock @[2] {
	  desc=;
	  flags=;
	  prog_code {
	   name=;
	   el_typ=ProgEl;
	   el_def=0;
	   AssignExpr @[0] {
	    desc=;
	    flags=;
	    result_var=$.projects[0].programs.gp[1][0].vars[4]$;
	    expr {
	     expr="cur_s_stim";
	    };
	   };
	   AssignExpr @[1] {
	    desc=;
	    flags=;
	    result_var=$.projects[0].programs.gp[1][0].vars[3]$;
	    expr {
	     expr="No_Stim";
	    };
	   };
	  };
	  case_val {
	   expr="R";
	  };
	 };
	};
       };
       FunctionCall @[3] {
	desc=;
	flags=;
	result_var=NULL;
	fun=.projects[0].programs.gp[1][0].functions[0]$$;
	fun_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=DynEnum;
	  type="Stims";
	  name="stim_no";
	  required=1;
	  def_val=;
	  expr {
	   expr="stim";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DynEnum;
	  type="Actions";
	  name="act_no";
	  required=1;
	  def_val=;
	  expr {
	   expr="action";
	  };
	 };
	};
       };
      };
      init {
       expr="ev = 0";
      };
      test {
       expr="ev < n_per_epc";
      };
      iter {
       expr="ev++";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp[2] {
   name="Analysis";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   Program @[0] {
    name="TrialAnal";
    short_nm="Trlnl";
    tags=;
    desc=;
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      name="grouped_data";
      desc=;
      data {
       name="data";
       el_typ=DataColTp;
       el_def=0;
       String_Data @[0] {
	name="group_name_group";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] "I";"R";"S";	};
       };
       float_Data @[1] {
	name="DA_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] -0.020897178;-0.065323599;0.048404917;	};
       };
       float_Data @[2] {
	name="LVe_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] 0.52293581;0.44;0.55100375;	};
       };
       float_Data @[3] {
	name="LVi_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] 0.4986209;0.44;0.51083404;	};
       };
       float_Data @[4] {
	name="PVe_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] 0.5;0.44;0.5;	};
       };
       float_Data @[5] {
	name="PVi_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[3] 0.50051802;0.48137191;0.50024521;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
     DataTable @[1] {
      name="abs_da_data";
      desc=" ";
      data {
       name="data";
       el_typ=DataColTp;
       el_def=0;
       float_Data @[0] {
	name="absDA_mean";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[1] 0.19785891;	};
       };
       float_Data @[1] {
	name="absDA_max";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name=;
		[0] 	};
	ar {
	 name=;
		[1] 0.60144711;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="grouped_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].programs.gp[2][0].objs[0]$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="abs_da_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].programs.gp[2][0].objs[1]$;
      objs_ptr=1;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     DataGroupProg @[0] {
      desc=;
      flags=;
      src_data_var=.projects[0].programs.gp[2][0].args[0]$$;
      dest_data_var=.projects[0].programs.gp[2][0].vars[0]$$;
      group_spec {
       name="group_spec";
       ops {
	name=;
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="group_name";
	 agg {name="": op=GROUP: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[1] {
	 col_name="DA";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[2] {
	 col_name="LVe";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[3] {
	 col_name="LVi";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[4] {
	 col_name="PVe";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[5] {
	 col_name="PVi";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
     DataGroupProg @[1] {
      desc=;
      flags=;
      src_data_var=$.projects[0].programs.gp[2][0].args[0]$;
      dest_data_var=.projects[0].programs.gp[2][0].vars[1]$$;
      group_spec {
       name="group_spec";
       ops {
	name=;
	el_typ=DataGroupEl;
	el_def=0;
	DataGroupEl @[0] {
	 col_name="absDA";
	 agg {name="": op=MEAN: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
	DataGroupEl @[1] {
	 col_name="absDA";
	 agg {name="": op=MAX: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	};
       };
       append_agg_name=1;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=0.9975414872169495;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.801556408405304;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAxQAAAoIAAAMEAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name=;
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name=;
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name=;
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="Frame2";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="SIRNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=0;
	  net_text=1;
	  net_text_xform {scale={x=0.5000001: y=0.5000003: z=0.5000002: }: rotate={x=1: y=-4.808161e-08: z=-4.808162e-08: rot=1.011057: }: translate={x=0.8703725: y=0.04301716: z=0.05981667: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ r.wt;	  };
	  unit_src_path=".layers.gp[0][4].units.gp[0][1]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=22: y=9: z=2.333333: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.03;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=.projects[0].networks[0].layers.gp[2][0]$$;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name=;
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    name="gc_h";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    name="I_net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[8] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[9] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[10] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[11] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[12] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[13] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[14] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[15] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[16] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[17] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[18] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[19] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[20] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[21] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[22] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[23] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[24] {
	    name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[25] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[26] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[27] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[28] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[29] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[30] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[31] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[32] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[33] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[34] {
	    name="r_wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[35] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[36] {
	    name="bias.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[37] {
	    name="s.wt";
	    auto_scale=0;
	    min=-0.81;
	    max=0.81;
	   };
	   ScaleRange @[38] {
	    name="s.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[39] {
	    name="dav";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[40] {
	    name="wt_prjn";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Hidden=0;Input=0;Output=0;RewTarg=0;PVe=0;PVi=0;PVr=0;LVe=0;LVi=0;NV=0;VTA=-1;Patch=-1;SNc=-1;Matrix=0;SNrThal=0;PFC=0;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5685001: y=1.373089: z=1.242074: };
	 orient {x=-1.000001: y=0: z=0: rot=0.5699995: };
	 focal_dist=2.085844;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="EpochOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][1]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=19: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="avg_sse";
	    m_data=.projects[0].data.gp[1][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="cnt_err";
	    m_data=.projects[0].data.gp[1][1].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=53: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="avg_ext_rew";
	    m_data=.projects[0].data.gp[1][1].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="avg_cycles";
	    m_data=.projects[0].data.gp[1][1].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="Leabra_cur_lrate";
	    m_data=.projects[0].data.gp[1][1].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="epoch_time_tot";
	    m_data=.projects[0].data.gp[1][1].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="epoch_time_usr";
	    m_data=.projects[0].data.gp[1][1].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="I_da";
	    m_data=.projects[0].data.gp[1][1].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=-0.0748982: fix_max=0: max=0.0734915: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="S_da";
	    m_data=.projects[0].data.gp[1][1].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=-0.3: fix_max=1: max=0.3: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="R_da";
	    m_data=.projects[0].data.gp[1][1].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=-0.153983: fix_max=0: max=0.0955654: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="S_I_diff";
	    m_data=.projects[0].data.gp[1][1].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=4: };
	   range {min=0: max=4: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="cnt_err";
	   fixed_range {fix_min=1: min=0: fix_max=0: max=35: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=35: };
	   range {min=0: max=35: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="S_da";
	   fixed_range {fix_min=1: min=-0.3: fix_max=1: max=0.3: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.3: max=0.3: };
	   range {min=-0.3: max=0.3: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=1;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="I_da";
	   fixed_range {fix_min=0: min=-0.09618778: fix_max=0: max=0.01100462: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=-0.09618778: max=0.01100462: };
	   range {min=-0.09618778: max=0.01100462: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=1;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="R_da";
	   fixed_range {fix_min=0: min=-0.08328541: fix_max=0: max=0.04703516: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=-0.08328541: max=0.04703516: };
	   range {min=-0.08328541: max=0.04703516: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=1;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=1;
	  alt_y_3=1;
	  alt_y_4=1;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.548417: y=0.4449999: z=1.769298: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.781798;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[2] {
       name="TrialOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[1][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="trial";
	    m_data=.projects[0].data.gp[1][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=88: fix_max=0: max=88: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[1][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="group_name";
	    m_data=.projects[0].data.gp[1][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="phase_no";
	    m_data=.projects[0].data.gp[1][0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="minus_cycles";
	    m_data=.projects[0].data.gp[1][0].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="sse";
	    m_data=.projects[0].data.gp[1][0].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="ext_rew";
	    m_data=.projects[0].data.gp[1][0].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="DA";
	    m_data=.projects[0].data.gp[1][0].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=-1: fix_max=0: max=1.93361: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="PVe";
	    m_data=.projects[0].data.gp[1][0].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="PVi";
	    m_data=.projects[0].data.gp[1][0].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.4966997: fix_max=0: max=0.5244628: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="LVe";
	    m_data=.projects[0].data.gp[1][0].data[12]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.906462: fix_max=0: max=0.985944: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[13] {
	    name="LVi";
	    m_data=.projects[0].data.gp[1][0].data[13]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.627347: fix_max=0: max=0.92603: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[14] {
	    name="absDA";
	    m_data=.projects[0].data.gp[1][0].data[14]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.000419927: fix_max=0: max=1.644: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="trial";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=9: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=9: };
	   range {min=0: max=9: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=1;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="trial";
	   fixed_range {fix_min=0: min=88: fix_max=0: max=88: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=88: max=88: };
	   range {min=87.995: max=88.005: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="DA";
	   fixed_range {fix_min=1: min=-1: fix_max=0: max=0.5987982: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-1: max=0.5987982: };
	   range {min=-1: max=0.5987982: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="group_name";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green": r=0: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="violet": r=0.9333333: g=0.509804: b=0.9333333: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=VALUE_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name=;
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.379083: y=0.4449999: z=1.680814: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.693314;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[3] {
       name="DaByCommand";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  name=;
	  m_data=$.projects[0].programs.gp[2][0].objs[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="group_name_group";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="DA_mean";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="LVe_mean";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="LVi_mean";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="PVe_mean";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="PVi_mean";
	    m_data=.projects[0].programs.gp[2][0].objs[0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=2: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE_AND_POINTS;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="group_name_group";
	   fixed_range {fix_min=1: min=-0.2: fix_max=1: max=2.2: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.2: max=2.2: };
	   range {min=-0.2: max=2.2: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=1;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="DA_mean";
	   fixed_range {fix_min=1: min=-1: fix_max=0: max=0.04840492: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-1: max=0.04840492: };
	   range {min=-1: max=0.04840492: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="PVe_mean";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=10: };
	   range {min=0: max=10: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="green": r=0: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="group_name_group";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="violet": r=0.9333333: g=0.509804: b=0.9333333: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=VALUE_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name=;
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.4275: y=0.445: z=1.624621: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.637121;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[4] {
       name="InputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=5;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="RewTarg";
	    m_data=.projects[0].data.gp[0][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=5;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=3;
	  col_range {min=0: max=2: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name=;
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	 GridTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[0][1]$;
FloatTransform @*(.m_transform) {scale={x=0.348435: y=0.348435: z=0.348435: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.9198194: y=1.149791: z=9.345074e-08: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][1].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=7;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Output";
	    m_data=.projects[0].data.gp[0][1].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="RewTarg";
	    m_data=.projects[0].data.gp[0][1].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.348435: y=0.348435: z=0.348435: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=0.9198194: y=1.149791: z=9.345074e-08: }: };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=2;
	  col_range {min=0: max=1: };
	  width=3.3;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=1;
	  colorscale {
	   name=;
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0.1;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.05: max=0.2: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.552142: y=0.7340348: z=1.813945: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.817281;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7305447459220886;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="SIRNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    DaModUnitSpec @[0] {
     name="DaModUnitSpec_0";
     desc=;
     unique{ act_range;opt_thresh;clamp_range;     };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[3].children[0]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=1: range=1: scale=1: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.3: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=3.333333: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.1: i=1: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraLayerSpec @[1] {
     name="Hidden";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input";
       desc=;
       unique{ kwta;inhib_group;compute_i;i_kwta_pt;inhib;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_PAT_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=1: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
      LeabraLayerSpec @[1] {
       name="Output";
       desc=;
       unique{ kwta;inhib_group;compute_i;i_kwta_pt;inhib;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=1: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_AVG_INHIB;
      kwta_pt=0.6;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_PCT: k=12: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=1: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[2] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraConSpec @[3] {
     name="LeabraConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EXT_REW_STAT;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=80;
	 step=-0.01125;
	};
	SchedItem @[1] {
	 start_ctr=80;
	 start_val=0.1;
	 duration=1;
	 step=1;
	};
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.001: err=0.999: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EXT_REW_STAT;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=80;
       step=-0.01125;
      };
      SchedItem @[1] {
       start_ctr=80;
       start_val=0.1;
       duration=1;
       step=1;
      };
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.001: err=0.999: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    BaseSpec_Group @.gp[0] {
     name="PFC_BG_Units";
     el_typ=DaModUnitSpec;
     el_def=0;
     DaModUnitSpec @[0] {
      name="PVUnits";
      desc=;
      unique{ g_bar;act;act_fun;dt;opt_thresh;maxda;      };
      children {
       name=;
       el_typ=DaModUnitSpec;
       el_def=0;
       DaModUnitSpec @[0] {
	name="LVUnits";
	desc=;
	unique{ maxda;	};
	children {
	 name=;
	 el_typ=DaModUnitSpec;
	 el_def=0;
	};
	act_range {min=0: max=1: range=1: scale=1: };
	bias_con_type=LeabraCon;
	bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[1]$$: };
	sse_tol=0.5;
	act_fun=NOISY_LINEAR;
	act {gelin=0: thr=0.17: gain=220: nvar=0.01: avg_dt=0: avg_init=0.15: i_thr=STD: };
	spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
	spike_misc {
	 exp_slope=0.02;
	 spk_thr=1.2;
	 clamp_max_p=0.11;
	 clamp_type=REGULAR;
	 vm_r=0.3;
	 vm_dend=0.3;
	 vm_dend_dt=0.16;
	 vm_dend_time=6.25;
	};
	opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
	maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
	clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
	vm_range {min=0: max=1: range=1: scale=1: };
	v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
	dt {integ=1: vm=0.05: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=100: vm_eq_dt=1: integ_time=1: vm_time=20: net_time=1.428571: };
	act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
	g_bar {e=1: l=0.1: i=1: h=0.03: a=0.09: };
	e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
	hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
	acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
	adapt {
	 on=0;
	 dt=0.007;
	 vm_gain=0.04;
	 spike_gain=0.00805;
	 interval=10;
	 dt_time=142.8571;
	};
	depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
	syn_delay {
	 on=0;
	 delay=4;
	};
	da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
	noise_type=NO_NOISE;
	noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
	noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
	noise_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=1;
	 cur_val=0;
	};
       };
      };
      act_range {min=0: max=1: range=1: scale=1: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[1]$: };
      sse_tol=0.5;
      act_fun=NOISY_LINEAR;
      act {gelin=0: thr=0.17: gain=220: nvar=0.01: avg_dt=0: avg_init=0.15: i_thr=STD: };
      spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.05: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=100: vm_eq_dt=1: integ_time=1: vm_time=20: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=0.03: a=0.09: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
     };
     DaModUnitSpec @[1] {
      name="DaUnits";
      desc=;
      unique{ act_range;clamp_range;act;maxda;      };
      children {
       name=;
       el_typ=DaModUnitSpec;
       el_def=0;
      };
      act_range {min=-2: max=2: range=4: scale=0.25: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[1].children[0]$$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0: avg_init=0.15: i_thr=STD: };
      spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=-2: max=2: range=4: scale=0.25: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.25: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=4: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=0.01: a=0.03: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
     };
     DaModUnitSpec @[2] {
      name="PFCUnits";
      desc=;
      unique{ g_bar;act_reg;dt;      };
      children {
       name=;
       el_typ=DaModUnitSpec;
       el_def=0;
      };
      act_range {min=0: max=1: range=1: scale=1: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[2].children[1]$$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
      spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=1: a=2: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
     };
     MatrixUnitSpec @[3] {
      name="MatrixUnits";
      desc=;
      unique{ bias_spec;g_bar;opt_thresh;act;noise;noise_adapt;noise_type;maxda;      };
      children {
       name=;
       el_typ=MatrixUnitSpec;
       el_def=0;
       MatrixUnitSpec @[0] {
	name="MatrixOut";
	desc=;
	unique{ bias_spec;g_bar;act;noise;noise_adapt;noise_type;matrix_noise;	};
	children {
	 name=;
	 el_typ=MatrixUnitSpec;
	 el_def=0;
	};
	act_range {min=0: max=1: range=1: scale=1: };
	bias_con_type=LeabraCon;
	bias_spec {type=MatrixBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[3].children[1]$$: };
	sse_tol=0.5;
	act_fun=NOISY_XX1;
	act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=NO_AH: };
	spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
	spike_misc {
	 exp_slope=0.02;
	 spk_thr=1.2;
	 clamp_max_p=0.11;
	 clamp_type=REGULAR;
	 vm_r=0.3;
	 vm_dend=0.3;
	 vm_dend_dt=0.16;
	 vm_dend_time=6.25;
	};
	opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
	maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
	clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
	vm_range {min=0: max=1: range=1: scale=1: };
	v_m_init {name="RandomSpec_37": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
	dt {integ=1: vm=0.25: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=4: net_time=1.428571: };
	act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
	g_bar {e=1: l=0.1: i=1: h=0.02: a=0.06: };
	e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
	hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
	acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
	adapt {
	 on=0;
	 dt=0.007;
	 vm_gain=0.04;
	 spike_gain=0.00805;
	 interval=10;
	 dt_time=142.8571;
	};
	depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
	syn_delay {
	 on=0;
	 delay=4;
	};
	da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
	noise_type=NETIN_NOISE;
	noise {name="RandomSpec_38": type=GAUSSIAN: mean=0: var=0.0005000000237487257: par=1: };
	noise_adapt {trial_fixed=1: k_pos_noise=1: mode=PVLV_PVI: min_pct=0.5: min_pct_c=0.5: };
	noise_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=1;
	 cur_val=0;
	};
	matrix_noise {
	 patch_noise=0;
	};
       };
      };
      act_range {min=0: max=1: range=1: scale=1: };
      bias_con_type=LeabraCon;
      bias_spec {type=MatrixBiasSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[3].children[1]$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=NO_AH: };
      spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.25: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=4: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=0.01: a=0.03: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NETIN_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=9.999999747378752e-05: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=1: mode=PVLV_LVE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
      matrix_noise {
       patch_noise=1;
      };
     };
     DaModUnitSpec @[4] {
      name="SNrThalUnits";
      desc=;
      unique{ maxda;      };
      children {
       name=;
       el_typ=DaModUnitSpec;
       el_def=0;
      };
      act_range {min=0: max=1: range=1: scale=1: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=$.projects[0].networks[0].specs[3].children[0]$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
      spike {rise=0: decay=5: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=NO_MAX_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=10: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.8: i=1: h=0.01: a=0.03: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=1: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
     };
    };
    BaseSpec_Group @.gp[1] {
     name="PFC_BG_Cons";
     el_typ=LeabraConSpec;
     el_def=0;
     LeabraConSpec @[0] {
      name="LearnCons";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=PVConSpec;
       el_def=0;
       PVConSpec @[0] {
	name="PVi";
	desc=;
	unique{ lmix;rnd;wt_limits;wt_sig;lrate;lrate_sched;lrs_value;lrs_value;xcalm;	};
	children {
	 name=;
	 el_typ=PVConSpec;
	 el_def=0;
	 PVConSpec @[0] {
	  name="LVe";
	  desc=;
	  unique{ lrate;lrate;lrs_value;wt_sig;xcalm;lrate;lrate_sched;lrs_value;lmix;rnd;wt_limits;	  };
	  children {
	   name=;
	   el_typ=PVConSpec;
	   el_def=0;
	   PVConSpec @[0] {
	    name="LVi";
	    desc=;
	    unique{ lrate;lrate;lrs_value;wt_sig;xcalm;lrate;lrate_sched;lrs_value;lmix;rnd;wt_limits;	    };
	    children {
	     name=;
	     el_typ=PVConSpec;
	     el_def=0;
	    };
	    rnd {name="": type=UNIFORM: mean=0.1000000014901161: var=0: par=1: };
	    wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	    learn_rule=LEABRA_CHL;
	    inhib=0;
	    wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	    wt_scale_init {init=0: abs=1: rel=1: };
	    lrate=0.001;
	    cur_lrate=0.001;
	    lrs_value=NO_LRS;
	    lrate_sched {
	     name=;
	     el_typ=SchedItem;
	     el_def=0;
	     last_ctr=-1;
	     default_val=1;
	     interpolate=0;
	     cur_val=0;
	    };
	    wt_sig {gain=1: off=1: };
	    lmix {hebb=0: err=1: err_sb=0: };
	    xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	    savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	    rel_net_adapt {
	     on=0;
	     trg_fm_input=0.85;
	     trg_fm_output=0.15;
	     trg_lateral=0;
	     trg_sum=1;
	     tol_lg=0.05;
	     tol_sm=0.2;
	     rel_lrate=0.2;
	    };
	    send_act=ACT_P;
	   };
	  };
	  rnd {name="": type=UNIFORM: mean=0.1000000014901161: var=0: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0.05;
	  cur_lrate=0.05;
	  lrs_value=NO_LRS;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	  };
	  wt_sig {gain=1: off=1: };
	  lmix {hebb=0: err=1: err_sb=0: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  send_act=ACT_P;
	 };
	 PVrConSpec @[1] {
	  name="PVr";
	  desc=;
	  unique{ xcalm;lrate;wt_limits;wt_sig;xcalm;lrate;lrate_sched;lrs_value;lmix;rnd;	  };
	  children {
	   name=;
	   el_typ=PVrConSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0.1000000014901161: var=0: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0.02;
	  cur_lrate=0.02;
	  lrs_value=NO_LRS;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	  };
	  wt_sig {gain=1: off=1: };
	  lmix {hebb=0: err=1: err_sb=0: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  send_act=ACT_P;
	  wt_dec_mult=0.01;
	 };
	 NVConSpec @[2] {
	  name="NV";
	  desc=;
	  unique{ xcalm;lrate;wt_limits;wt_sig;xcalm;lrate;lrate_sched;lrs_value;lmix;rnd;	  };
	  children {
	   name=;
	   el_typ=NVConSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0.1000000014901161: var=0: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0.0005;
	  cur_lrate=0.0005;
	  lrs_value=NO_LRS;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	  };
	  wt_sig {gain=1: off=1: };
	  lmix {hebb=0: err=1: err_sb=0: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  send_act=ACT_P;
	  decay=0;
	 };
	};
	rnd {name="": type=UNIFORM: mean=0.1000000014901161: var=0: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0.01;
	cur_lrate=0.01;
	lrs_value=NO_LRS;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	};
	wt_sig {gain=1: off=1: };
	lmix {hebb=0: err=1: err_sb=0: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
	send_act=ACT_P;
       };
       LeabraBiasSpec @[1] {
	name="BgBias";
	desc=;
	unique{ rnd;wt_limits;wt_scale;wt_scale_init;lrate;	};
	children {
	 name=;
	 el_typ=LeabraBiasSpec;
	 el_def=0;
	 LeabraBiasSpec @[0] {
	  name="FixedBias";
	  desc=;
	  unique{ rnd;wt_limits;wt_scale;wt_scale_init;lrate;	  };
	  children {
	   name=;
	   el_typ=LeabraBiasSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	  wt_limits {type=NONE: min=-1: max=5: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0.001: err=0.999: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  dwt_thresh=0.1;
	 };
	 MatrixBiasSpec @[1] {
	  name="MatrixBias";
	  desc=;
	  unique{ rnd;wt_limits;wt_scale;wt_scale_init;rnd;wt_scale;wt_scale_init;lrate;	  };
	  children {
	   name=;
	   el_typ=MatrixBiasSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	  wt_limits {type=NONE: min=-1: max=5: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0.01;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0.001: err=0.999: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  dwt_thresh=0.1;
	 };
	};
	rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	wt_limits {type=NONE: min=-1: max=5: sym=0: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0;
	cur_lrate=0;
	lrs_value=EXT_REW_STAT;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	 SchedItem @[0] {
	  start_ctr=0;
	  start_val=1;
	  duration=90;
	  step=-0.01;
	 };
	 SchedItem @[1] {
	  start_ctr=90;
	  start_val=0.1;
	  duration=1;
	  step=1;
	 };
	};
	wt_sig {gain=6: off=1.25: };
	lmix {hebb=0.001: err=0.999: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
	dwt_thresh=0.1;
       };
       LeabraConSpec @[2] {
	name="ToPFC";
	desc=;
	unique{ lrate;rnd;lmix;	};
	children {
	 name=;
	 el_typ=LeabraConSpec;
	 el_def=0;
	 LeabraConSpec @[0] {
	  name="IntraPFC";
	  desc=;
	  unique{ wt_scale;	  };
	  children {
	   name=;
	   el_typ=LeabraConSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=0.1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0.01;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0.001: err=0.999: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	 };
	 LeabraBiasSpec @[1] {
	  name="PFCBias";
	  desc=;
	  unique{ rnd;wt_limits;wt_scale;wt_scale_init;	  };
	  children {
	   name=;
	   el_typ=LeabraBiasSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	  wt_limits {type=NONE: min=-1: max=5: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0.001: err=0.999: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  dwt_thresh=0.1;
	 };
	};
	rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0;
	cur_lrate=0;
	lrs_value=EXT_REW_STAT;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	 SchedItem @[0] {
	  start_ctr=0;
	  start_val=1;
	  duration=90;
	  step=-0.01;
	 };
	 SchedItem @[1] {
	  start_ctr=90;
	  start_val=0.1;
	  duration=1;
	  step=1;
	 };
	};
	wt_sig {gain=6: off=1.25: };
	lmix {hebb=0.001: err=0.999: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
       };
       MatrixConSpec @[3] {
	name="MatrixCons";
	desc=;
	unique{ lmix;lrate;wt_limits;wt_limits;wt_sig;xcal;rnd;	};
	children {
	 name=;
	 el_typ=MatrixConSpec;
	 el_def=0;
	 MatrixConSpec @[0] {
	  name="MatrixFmPFC";
	  desc=;
	  unique{ wt_scale;wt_limits;xcal;wt_limits;wt_sig;	  };
	  children {
	   name=;
	   el_typ=MatrixConSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0.5: var=0.01999999955296516: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=0.02: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0.05;
	  cur_lrate=0.05;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=1: off=1: };
	  lmix {hebb=0: err=1: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	 };
	 MatrixBiasSpec @[1] {
	  name="MatrixBias";
	  desc=;
	  unique{ lmix;wt_sig;wt_limits;rnd;wt_scale;wt_scale_init;lrate;lrate;	  };
	  children {
	   name=;
	   el_typ=MatrixBiasSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	  wt_limits {type=NONE: min=-1: max=5: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0: err=1: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	  dwt_thresh=0.1;
	 };
	 MatrixConSpec @[2] {
	  name="Matrix_out";
	  desc=;
	  unique{ wt_sig;xcal;wt_limits;lrate;	  };
	  children {
	   name=;
	   el_typ=MatrixConSpec;
	   el_def=0;
	   MatrixConSpec @[0] {
	    name="Matrix_out_FmPFC";
	    desc=;
	    unique{ wt_sig;xcal;wt_limits;wt_scale;	    };
	    children {
	     name=;
	     el_typ=MatrixConSpec;
	     el_def=0;
	    };
	    rnd {name="RandomSpec_40": type=UNIFORM: mean=0.5: var=0.01999999955296516: par=1: };
	    wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	    learn_rule=LEABRA_CHL;
	    inhib=0;
	    wt_scale {abs=1: rel=0.02: sem_extra=2: old=0: };
	    wt_scale_init {init=0: abs=1: rel=1: };
	    lrate=0.1;
	    cur_lrate=0.01;
	    lrs_value=EXT_REW_STAT;
	    lrate_sched {
	     name=;
	     el_typ=SchedItem;
	     el_def=0;
	     last_ctr=-1;
	     default_val=1;
	     interpolate=0;
	     cur_val=0;
	     SchedItem @[0] {
	      start_ctr=0;
	      start_val=1;
	      duration=90;
	      step=-0.01;
	     };
	     SchedItem @[1] {
	      start_ctr=90;
	      start_val=0.1;
	      duration=1;
	      step=1;
	     };
	    };
	    wt_sig {gain=1: off=1: };
	    lmix {hebb=0: err=1: err_sb=1: };
	    xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	    savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	    rel_net_adapt {
	     on=0;
	     trg_fm_input=0.85;
	     trg_fm_output=0.15;
	     trg_lateral=0;
	     trg_sum=1;
	     tol_lg=0.05;
	     tol_sm=0.2;
	     rel_lrate=0.2;
	    };
	   };
	  };
	  rnd {name="RandomSpec_39": type=UNIFORM: mean=0.5: var=0.01999999955296516: par=1: };
	  wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0.1;
	  cur_lrate=0.01;
	  lrs_value=EXT_REW_STAT;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	   SchedItem @[0] {
	    start_ctr=0;
	    start_val=1;
	    duration=90;
	    step=-0.01;
	   };
	   SchedItem @[1] {
	    start_ctr=90;
	    start_val=0.1;
	    duration=1;
	    step=1;
	   };
	  };
	  wt_sig {gain=1: off=1: };
	  lmix {hebb=0: err=1: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.2;
	  };
	 };
	};
	rnd {name="": type=UNIFORM: mean=0.5: var=0.01999999955296516: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0.05;
	cur_lrate=0.05;
	lrs_value=EXT_REW_STAT;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	 SchedItem @[0] {
	  start_ctr=0;
	  start_val=1;
	  duration=90;
	  step=-0.01;
	 };
	 SchedItem @[1] {
	  start_ctr=90;
	  start_val=0.1;
	  duration=1;
	  step=1;
	 };
	};
	wt_sig {gain=1: off=1: };
	lmix {hebb=0: err=1: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
       };
       LeabraConSpec @[4] {
	name="FmPFC_mnt";
	desc=;
	unique{ wt_scale;	};
	children {
	 name=;
	 el_typ=LeabraConSpec;
	 el_def=0;
	};
	rnd {name="RandomSpec_41": type=UNIFORM: mean=0.5: var=0.25: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0.01;
	cur_lrate=0.01;
	lrs_value=EXT_REW_STAT;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	 SchedItem @[0] {
	  start_ctr=0;
	  start_val=1;
	  duration=90;
	  step=-0.01;
	 };
	 SchedItem @[1] {
	  start_ctr=90;
	  start_val=0.1;
	  duration=1;
	  step=1;
	 };
	};
	wt_sig {gain=6: off=1.25: };
	lmix {hebb=0.001: err=0.999: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
       };
       LeabraConSpec @[5] {
	name="FmPFC_out";
	desc=;
	unique{ wt_scale;	};
	children {
	 name=;
	 el_typ=LeabraConSpec;
	 el_def=0;
	};
	rnd {name="RandomSpec_42": type=UNIFORM: mean=0.5: var=0.25: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0.01;
	cur_lrate=0.01;
	lrs_value=EXT_REW_STAT;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	 SchedItem @[0] {
	  start_ctr=0;
	  start_val=1;
	  duration=90;
	  step=-0.01;
	 };
	 SchedItem @[1] {
	  start_ctr=90;
	  start_val=0.1;
	  duration=1;
	  step=1;
	 };
	};
	wt_sig {gain=6: off=1.25: };
	lmix {hebb=0.001: err=0.999: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.2;
	};
       };
      };
      rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
      wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
      learn_rule=LEABRA_CHL;
      inhib=0;
      wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
      wt_scale_init {init=0: abs=1: rel=1: };
      lrate=0.01;
      cur_lrate=0.01;
      lrs_value=EXT_REW_STAT;
      lrate_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=0;
       cur_val=0;
       SchedItem @[0] {
	start_ctr=0;
	start_val=1;
	duration=90;
	step=-0.01;
       };
       SchedItem @[1] {
	start_ctr=90;
	start_val=0.1;
	duration=1;
	step=1;
       };
      };
      wt_sig {gain=6: off=1.25: };
      lmix {hebb=0.001: err=0.999: err_sb=1: };
      xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
      savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
      rel_net_adapt {
       on=0;
       trg_fm_input=0.85;
       trg_fm_output=0.15;
       trg_lateral=0;
       trg_sum=1;
       tol_lg=0.05;
       tol_sm=0.2;
       rel_lrate=0.2;
      };
     };
     MarkerConSpec @[1] {
      name="MarkerCons";
      desc=;
      unique{ rnd;wt_limits;wt_scale;lrate;      };
      children {
       name=;
       el_typ=MarkerConSpec;
       el_def=0;
      };
      rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
      wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
      learn_rule=LEABRA_CHL;
      inhib=0;
      wt_scale {abs=1: rel=0: sem_extra=2: old=0: };
      wt_scale_init {init=0: abs=1: rel=1: };
      lrate=0;
      cur_lrate=0;
      lrs_value=EPOCH;
      lrate_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=0;
       cur_val=0;
      };
      wt_sig {gain=6: off=1.25: };
      lmix {hebb=0.001: err=0.999: err_sb=1: };
      xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
      savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
      rel_net_adapt {
       on=0;
       trg_fm_input=0.85;
       trg_fm_output=0.15;
       trg_lateral=0;
       trg_sum=1;
       tol_lg=0.05;
       tol_sm=0.2;
       rel_lrate=0.2;
      };
     };
     LeabraConSpec @[2] {
      name="PFCSelfCon";
      desc=;
      unique{ lrate;rnd;wt_scale;savg_cor;      };
      children {
       name=;
       el_typ=LeabraConSpec;
       el_def=0;
      };
      rnd {name="": type=UNIFORM: mean=0.8999999761581421: var=0: par=1: };
      wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
      learn_rule=LEABRA_CHL;
      inhib=0;
      wt_scale {abs=1: rel=0.2: sem_extra=2: old=0: };
      wt_scale_init {init=0: abs=1: rel=1: };
      lrate=0;
      cur_lrate=0;
      lrs_value=EPOCH;
      lrate_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=0;
       cur_val=0;
      };
      wt_sig {gain=6: off=1.25: };
      lmix {hebb=0.001: err=0.999: err_sb=1: };
      xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
      savg_cor {cor=0.4: thresh=0.001: norm_con_n=1: };
      rel_net_adapt {
       on=0;
       trg_fm_input=0.85;
       trg_fm_output=0.15;
       trg_lateral=0;
       trg_sum=1;
       tol_lg=0.05;
       tol_sm=0.2;
       rel_lrate=0.2;
      };
     };
    };
    BaseSpec_Group @.gp[2] {
     name="PFC_BG_Layers";
     el_typ=ExtRewLayerSpec;
     el_def=0;
     ExtRewLayerSpec @[0] {
      name="PVeLayer";
      desc=;
      unique{ kwta;inhib_group;compute_i;i_kwta_pt;decay;inhib;gp_kwta;      };
      children {
       name=;
       el_typ=ExtRewLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=1: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=0: max=1: range=1: scale=1: };
      bias_val {un=NO_UN: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0: };
      val_range {min=0: max=1: range=1: scale=1: };
      rew_type=OUT_ERR_REW;
      avg_rew {sub_avg=0: avg_dt=0.005: };
      out_err {err_tol=0.5: graded=0: no_off_err=0: scalar_val_max=1: };
      rew {err_val=0: norew_val=0.5: rew_val=1: };
     };
     PVrLayerSpec @[1] {
      name="PVrLayer";
      desc=;
      unique{ kwta;inhib_group;compute_i;i_kwta_pt;decay;inhib;gp_kwta;      };
      children {
       name=;
       el_typ=PVrLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=0: max=1: range=1: scale=1: };
      bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0.5: };
      val_range {min=0: max=1: range=1: scale=1: };
      pv_detect {thr=0.7: };
     };
     PViLayerSpec @[2] {
      name="PViLayer";
      desc=;
      unique{ kwta;inhib_group;compute_i;i_kwta_pt;decay;inhib;gp_kwta;      };
      children {
       name=;
       el_typ=PViLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=0: max=1: range=1: scale=1: };
      bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0.5: };
      val_range {min=0: max=1: range=1: scale=1: };
      pv {min_pvi=0.4: pvi_scale_min=0: prior_gain=1: er_reset_prior=1: };
     };
     LVeLayerSpec @[3] {
      name="LVeLayer";
      desc=;
      unique{ kwta;inhib_group;compute_i;i_kwta_pt;decay;gp_kwta;inhib;      };
      children {
       name=;
       el_typ=LViLayerSpec;
       el_def=0;
       LViLayerSpec @[0] {
	name="LViLayer";
	desc=;
	unique{ ct_inhib_mod;inhib_group;inhib;decay;ct_inhib_mod;kwta;gp_kwta;	};
	children {
	 name=;
	 el_typ=LViLayerSpec;
	 el_def=0;
	};
	inhib_group=UNIT_GROUPS;
	inhib {
	 type=KWTA_AVG_INHIB;
	 kwta_pt=0.9;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
	scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
	unit_range {min=0: max=1: range=1: scale=1: };
	bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0.5: };
	val_range {min=0: max=1: range=1: scale=1: };
	lv {min_lvi=0.4: lvi_scale_min=0: lrn_pv_only=1: prior_gain=1: er_reset_prior=1: };
       };
       PatchLayerSpec @[1] {
	name="PatchLayer";
	desc=;
	unique{ inhib_group;ct_inhib_mod;ct_inhib_mod;inhib_group;gp_kwta;inhib_group;	};
	children {
	 name=;
	 el_typ=PatchLayerSpec;
	 el_def=0;
	};
	inhib_group=UNIT_GROUPS;
	inhib {
	 type=KWTA_AVG_INHIB;
	 kwta_pt=0.9;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
	scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
	unit_range {min=0: max=1: range=1: scale=1: };
	bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0.5: };
	val_range {min=0: max=1: range=1: scale=1: };
	lv {min_lvi=0.4: lvi_scale_min=0: lrn_pv_only=1: prior_gain=1: er_reset_prior=1: };
       };
      };
      inhib_group=UNIT_GROUPS;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=0: max=1: range=1: scale=1: };
      bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0.5: };
      val_range {min=0: max=1: range=1: scale=1: };
      lv {min_lvi=0.4: lvi_scale_min=0: lrn_pv_only=1: prior_gain=1: er_reset_prior=1: };
     };
     NVLayerSpec @[4] {
      name="NVLayer";
      desc=;
      unique{ kwta;inhib_group;compute_i;i_kwta_pt;decay;inhib;gp_kwta;      };
      children {
       name=;
       el_typ=NVLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      scalar {rep=LOCALIST: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=0: max=1: range=1: scale=1: };
      bias_val {un=GC: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=1: };
      val_range {min=0: max=1: range=1: scale=1: };
      nv {
       da_gain=0.1;
       val_thr=0.1;
       prior_gain=1;
       er_reset_prior=1;
      };
     };
     PVLVDaLayerSpec @[5] {
      name="DALayer";
      desc=;
      unique{ decay;kwta;inhib_group;compute_i;i_kwta_pt;inhib;ct_inhib_mod;      };
      children {
       name=;
       el_typ=SNcLayerSpec;
       el_def=0;
       SNcLayerSpec @[0] {
	name="SNcLayer";
	desc=;
	unique{ decay;kwta;inhib_group;inhib;ct_inhib_mod;	};
	children {
	 name=;
	 el_typ=SNcLayerSpec;
	 el_def=0;
	};
	inhib_group=ENTIRE_LAYER;
	inhib {
	 type=KWTA_INHIB;
	 kwta_pt=0.25;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
	da {da_gain=1: tonic_da=0: pv_gain=0.1: add_pv_lv=0: };
	snc {
	 stripe_lv_pct=0.5;
	 global_lv_pct=0.5;
	};
       };
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      da {da_gain=1: tonic_da=0: pv_gain=0.1: add_pv_lv=0: };
     };
     PFCLayerSpec @[6] {
      name="PFCLayer";
      desc=;
      unique{ gp_kwta;inhib_group;compute_i;i_kwta_pt;decay;inhib;      };
      children {
       name=;
       el_typ=PFCOutLayerSpec;
       el_def=0;
       PFCOutLayerSpec @[0] {
	name="PFCOutLayer";
	desc=;
	unique{ ct_inhib_mod;	};
	children {
	 name=;
	 el_typ=PFCOutLayerSpec;
	 el_def=0;
	};
	inhib_group=UNIT_GROUPS;
	inhib {
	 type=KWTA_AVG_INHIB;
	 kwta_pt=0.6;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_K: k=2: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=0: phase=0: phase2=0.1: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
       };
      };
      inhib_group=UNIT_GROUPS;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.6;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=2: pct=0.15: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=0: phase=0: phase2=0.1: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      gate {graded_out_go=1: clear_decay=0.9: go_learn_base=0.05: go_learn_mod=0.95: mid_minus_min=10: max_maint=100: out_go_clear=1: off_accom=0: };
     };
     MatrixLayerSpec @[7] {
      name="MatrixLayer";
      desc=;
      unique{ decay;      };
      children {
       name=;
       el_typ=MatrixLayerSpec;
       el_def=0;
       MatrixLayerSpec @[0] {
	name="Matrix_out";
	desc=;
	unique{ ct_inhib_mod;bg_type;	};
	children {
	 name=;
	 el_typ=MatrixLayerSpec;
	 el_def=0;
	};
	inhib_group=UNIT_GROUPS;
	inhib {
	 type=KWTA_INHIB;
	 kwta_pt=0.25;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_K: k=4: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=1: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
	bg_type=OUTPUT;
	matrix {da_gain=0.1: bias_gain=0.1: bias_pos_gain=0: mnt_only=0: };
	gate_bias {
	 out_rew_go=1;
	 out_norew_nogo=1;
	 out_empty_nogo=5;
	 mnt_rew_nogo=5;
	 mnt_mnt_nogo=0;
	 mnt_empty_go=0;
	};
	rnd_go {nogo_thr=20: rng_eq_thr=1: nogo_rng=20: nogo_da=10: nogo_noise=0.02: };
	go_nogo_gain {
	 on=0;
	 go_p=1;
	 go_n=1;
	 nogo_p=1;
	 nogo_n=1;
	};
       };
      };
      inhib_group=UNIT_GROUPS;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=4: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=1: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      bg_type=MAINT;
      matrix {da_gain=0.1: bias_gain=0.1: bias_pos_gain=0: mnt_only=0: };
      gate_bias {
       out_rew_go=1;
       out_norew_nogo=1;
       out_empty_nogo=5;
       mnt_rew_nogo=5;
       mnt_mnt_nogo=0;
       mnt_empty_go=0;
      };
      rnd_go {nogo_thr=20: rng_eq_thr=1: nogo_rng=20: nogo_da=10: nogo_noise=0.02: };
      go_nogo_gain {
       on=0;
       go_p=1;
       go_n=1;
       nogo_p=1;
       nogo_n=1;
      };
     };
     SNrThalLayerSpec @[8] {
      name="SNrThalLayer";
      desc=;
      unique{ decay;kwta;tie_brk;inhib_group;compute_i;i_kwta_pt;inhib;bg_type;      };
      children {
       name=;
       el_typ=SNrThalLayerSpec;
       el_def=0;
       SNrThalLayerSpec @[0] {
	name="SNrThalOut";
	desc=;
	unique{ kwta;bg_type;inhib_group;ct_inhib_mod;tie_brk;inhib;	};
	children {
	 name=;
	 el_typ=SNrThalLayerSpec;
	 el_def=0;
	};
	inhib_group=ENTIRE_LAYER;
	inhib {
	 type=KWTA_AVG_INHIB;
	 kwta_pt=0.8;
	 min_i=0;
	 fb_act_thr=0;
	 ff_pct=0;
	 fb_max_dt=0.1;
	 comp_thr=0.5;
	 comp_gain=2;
	 gp_pt=0.2;
	};
	kwta {k_from=USE_PCT: k=2: pct=0.75: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
	tie_brk {on=1: k_thr=1: diff_thr=0.2: thr_gain=0.2: loser_gain=1: };
	i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
	adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
	clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
	decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
	ct_inhib_mod {
	 use_sin=1;
	 burst_i=0;
	 trough_i=0;
	 use_fin=0;
	 inhib_i=0;
	};
	abs_net_adapt {
	 on=0;
	 trg_net=0.5;
	 tol=0.1;
	 abs_lrate=0.2;
	};
	bg_type=OUTPUT;
	snrthal {net_off=0: go_thr=0.5: rnd_go_inc=0.1: leak=1: };
       };
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.8;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=2: pct=0.75: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=1: k_thr=1: diff_thr=0.2: thr_gain=0.2: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      bg_type=MAINT;
      snrthal {net_off=0: go_thr=0.5: rnd_go_inc=0.1: leak=1: };
     };
     PVLVDaLayerSpec @[9] {
      name="VTALayer";
      desc=;
      unique{ decay;kwta;inhib_group;inhib;ct_inhib_mod;      };
      children {
       name=;
       el_typ=PVLVDaLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=1;
       burst_i=0;
       trough_i=0;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
      da {da_gain=1: tonic_da=0: pv_gain=1: add_pv_lv=0: };
     };
     LeabraLayerSpec @[10] {
      name="RewTargLayer";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=LeabraLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.6;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.2: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.2;
      };
     };
    };
    BaseSpec_Group @.gp[3] {
     name="PFC_BG_Prjns";
     el_typ=FullPrjnSpec;
     el_def=0;
     FullPrjnSpec @[0] {
      name="FullPrjn";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=FullPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
     OneToOnePrjnSpec @[1] {
      name="OneToOne";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=1;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     GpOneToOnePrjnSpec @[2] {
      name="GpOneToOne";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=GpOneToOnePrjnSpec;
       el_def=0;
      };
      self_con=1;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     UniformRndPrjnSpec @[3] {
      name="ToPFC";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=UniformRndPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      p_con=0.4;
      sym_self=1;
      same_seed=0;
      rndm_seed {
       name="RndSeed_27";
       seed{ 1442805149;149668195;-303656920;1168039885;112848622;-990519853;-1741082693;858166226;-839865104;1776599158;1132392534;168976868;-744033174;-1866303866;-1185466903;-1866786951;-469980073;639188522;-344609915;433226217;2037738619;1565342338;1156284204;2091509289;-1495788044;658480996;427512996;-11729335;1989876954;993144810;1474967670;1328897258;-700708784;-665781408;-369458589;1488055559;-1284282434;742047907;922759850;1566992458;-2100328631;2056776435;2079208072;-1668231184;595057929;824217168;1920212986;-741265030;-779008446;271831194;1376567282;8047093;1080794376;1143625828;-1895302285;1865015983;324814232;-1681564194;-486488437;160782399;-830330727;1866780128;-94506702;-421656262;295284402;1073845788;715366959;2127192838;-436718877;-45559170;-931681640;1130353775;1987300769;1723871370;-1024841864;-1233942237;1408843947;1110626300;581586919;-1999632223;248082626;-404029463;-1311422021;-394142942;-604347885;409501368;482371290;-2120661958;-1301135485;-1941833896;-518747892;1975094022;-1678008834;-94588672;97264310;-725483891;-675453619;-1283573739;756393594;-1927878798;796303679;-2050740881;-522347329;-1518386848;1774620694;1656966288;-699173554;-903039049;-1821574909;481060707;-2130906196;840766495;-66793249;2059455114;1089939267;-1307270889;-1880630010;121044151;-1148688892;-1734920103;-76563115;-1338015709;1043899657;-269695540;-522103179;-271951907;-1274693761;883747211;1275710902;-924376396;-756204147;1326771002;1739504468;-300703766;-894965140;603871427;1724915556;-1320982344;689646918;1503195906;-674019634;1300916194;1378749209;146570270;-711795971;1474761308;-1030665207;312266503;1947929371;1419363212;1058020620;-1634977571;1765121399;2132451248;-334557351;942713316;64902905;686729149;1595974217;-49781023;-589231155;217645292;1101626635;556710199;-714454485;1776574906;-17146199;2121062208;623304790;-685040871;-1430045145;1511517529;-482063087;-447129031;-1336634178;434575393;-1842987933;-769656913;623579699;-1235494502;184885553;-2129608767;1118256566;1353875274;1947178086;618026301;-1316421425;-1867665030;-236756423;831687325;-655899806;1509110572;-792603420;-949967293;-79809708;-2092819722;693794685;-794902307;-2142871114;476376336;1952107837;1267897314;-1801887808;2072732809;1181466596;1966449323;-529994618;-1942928901;1950615548;-303270460;1708630635;1007221136;896127177;-617345593;1080237513;-744425137;-948919741;-1949591588;889095258;-53898193;984272409;-962151296;1393230208;1209635819;806177596;1422284657;1925710871;-291512269;1428924701;1640237511;-855108301;-1954548775;-2098739793;378479398;-612433352;-293099450;-1104141096;2040557410;2137022104;-982468569;-1116745546;-1845247185;-584432886;-711200712;-465826181;-49977557;87209080;-1515247481;-2035938355;995225582;-1830119101;514219382;1216898323;773131357;-280070714;1748474575;-249421632;-127786775;1991472465;2091107882;2090375311;-239687211;1574942563;-648463366;1657615488;327674199;-178556458;-1504918004;1514742828;996487269;-248203770;1689106806;-1605277542;-2107920023;-679407244;-841882764;-1909548848;-601857967;-576949378;50498780;414120390;-690903395;158596653;1774248302;-158985083;-163110560;1493685820;-1920304958;668220927;-1987644122;-2001620075;1504210784;1596029287;158389329;-1919303305;-1102647548;-1248358359;1528993253;1159212532;1783437206;-421304263;-1857524200;2070527108;-578305800;-1919296517;-1122790762;1801506007;-1193622723;2030976328;1497460796;-323831013;-617185610;-722160899;708789090;1325969115;652993968;-272855090;865915442;1491891200;1853714239;1519842386;1127306862;1059956210;2036782542;-2059581224;-188134305;946526757;13020821;-1254949998;-1614926805;-1640260456;1874183348;202245881;-187622857;110091926;-1967925974;-1430061070;1766704516;-380309479;-1355799460;-1550604137;674797767;2054309211;-2137297573;777426837;-554017816;-933361526;-1919615770;-1396554946;-23871574;-1585291722;-249522176;1812901808;631861586;567586903;-743434796;1633664913;622184746;1440302502;-1158193505;693401970;-1174985634;1724284522;744051099;-1235870353;497323876;1938449694;-914742316;1173752050;-2139087623;62412091;-1771168503;36295059;579928491;-282042109;214277513;382890507;-274398874;-2106991802;849205784;-771651636;858723874;713750041;1665114075;-1129736098;-221602372;-1766006017;-1368840610;164009794;726780532;1588215311;1515861965;-611988039;-1207122334;-560080067;-581106332;2110227006;146383141;-434041836;-1719418087;-752080626;1354905517;606194832;-2134129737;2101892753;-1467123364;-1802256615;-429229269;-344753267;-1808786808;1459176405;853269982;-376846181;1097873925;-1107126813;-1992307228;-423110123;1831052352;-601685448;696166801;-1523862007;638022537;722479175;-272805700;1400796398;-1363726448;1053776405;-939300948;-1295280943;505106422;1916060500;-916755169;414991474;-37695901;-612328927;845706612;-674248389;-175720764;1240513331;-399383817;756306713;943484559;-1587161825;-1824415400;-1960364303;1139516108;-436218092;315069979;-1249805073;-342044921;-1641217672;404219502;-561415856;594940732;53982510;-1898516538;-609543484;946951725;-1833462807;121618957;756734760;-82081665;-1644753416;1073432375;178945300;1980010108;1938862497;1541342512;990277944;-150080751;1892408316;786561215;-2037509101;239867934;1677198073;-520110119;1315962502;-1115758271;1342090771;-54467615;1130102771;1354396182;-1882239682;-522378751;-389940131;1976424122;1316255945;-70817460;2086627310;-1335920899;1649707499;-656275733;1693310582;-1687873667;-1774899475;523019863;273616406;-311188491;-1970529322;-574737278;2134470098;911143936;1882829212;289177939;-589481834;1989781739;-1600770113;-437846642;1407003501;-1338841262;1112759194;2009144765;-384027181;-1163775236;-100022516;1867015724;91966928;2112430437;969345132;-564940035;-1513719184;-551439335;1844122095;-1706144701;-1703170035;2052308923;-1119071528;-268158811;1062050630;-2025778944;-1823900119;1063321635;424158147;2040804584;-622649171;977874460;-1219982430;-2064583648;-1214053191;-1793521643;-464173251;450866475;1918674681;1220816519;1086893184;1001596915;-1630751937;1453049187;41513455;-1759131455;-2056132045;819994897;-1531805554;-1453858296;-2007649272;1923170596;438522419;771652362;397106045;-1459163844;-785478095;477130244;-466667573;-977384758;-1599149752;354561450;2120038272;346986851;-2142409164;-580956995;273313154;1049950046;1519043733;-1347933736;1099633103;-661240259;1457534074;1711386025;-1840420459;-1340008138;-145306852;-2084190325;2117373495;1222962055;1519257729;-673024375;-105587892;562583717;404843957;-109078149;-1965460782;-1208540372;1876221494;670400171;1341311915;-964497441;1345775790;-1278469431;-909922097;377443515;-1237802705;1246104137;54352143;-769768271;-2097548195;1301863517;-1490843019;-1124769460;-1669796299;-791015222;1813618258;-1221597797;1232932414;1506177275;-1359103563;-996205522;1093187048;3357986;1607365394;431056881;43885002;-1206592426;-193586242;-835680209;       };
       mti=344;
      };
     };
     OneToOnePrjnSpec @[4] {
      name="PFCSelf";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=1;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     GpRndTesselPrjnSpec @[5] {
      name="IntraPFC";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=GpRndTesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_gp_off {x=0: y=0: };
      recv_gp_n {x=-1: y=1: };
      recv_gp_skip {x=1: y=1: };
      recv_gp_group {x=1: y=1: };
      send_gp_scale {x=1: y=1: };
      send_gp_border {x=0: y=0: };
      send_gp_offs {
       name=;
       el_typ=GpTessEl;
       el_def=0;
       GpTessEl @[0] {
	send_gp_off {x=0: y=1: };
	p_con=0.4;
       };
      };
      wrap=0;
      def_p_con=0.4;
      sym_self=1;
      same_seed=0;
      rndm_seed {
       name="RndSeed_28";
       seed{ 1442805149;149668195;-303656920;1168039885;112848622;-990519853;-1741082693;858166226;-839865104;1776599158;1132392534;168976868;-744033174;-1866303866;-1185466903;-1866786951;-469980073;639188522;-344609915;433226217;2037738619;1565342338;1156284204;2091509289;-1495788044;658480996;427512996;-11729335;1989876954;993144810;1474967670;1328897258;-700708784;-665781408;-369458589;1488055559;-1284282434;742047907;922759850;1566992458;-2100328631;2056776435;2079208072;-1668231184;595057929;824217168;1920212986;-741265030;-779008446;271831194;1376567282;8047093;1080794376;1143625828;-1895302285;1865015983;324814232;-1681564194;-486488437;160782399;-830330727;1866780128;-94506702;-421656262;295284402;1073845788;715366959;2127192838;-436718877;-45559170;-931681640;1130353775;1987300769;1723871370;-1024841864;-1233942237;1408843947;1110626300;581586919;-1999632223;248082626;-404029463;-1311422021;-394142942;-604347885;409501368;482371290;-2120661958;-1301135485;-1941833896;-518747892;1975094022;-1678008834;-94588672;97264310;-725483891;-675453619;-1283573739;756393594;-1927878798;796303679;-2050740881;-522347329;-1518386848;1774620694;1656966288;-699173554;-903039049;-1821574909;481060707;-2130906196;840766495;-66793249;2059455114;1089939267;-1307270889;-1880630010;121044151;-1148688892;-1734920103;-76563115;-1338015709;1043899657;-269695540;-522103179;-271951907;-1274693761;883747211;1275710902;-924376396;-756204147;1326771002;1739504468;-300703766;-894965140;603871427;1724915556;-1320982344;689646918;1503195906;-674019634;1300916194;1378749209;146570270;-711795971;1474761308;-1030665207;312266503;1947929371;1419363212;1058020620;-1634977571;1765121399;2132451248;-334557351;942713316;64902905;686729149;1595974217;-49781023;-589231155;217645292;1101626635;556710199;-714454485;1776574906;-17146199;2121062208;623304790;-685040871;-1430045145;1511517529;-482063087;-447129031;-1336634178;434575393;-1842987933;-769656913;623579699;-1235494502;184885553;-2129608767;1118256566;1353875274;1947178086;618026301;-1316421425;-1867665030;-236756423;831687325;-655899806;1509110572;-792603420;-949967293;-79809708;-2092819722;693794685;-794902307;-2142871114;476376336;1952107837;1267897314;-1801887808;2072732809;1181466596;1966449323;-529994618;-1942928901;1950615548;-303270460;1708630635;1007221136;896127177;-617345593;1080237513;-744425137;-948919741;-1949591588;889095258;-53898193;984272409;-962151296;1393230208;1209635819;806177596;1422284657;1925710871;-291512269;1428924701;1640237511;-855108301;-1954548775;-2098739793;378479398;-612433352;-293099450;-1104141096;2040557410;2137022104;-982468569;-1116745546;-1845247185;-584432886;-711200712;-465826181;-49977557;87209080;-1515247481;-2035938355;995225582;-1830119101;514219382;1216898323;773131357;-280070714;1748474575;-249421632;-127786775;1991472465;2091107882;2090375311;-239687211;1574942563;-648463366;1657615488;327674199;-178556458;-1504918004;1514742828;996487269;-248203770;1689106806;-1605277542;-2107920023;-679407244;-841882764;-1909548848;-601857967;-576949378;50498780;414120390;-690903395;158596653;1774248302;-158985083;-163110560;1493685820;-1920304958;668220927;-1987644122;-2001620075;1504210784;1596029287;158389329;-1919303305;-1102647548;-1248358359;1528993253;1159212532;1783437206;-421304263;-1857524200;2070527108;-578305800;-1919296517;-1122790762;1801506007;-1193622723;2030976328;1497460796;-323831013;-617185610;-722160899;708789090;1325969115;652993968;-272855090;865915442;1491891200;1853714239;1519842386;1127306862;1059956210;2036782542;-2059581224;-188134305;946526757;13020821;-1254949998;-1614926805;-1640260456;1874183348;202245881;-187622857;110091926;-1967925974;-1430061070;1766704516;-380309479;-1355799460;-1550604137;674797767;2054309211;-2137297573;777426837;-554017816;-933361526;-1919615770;-1396554946;-23871574;-1585291722;-249522176;1812901808;631861586;567586903;-743434796;1633664913;622184746;1440302502;-1158193505;693401970;-1174985634;1724284522;744051099;-1235870353;497323876;1938449694;-914742316;1173752050;-2139087623;62412091;-1771168503;36295059;579928491;-282042109;214277513;382890507;-274398874;-2106991802;849205784;-771651636;858723874;713750041;1665114075;-1129736098;-221602372;-1766006017;-1368840610;164009794;726780532;1588215311;1515861965;-611988039;-1207122334;-560080067;-581106332;2110227006;146383141;-434041836;-1719418087;-752080626;1354905517;606194832;-2134129737;2101892753;-1467123364;-1802256615;-429229269;-344753267;-1808786808;1459176405;853269982;-376846181;1097873925;-1107126813;-1992307228;-423110123;1831052352;-601685448;696166801;-1523862007;638022537;722479175;-272805700;1400796398;-1363726448;1053776405;-939300948;-1295280943;505106422;1916060500;-916755169;414991474;-37695901;-612328927;845706612;-674248389;-175720764;1240513331;-399383817;756306713;943484559;-1587161825;-1824415400;-1960364303;1139516108;-436218092;315069979;-1249805073;-342044921;-1641217672;404219502;-561415856;594940732;53982510;-1898516538;-609543484;946951725;-1833462807;121618957;756734760;-82081665;-1644753416;1073432375;178945300;1980010108;1938862497;1541342512;990277944;-150080751;1892408316;786561215;-2037509101;239867934;1677198073;-520110119;1315962502;-1115758271;1342090771;-54467615;1130102771;1354396182;-1882239682;-522378751;-389940131;1976424122;1316255945;-70817460;2086627310;-1335920899;1649707499;-656275733;1693310582;-1687873667;-1774899475;523019863;273616406;-311188491;-1970529322;-574737278;2134470098;911143936;1882829212;289177939;-589481834;1989781739;-1600770113;-437846642;1407003501;-1338841262;1112759194;2009144765;-384027181;-1163775236;-100022516;1867015724;91966928;2112430437;969345132;-564940035;-1513719184;-551439335;1844122095;-1706144701;-1703170035;2052308923;-1119071528;-268158811;1062050630;-2025778944;-1823900119;1063321635;424158147;2040804584;-622649171;977874460;-1219982430;-2064583648;-1214053191;-1793521643;-464173251;450866475;1918674681;1220816519;1086893184;1001596915;-1630751937;1453049187;41513455;-1759131455;-2056132045;819994897;-1531805554;-1453858296;-2007649272;1923170596;438522419;771652362;397106045;-1459163844;-785478095;477130244;-466667573;-977384758;-1599149752;354561450;2120038272;346986851;-2142409164;-580956995;273313154;1049950046;1519043733;-1347933736;1099633103;-661240259;1457534074;1711386025;-1840420459;-1340008138;-145306852;-2084190325;2117373495;1222962055;1519257729;-673024375;-105587892;562583717;404843957;-109078149;-1965460782;-1208540372;1876221494;670400171;1341311915;-964497441;1345775790;-1278469431;-909922097;377443515;-1237802705;1246104137;54352143;-769768271;-2097548195;1301863517;-1490843019;-1124769460;-1669796299;-791015222;1813618258;-1221597797;1232932414;1506177275;-1359103563;-996205522;1093187048;3357986;1607365394;431056881;43885002;-1206592426;-193586242;-835680209;       };
       mti=344;
      };
     };
     TesselPrjnSpec @[6] {
      name="Input_PFC";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=1: y=1: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
       TessEl @[1] {
	send_off {x=0: y=0: };
	wt_val=1;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
     PFCLVPrjnSpec @[7] {
      name="PFC_LV_Prjn";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=PFCLVPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=22: y=9: z=3: };
    LeabraLayer @[0] {
     name="Hidden";
     desc=;
     flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
     layer_type=HIDDEN;
     pos {x=0: y=2: z=1: };
     disp_scale=1;
     un_geom {x=7: y=7: n_not_xy=0: n=49: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=7: y=7: n_not_xy=0: n=49: };
     scaled_act_geom {x=7: y=7: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[1]$$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs[2]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[3]$: };
       recv_idx=0;
       send_idx=9;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Output";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[2]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[2]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[3]$: };
       recv_idx=1;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[2] {
       name="Fm_PFC";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers.gp[2][0]$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[3][0]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][0]$$: };
       recv_idx=2;
       send_idx=8;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=DaModUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=7: n_not_xy=0: n=49: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=DaModUnitSpec: spec=.projects[0].networks[0].specs[0]$$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [7 7] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;     };
     netin {cmpt=1: avg=0.463504: max=0.6903784: max_i=25: };
     netin_top_k {cmpt=1: avg=0.6632244: max=0.6903784: max_i=4: };
     i_thrs {cmpt=1: avg=3.382219: max=5.023819: max_i=25: };
     acts {cmpt=1: avg=0.1425425: max=0.9133994: max_i=25: };
     acts_p {cmpt=1: avg=0.1308295: max=0.927622: max_i=25: };
     acts_m {cmpt=1: avg=0.1425425: max=0.9133994: max_i=25: };
     phase_dif_ratio=0.9978138;
     acts_p2 {cmpt=1: avg=0.1730829: max=0.8974027: max_i=41: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=7: pct=0.1428571: pct_c=0.8571429: adth_k=1: k_ithr=4.862242: k1_ithr=3.135548: ithr_r=0.4386955: ithr_diff=0.3551229: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=4.171565: g_i=4.171565: gp_g_i=0: g_i_orig=4.171565: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.154992: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     maxda=2.780775e-07;
     act_max_avg=0.9157109;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[1]$$: };
     hard_clamped=0;
     avg_l_avg=2.001295e-19;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="Input";
     desc=;
     flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
     layer_type=INPUT;
     pos {x=0: y=2: z=2: };
     disp_scale=1;
     un_geom {x=7: y=1: n_not_xy=0: n=7: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=7: y=1: n_not_xy=0: n=7: };
     scaled_act_geom {x=7: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[0].projections[0];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
	    Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers.gp[0][3].projections[1];
	    Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers.gp[0][2].projections[1];
	    Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers.gp[0][4].projections[1];
	    Projection_Group @. = [5] = LeabraPrjn .projects[0].networks[0].layers.gp[0][5].projections[1];
	    Projection_Group @. = [6] = LeabraPrjn .projects[0].networks[0].layers.gp[0][6].projections[0];
	    Projection_Group @. = [7] = LeabraPrjn .projects[0].networks[0].layers.gp[1][2].projections[2];
	    Projection_Group @. = [8] = LeabraPrjn .projects[0].networks[0].layers.gp[2][0].projections[2];
	    Projection_Group @. = [9] = LeabraPrjn .projects[0].networks[0].layers.gp[1][0].projections[1];
     };
     units {
      name=;
      el_typ=DaModUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=7: y=1: n_not_xy=0: n=7: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=EXT;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="S";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [7 1] "S";"I";"R";"A";"B";"C";"D";     };
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0.2857143: max=1: max_i=0: };
     acts_p {cmpt=1: avg=0.2857143: max=1: max_i=1: };
     acts_m {cmpt=1: avg=0.2857143: max=1: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0.1428571: max=1: max_i=2: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=2: pct=0.2857143: pct_c=0.7142857: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0.25: gp_g_i=0: g_i_orig=0.25: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2857143: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=1;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
     hard_clamped=1;
     avg_l_avg=1.356313e-19;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=-1;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="Output";
     desc=;
     flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
     layer_type=TARGET;
     pos {x=9: y=2: z=2: };
     disp_scale=1;
     un_geom {x=4: y=1: n_not_xy=0: n=4: };
     unit_groups=0;
     gp_geom {x=0: y=0: n_not_xy=0: n=0: };
     gp_spc {x=0: y=0: };
     act_geom {x=4: y=1: n_not_xy=0: n=4: };
     scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[2]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[3]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[1]$;
       spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs[2]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs[3]$: };
       recv_idx=1;
       send_idx=8;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[0].projections[1];
	    Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[0][1].projections[1];
     };
     units {
      name=;
      el_typ=DaModUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=4: y=1: n_not_xy=0: n=4: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=TARG;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="B";
     sse=0;
     icon_value=0;
     unit_names {
      name=;
	  [4 1] "A";"B";"C";"D";     };
     netin {cmpt=1: avg=0.532686: max=0.7417576: max_i=1: };
     netin_top_k {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     i_thrs {cmpt=1: avg=3.88904: max=5.456872: max_i=1: };
     acts {cmpt=1: avg=0.2358085: max=0.9420878: max_i=1: };
     acts_p {cmpt=1: avg=0.25: max=1: max_i=0: };
     acts_m {cmpt=1: avg=0.2358085: max=0.9420878: max_i=1: };
     phase_dif_ratio=0.9437304;
     acts_p2 {cmpt=1: avg=0.25: max=1: max_i=1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=5.456872: k1_ithr=3.648863: ithr_r=0.4024602: ithr_diff=0.3313271: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=4.100865: g_i=4.100865: gp_g_i=0: g_i_orig=4.100865: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2371975: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=4.639121e-10;
     act_max_avg=0.9423907;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[1].children[1]$$: };
     hard_clamped=0;
     avg_l_avg=nan;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    Layer_Group @.gp[0] {
     name="PVLV";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=0: y=0: z=0: };
     max_size {x=13: y=5: z=1: };
     LeabraLayer @[0] {
      name="RewTarg";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=INPUT;
      pos {x=12: y=4: z=0: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=1: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][1].projections[0];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
      ext_flag=EXT;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="rew_targ";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [1 1] "rew_targ";      };
      netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      acts {cmpt=1: avg=0: max=0: max_i=0: };
      acts_p {cmpt=1: avg=0: max=0: max_i=0: };
      acts_m {cmpt=1: avg=0: max=0: max_i=0: };
      phase_dif_ratio=1;
      acts_p2 {cmpt=1: avg=1: max=1: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=0.6: gp_g_i=0: g_i_orig=0.6: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=1: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0;
      spec {type=LeabraLayerSpec: spec=$.projects[0].networks[0].specs[1]$: };
      hard_clamped=1;
      avg_l_avg=1.663912e-33;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[1] {
      name="PVe";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=0: y=0: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_RewTarg";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][0]$$;
	spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[3][1]$$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=.projects[0].networks[0].specs.gp[1][1]$$: };
	recv_idx=0;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Output";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[2]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=1;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][3].projections[0];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[0][2].projections[0];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=.projects[0].networks[0].specs.gp[0][0]$$: };
      ext_flag=EXT;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="0.5";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1] ;;;;      };
      netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      acts {cmpt=1: avg=0.2375: max=0.95: max_i=2: };
      acts_p {cmpt=1: avg=0.2375: max=0.95: max_i=2: };
      acts_m {cmpt=1: avg=0.2375: max=0.95: max_i=2: };
      phase_dif_ratio=1;
      acts_p2 {cmpt=1: avg=0.2375: max=0.95: max_i=3: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=0.9: gp_g_i=0: g_i_orig=0.9: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.25: i_kwta_pt=0.9: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.95;
      spec {type=ExtRewLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][0]$: };
      hard_clamped=1;
      avg_l_avg=5.407882e+16;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[2] {
      name="PVi";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=0: y=2: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVe";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][1]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0]$: };
	recv_idx=1;
	send_idx=7;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0]$: };
	recv_idx=2;
	send_idx=7;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][7].projections[0];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[0];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="0.5";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1] ;;;;      };
      netin {cmpt=1: avg=0.05437439: max=0.1431042: max_i=2: };
      netin_top_k {cmpt=1: avg=0.1431042: max=0.1431042: max_i=0: };
      i_thrs {cmpt=1: avg=2.492787: max=7.083827: max_i=2: };
      acts {cmpt=1: avg=0.2145965: max=0.8404749: max_i=2: };
      acts_p {cmpt=1: avg=0.2148134: max=0.842941: max_i=2: };
      acts_m {cmpt=1: avg=0.2145965: max=0.8404749: max_i=2: };
      phase_dif_ratio=1.000016;
      acts_p2 {cmpt=1: avg=0.3005596: max=0.7492571: max_i=3: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=7.083827: k1_ithr=0.9624412: ithr_r=1.996097: ithr_diff=0.8641354: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=6.471688: g_i=6.471688: gp_g_i=0: g_i_orig=6.471688: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.2595804: i_kwta_pt=0.9: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.8421388;
      spec {type=PViLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][2]$: };
      hard_clamped=0;
      avg_l_avg=1.356313e-19;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[3] {
      name="PVr";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=0: y=4: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVe";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][1]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVrConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[1]$: };
	recv_idx=1;
	send_idx=6;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVrConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[1]$: };
	recv_idx=2;
	send_idx=6;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][4].projections[0];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[0][5].projections[0];
	      Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers.gp[0][7].projections[3];
	      Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers.gp[1][0].projections[0];
	      Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[3];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="0.5";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1] ;;;;      };
      netin {cmpt=1: avg=0.1892752: max=0.4596527: max_i=2: };
      netin_top_k {cmpt=1: avg=0.4596527: max=0.4596527: max_i=0: };
      i_thrs {cmpt=1: avg=8.091171: max=20.22059: max_i=2: };
      acts {cmpt=1: avg=0.2177687: max=0.8237861: max_i=2: };
      acts_p {cmpt=1: avg=0.215376: max=0.838968: max_i=2: };
      acts_m {cmpt=1: avg=0.2177687: max=0.8237861: max_i=2: };
      phase_dif_ratio=0.999988;
      acts_p2 {cmpt=1: avg=0.2279552: max=0.8228762: max_i=3: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=20.22059: k1_ithr=4.048032: ithr_r=1.608471: ithr_diff=0.7998065: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=18.60333: g_i=18.60333: gp_g_i=0: g_i_orig=18.60333: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.2324875: i_kwta_pt=0.9: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.8268275;
      spec {type=PVrLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][1]$: };
      hard_clamped=0;
      avg_l_avg=1.401298e-45;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[4] {
      name="LVe";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=6: y=0: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVr";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][3]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=4;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0]$: };
	recv_idx=1;
	send_idx=5;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=PFCLVPrjnSpec: spec=.projects[0].networks[0].specs.gp[3][7]$$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0]$: };
	recv_idx=2;
	send_idx=5;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][7].projections[1];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[1];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=DaModUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=4: y=1: n_not_xy=0: n=4: };
	units_lesioned=0;
	output_name="1";
	netin {cmpt=1: avg=0.05769879: max=0.1155189: max_i=3: };
	netin_top_k {cmpt=1: avg=0.1155189: max=0.1155189: max_i=0: };
	i_thrs {cmpt=1: avg=2.63075: max=4.694034: max_i=3: };
	acts {cmpt=1: avg=0.2682975: max=0.7597903: max_i=3: };
	acts_p {cmpt=1: avg=0.2616753: max=0.7619386: max_i=1: };
	acts_m {cmpt=1: avg=0.2682975: max=0.7597903: max_i=3: };
	phase_dif_ratio=1.001291;
	acts_p2 {cmpt=1: avg=0.2346177: max=0.8215627: max_i=3: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=4.694034: k1_ithr=1.942989: ithr_r=0.8820649: ithr_diff=0.5860727: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=4.418929: g_i=4.418929: gp_g_i=0: g_i_orig=4.418929: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.3231557: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
	maxda=0;
	act_max_avg=0.7597903;
	misc_state=0;
	misc_state1=0;
	misc_state2=0;
	misc_state3=0;
	misc_float=0;
	misc_float1=0;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=.projects[0].networks[0].specs.gp[0][0].children[0]$$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="1";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1 1 1] ;;;;      };
      netin {cmpt=1: avg=0.2307951: max=0.1155189: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=10.523: max=4.694034: max_i=0: };
      acts {cmpt=1: avg=0.2682975: max=0.7597903: max_i=0: };
      acts_p {cmpt=1: avg=0.2616753: max=0.7619386: max_i=0: };
      acts_m {cmpt=1: avg=0.2682975: max=0.7597903: max_i=0: };
      phase_dif_ratio=1.001291;
      acts_p2 {cmpt=1: avg=0.2346177: max=0.8215627: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=4.418929: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.3231557: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.7597903;
      spec {type=LVeLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][3]$: };
      hard_clamped=0;
      avg_l_avg=nan;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[5] {
      name="LVi";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=6: y=2: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVr";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][3]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=3;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0].children[0]$: };
	recv_idx=1;
	send_idx=4;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=PFCLVPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][7]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0].children[0]$: };
	recv_idx=2;
	send_idx=4;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][7].projections[2];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[2];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=DaModUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=4: y=1: n_not_xy=0: n=4: };
	units_lesioned=0;
	output_name="0.5";
	netin {cmpt=1: avg=0.06807317: max=0.09792607: max_i=3: };
	netin_top_k {cmpt=1: avg=0.08213757: max=0.08213757: max_i=0: };
	i_thrs {cmpt=1: avg=3.061287: max=4.55371: max_i=2: };
	acts {cmpt=1: avg=0.3836956: max=0.7207951: max_i=2: };
	acts_p {cmpt=1: avg=0.3705087: max=0.7237232: max_i=2: };
	acts_m {cmpt=1: avg=0.3836956: max=0.7207951: max_i=2: };
	phase_dif_ratio=0.9989643;
	acts_p2 {cmpt=1: avg=0.2616093: max=0.7639928: max_i=3: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=4.55371: k1_ithr=2.563812: ithr_r=0.5744469: ithr_diff=0.4369838: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=4.35472: g_i=4.35472: gp_g_i=0: g_i_orig=4.35472: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.3785389: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
	maxda=0;
	act_max_avg=0.7262737;
	misc_state=0;
	misc_state1=0;
	misc_state2=0;
	misc_state3=0;
	misc_float=0;
	misc_float1=0;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0].children[0]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="0.5";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1 1 1] ;;;;      };
      netin {cmpt=1: avg=0.2722927: max=0.09792607: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=12.24515: max=4.55371: max_i=0: };
      acts {cmpt=1: avg=0.3836956: max=0.7207951: max_i=0: };
      acts_p {cmpt=1: avg=0.3705087: max=0.7237232: max_i=0: };
      acts_m {cmpt=1: avg=0.3836956: max=0.7207951: max_i=0: };
      phase_dif_ratio=0.9989643;
      acts_p2 {cmpt=1: avg=0.2616093: max=0.7639928: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=4.35472: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.3785389: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.7262737;
      spec {type=LViLayerSpec: spec=.projects[0].networks[0].specs.gp[2][3].children[0]$$: };
      hard_clamped=0;
      avg_l_avg=9.027256e-33;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[6] {
      name="NV";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=6: y=4: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=4: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0]$: };
	recv_idx=0;
	send_idx=3;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=NVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[2]$: };
	recv_idx=1;
	send_idx=3;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][7].projections[4];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[4];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=4: y=1: n_not_xy=0: n=4: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="0";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 1] ;;;;      };
      netin {cmpt=1: avg=0.07667137: max=0.2056583: max_i=1: };
      netin_top_k {cmpt=1: avg=0.2056583: max=0.2056583: max_i=0: };
      i_thrs {cmpt=1: avg=3.418113: max=8.434819: max_i=1: };
      acts {cmpt=1: avg=0.2155741: max=0.8202075: max_i=1: };
      acts_p {cmpt=1: avg=0.214538: max=0.832839: max_i=1: };
      acts_m {cmpt=1: avg=0.2155741: max=0.8202075: max_i=1: };
      phase_dif_ratio=1.000001;
      acts_p2 {cmpt=1: avg=0.2178252: max=0.865285: max_i=1: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=8.434819: k1_ithr=1.745877: ithr_r=1.575111: ithr_diff=0.7930155: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=7.765925: g_i=7.765925: gp_g_i=0: g_i_orig=7.765925: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.2224914: i_kwta_pt=6.359359e-07: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.8251904;
      spec {type=NVLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][4]$: };
      hard_clamped=0;
      avg_l_avg=0.00386241;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[7] {
      name="VTA";
      desc=;
      flags=;
      layer_type=HIDDEN;
      pos {x=12: y=0: z=0: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=0;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=1: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVi";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][2]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_LVe";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][4]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=1;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_LVi";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][5]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=2;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[3] {
	name="Fm_PVr";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][3]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=3;
	send_idx=2;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[4] {
	name="Fm_NV";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[0][6]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=4;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
      };
      unit_spec {type=DaModUnitSpec: spec=.projects[0].networks[0].specs.gp[0][1]$$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name=;
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [1 1] ;      };
      netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      acts {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
      acts_p {cmpt=1: avg=0.0005948097: max=0.0005948097: max_i=0: };
      acts_m {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
      phase_dif_ratio=1.999098;
      acts_p2 {cmpt=1: avg=0.04060891: max=0.04060891: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.05352848: i_kwta_pt=-0.6499997: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.5591025;
      spec {type=PVLVDaLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][9]$: };
      hard_clamped=0;
      avg_l_avg=1.356313e-19;
      dav=0.5591025;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
    };
    Layer_Group @.gp[1] {
     name="PBWM_BG";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=11: y=0: z=0: };
     max_size {x=8: y=9: z=2: };
     LeabraLayer @[0] {
      name="Patch";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=4: y=0: z=0: };
      disp_scale=1;
      un_geom {x=4: y=1: n_not_xy=0: n=4: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=4: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVr";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][3]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0]$: };
	recv_idx=1;
	send_idx=2;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=GpOneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[3][2]$$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=PVConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0].children[0]$: };
	recv_idx=2;
	send_idx=2;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[1][2].projections[4];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[1][1].projections[5];
      };
      units {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=LeabraUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=4: y=1: n_not_xy=0: n=4: };
	units_lesioned=0;
	output_name="1";
	netin {cmpt=1: avg=0.05769879: max=0.1155189: max_i=3: };
	netin_top_k {cmpt=1: avg=0.1155189: max=0.1155189: max_i=0: };
	i_thrs {cmpt=1: avg=2.63075: max=4.694034: max_i=3: };
	acts {cmpt=1: avg=0.2682975: max=0.7597903: max_i=3: };
	acts_p {cmpt=1: avg=0.2616753: max=0.7619386: max_i=1: };
	acts_m {cmpt=1: avg=0.2682975: max=0.7597903: max_i=3: };
	phase_dif_ratio=1.001291;
	acts_p2 {cmpt=1: avg=0.2346177: max=0.8215627: max_i=3: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=4.694034: k1_ithr=1.942989: ithr_r=0.8820649: ithr_diff=0.5860727: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=4.418929: g_i=4.418929: gp_g_i=0: g_i_orig=4.418929: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.3231557: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
	maxda=0;
	act_max_avg=0.7597903;
	misc_state=1;
	misc_state1=4;
	misc_state2=2;
	misc_state3=0;
	misc_float=0.9794551;
	misc_float1=0.9783738;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0].children[0]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="1";
      sse=0;
      icon_value=0;
      netin {cmpt=1: avg=0.2307951: max=0.1155189: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=10.523: max=4.694034: max_i=0: };
      acts {cmpt=1: avg=0.2682975: max=0.7597903: max_i=0: };
      acts_p {cmpt=1: avg=0.2616753: max=0.7619386: max_i=0: };
      acts_m {cmpt=1: avg=0.2682975: max=0.7597903: max_i=0: };
      phase_dif_ratio=1.001291;
      acts_p2 {cmpt=1: avg=0.2346177: max=0.8215627: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=4.418929: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.3231557: i_kwta_pt=1.799999: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.7597903;
      spec {type=PatchLayerSpec: spec=.projects[0].networks[0].specs.gp[2][3].children[1]$$: };
      hard_clamped=0;
      avg_l_avg=1.144609e+24;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[1] {
      name="SNc";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=5: y=2: z=0: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=1: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_PVi";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][2]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_LVe";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][4]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=1;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_LVi";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][5]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=2;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[3] {
	name="Fm_PVr";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][3]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=3;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[4] {
	name="Fm_NV";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[0][6]$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=4;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[5] {
	name="Fm_Patch";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[1][0]$$;
	spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=5;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[1][2].projections[3];
      };
      units {
       name=;
       el_typ=LeabraUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=LeabraUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=1: y=1: n_not_xy=0: n=1: };
	units_lesioned=0;
	output_name=;
	netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
	netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
	i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
	acts {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
	acts_p {cmpt=1: avg=0.0005948097: max=0.0005948097: max_i=0: };
	acts_m {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
	phase_dif_ratio=1.999098;
	acts_p2 {cmpt=1: avg=0.2436535: max=0.2436535: max_i=0: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.25: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
	maxda=0;
	act_max_avg=0.5591025;
	misc_state=0;
	misc_state1=0;
	misc_state2=0;
	misc_state3=0;
	misc_float=0;
	misc_float1=0;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][1]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name=;
      sse=0;
      icon_value=0;
      netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      acts {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
      acts_p {cmpt=1: avg=0.0005948097: max=0.0005948097: max_i=0: };
      acts_m {cmpt=1: avg=0.5591025: max=0.5591025: max_i=0: };
      phase_dif_ratio=1.999098;
      acts_p2 {cmpt=1: avg=0.2436535: max=0.2436535: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.05340239: i_kwta_pt=-0.6499997: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.5591025;
      spec {type=SNcLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][5].children[0]$: };
      hard_clamped=0;
      avg_l_avg=9.367362e-39;
      dav=0.5591025;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[2] {
      name="Matrix";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=0: y=2: z=1: };
      disp_scale=1;
      un_geom {x=4: y=7: n_not_xy=0: n=28: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=4: y=7: n_not_xy=0: n=1: };
      scaled_act_geom {x=4: y=7: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_SNrThal";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[1][3]$$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_PFC";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=MatrixCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MatrixConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[3].children[0]$: };
	recv_idx=1;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=FullPrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][0]$: };
	con_type=MatrixCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MatrixConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[3]$: };
	recv_idx=2;
	send_idx=1;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[3] {
	name="Fm_SNc";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[1][1]$$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=3;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[4] {
	name="Fm_Patch";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[1][0]$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=4;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[1][3].projections[0];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=DaModUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=4: y=7: n_not_xy=0: n=28: };
	units_lesioned=0;
	output_name="Go";
	netin {cmpt=1: avg=0.5012091: max=0.5223856: max_i=13: };
	netin_top_k {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
	i_thrs {cmpt=1: avg=3.659068: max=3.817892: max_i=13: };
	acts {cmpt=1: avg=0.05736661: max=0.4904254: max_i=13: };
	acts_p {cmpt=1: avg=0.04467216: max=0.32198: max_i=21: };
	acts_m {cmpt=1: avg=0.05736661: max=0.4904254: max_i=13: };
	phase_dif_ratio=1.000002;
	acts_p2 {cmpt=1: avg=0.1692256: max=0.9243819: max_i=5: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=4: pct=0.1428571: pct_c=0.8571429: adth_k=1: k_ithr=3.729419: k1_ithr=3.689036: ithr_r=0.01088727: ithr_diff=0.006007486: tie_brk_gain=0.9699626: eff_loser_gain=1.969963: tie_brk=1: };
	i_val {kwta=3.699132: g_i=3.699132: gp_g_i=0: g_i_orig=3.699132: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.05126678: i_kwta_pt=-0.6499997: g_bar_i=1: g_bar_l=0.1: };
	maxda=0;
	act_max_avg=0.4919616;
	misc_state=1;
	misc_state1=30;
	misc_state2=2;
	misc_state3=32;
	misc_float=0;
	misc_float1=0;
	misc_float2=0;
       };
      };
      unit_spec {type=MatrixUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][3]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="Go";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [4 7 1 1] "Go";"Nogo";"Go";"NoGo";;;;;;;
;;;;;;;;;;
;;;;;;;;      };
      netin {cmpt=1: avg=14.03385: max=0.5223856: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=102.4539: max=3.817892: max_i=0: };
      acts {cmpt=1: avg=0.05736661: max=0.4904254: max_i=0: };
      acts_p {cmpt=1: avg=0.04467216: max=0.32198: max_i=0: };
      acts_m {cmpt=1: avg=0.05736661: max=0.4904254: max_i=0: };
      phase_dif_ratio=1.000002;
      acts_p2 {cmpt=1: avg=0.1692256: max=0.9243819: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=4: pct=0.1428571: pct_c=0.8571429: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=3.699132: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.05126678: i_kwta_pt=-0.6499997: g_bar_i=1: g_bar_l=0.1: };
      maxda=0;
      act_max_avg=0.4919616;
      spec {type=MatrixLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][7]$: };
      hard_clamped=0;
      avg_l_avg=9.705644e+24;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
     LeabraLayer @[3] {
      name="SNrThal";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=7: y=2: z=1: };
      disp_scale=1;
      un_geom {x=1: y=1: n_not_xy=0: n=1: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=1: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_Matrix";
	from_type=CUSTOM;
	from=.projects[0].networks[0].layers.gp[1][2]$$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[1][2].projections[0];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[2][0].projections[0];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=DaModUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=1: y=1: n_not_xy=0: n=1: };
	units_lesioned=0;
	output_name=;
	netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
	netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
	i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
	acts {cmpt=1: avg=0.9920983: max=0.9920983: max_i=0: };
	acts_p {cmpt=1: avg=0.9899954: max=0.9899954: max_i=0: };
	acts_m {cmpt=1: avg=0.9920983: max=0.9920983: max_i=0: };
	phase_dif_ratio=0.9998692;
	acts_p2 {cmpt=1: avg=0.9164521: max=0.9164521: max_i=0: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.25: i_kwta_pt=0.8: g_bar_i=1: g_bar_l=0.8: };
	maxda=0;
	act_max_avg=0.9920983;
	misc_state=1;
	misc_state1=4;
	misc_state2=2;
	misc_state3=0;
	misc_float=0.9794551;
	misc_float1=0.9783738;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=.projects[0].networks[0].specs.gp[0][4]$$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name=;
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [1 1 1 1] ;      };
      netin {cmpt=1: avg=0.4699569: max=0.4699569: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
      i_thrs {cmpt=1: avg=2.724677: max=2.724677: max_i=0: };
      acts {cmpt=1: avg=0.9920983: max=0.9920983: max_i=0: };
      acts_p {cmpt=1: avg=0.9899954: max=0.9899954: max_i=0: };
      acts_m {cmpt=1: avg=0.9920983: max=0.9920983: max_i=0: };
      phase_dif_ratio=0.9998692;
      acts_p2 {cmpt=1: avg=0.9164521: max=0.9164521: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0.2081974: k1_ithr=-0.4865944: ithr_r=0: ithr_diff=3.337178: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.464255: i_kwta_pt=-0.09999993: g_bar_i=1: g_bar_l=0.8: };
      maxda=0;
      act_max_avg=0.9920983;
      spec {type=SNrThalLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][8]$: };
      hard_clamped=0;
      avg_l_avg=7.438859e-39;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
    };
    Layer_Group @.gp[2] {
     name="PBWM_PFC";
     el_typ=LeabraLayer;
     el_def=0;
     pos {x=15: y=2: z=2: };
     max_size {x=7: y=1: z=1: };
     LeabraLayer @[0] {
      name="PFC";
      desc=;
      flags=PROJECT_WTS_NEXT|PROJECT_WTS_DONE;
      layer_type=HIDDEN;
      pos {x=0: y=0: z=0: };
      disp_scale=1;
      un_geom {x=7: y=1: n_not_xy=0: n=7: };
      unit_groups=1;
      gp_geom {x=1: y=1: n_not_xy=0: n=1: };
      gp_spc {x=1: y=1: };
      act_geom {x=7: y=1: n_not_xy=0: n=1: };
      scaled_act_geom {x=7: y=1: n_not_xy=0: n=1: };
      projections {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
       LeabraPrjn @[0] {
	name="Fm_SNrThal";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers.gp[1][3]$;
	spec {type=GpOneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][2]$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
	recv_idx=0;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[1] {
	name="Fm_PFC";
	from_type=SELF;
	from=$.projects[0].networks[0].layers.gp[2][0]$;
	spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[3][4]$$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs.gp[1][2]$: };
	recv_idx=1;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
       LeabraPrjn @[2] {
	name="Fm_Input";
	from_type=CUSTOM;
	from=$.projects[0].networks[0].layers[1]$;
	spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[3][6]$$: };
	con_type=LeabraCon;
	recvcons_type=LeabraRecvCons;
	sendcons_type=LeabraSendCons;
	con_spec {type=LeabraConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[2]$: };
	recv_idx=2;
	send_idx=0;
	recv_n=1;
	send_n=1;
	projected=1;
	direction=DIR_UNKNOWN;
	netin_avg=0;
	netin_rel=0;
	avg_netin_avg=0;
	avg_netin_avg_sum=0;
	avg_netin_rel=0;
	avg_netin_rel_sum=0;
	avg_netin_n=0;
	trg_netin_rel=-1;
       };
      };
      send_prjns {
       name=;
       el_typ=LeabraPrjn;
       el_def=0;
	      Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers.gp[0][3].projections[2];
	      Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers.gp[0][2].projections[2];
	      Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers.gp[0][4].projections[2];
	      Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers.gp[0][5].projections[2];
	      Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers.gp[0][6].projections[1];
	      Projection_Group @. = [5] = LeabraPrjn .projects[0].networks[0].layers[0].projections[2];
	      Projection_Group @. = [6] = LeabraPrjn .projects[0].networks[0].layers.gp[1][2].projections[1];
	      Projection_Group @. = [7] = LeabraPrjn .projects[0].networks[0].layers.gp[2][0].projections[1];
	      Projection_Group @. = [8] = LeabraPrjn .projects[0].networks[0].layers.gp[1][0].projections[2];
      };
      units {
       name=;
       el_typ=DaModUnit;
       el_def=0;
       pos {x=0: y=0: z=0: };
       unique_geom=0;
       geom {x=1: y=1: n_not_xy=0: n=1: };
       units_lesioned=0;
       output_name=;
       LeabraUnit_Group @.gp[0] {
	name=;
	el_typ=DaModUnit;
	el_def=0;
	pos {x=0: y=0: z=0: };
	unique_geom=0;
	geom {x=7: y=1: n_not_xy=0: n=7: };
	units_lesioned=0;
	output_name="S";
	netin {cmpt=1: avg=0.160425: max=0.5614876: max_i=0: };
	netin_top_k {cmpt=1: avg=0.5614876: max=0.5614876: max_i=0: };
	i_thrs {cmpt=1: avg=1.103188: max=4.111157: max_i=0: };
	acts {cmpt=1: avg=0.2772017: max=0.970206: max_i=0: };
	acts_p {cmpt=1: avg=0.2772084: max=0.9702293: max_i=1: };
	acts_m {cmpt=1: avg=0.2772017: max=0.970206: max_i=0: };
	phase_dif_ratio=0.99998;
	acts_p2 {cmpt=1: avg=0.1386041: max=0.970229: max_i=2: };
	acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
	kwta {k=2: pct=0.2857143: pct_c=0.7142857: adth_k=1: k_ithr=4.111157: k1_ithr=-0.1: ithr_r=0: ithr_diff=1.024324: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
	i_val {kwta=2.426694: g_i=2.426694: gp_g_i=0: g_i_orig=2.426694: i_netin_mod=0: };
	un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
	adapt_i {avg_avg=0.276522: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
	maxda=1.043892e-05;
	act_max_avg=0.970206;
	misc_state=1;
	misc_state1=4;
	misc_state2=2;
	misc_state3=0;
	misc_float=0.9794551;
	misc_float1=0.9783738;
	misc_float2=0;
       };
      };
      unit_spec {type=DaModUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][2]$: };
      ext_flag=;
      dmem_dist=DMEM_DIST_DEFAULT;
      dist {
       fm_input=-1;
       fm_output=-1;
      };
      output_name="S";
      sse=0;
      icon_value=0;
      unit_names {
       name=;
	    [7 1 1 1] "S";"I";"R";"A";"B";"C";"D";      };
      netin {cmpt=1: avg=1.122975: max=0.5614876: max_i=0: };
      netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
      i_thrs {cmpt=1: avg=7.722315: max=4.111157: max_i=0: };
      acts {cmpt=1: avg=0.2772017: max=0.970206: max_i=0: };
      acts_p {cmpt=1: avg=0.2772084: max=0.9702293: max_i=0: };
      acts_m {cmpt=1: avg=0.2772017: max=0.970206: max_i=0: };
      phase_dif_ratio=0.99998;
      acts_p2 {cmpt=1: avg=0.1386041: max=0.970229: max_i=0: };
      acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
      kwta {k=2: pct=0.2857143: pct_c=0.7142857: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
      i_val {kwta=0: g_i=2.426694: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
      un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
      adapt_i {avg_avg=0.276522: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
      maxda=1.043892e-05;
      act_max_avg=0.970206;
      spec {type=PFCLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][6]$: };
      hard_clamped=0;
      avg_l_avg=3.785733e+22;
      dav=0;
      avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
      avg_netin_n=0;
      norm_err=-1;
      da_updt=0;
     };
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=5;
   group=0;
   trial=69;
   tick=0;
   cycle=35;
   time=41512;
   group_name="S";
   trial_name="S_B";
   output_name="B";
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=23.38356;
   avg_sse=0.2338356;
   cnt_err_tol=0;
   cnt_err=14;
   pct_err=0.14;
   pct_cor=0.86;
   cur_sum_sse=14.2121;
   avg_sse_n=70;
   cur_cnt_err=8;
   train_time {name="train_time": start={usr=21290: sys=39841: tot=1718502479: }: end={usr=21290: sys=13929: tot=1718365587: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="epoch_time": start={usr=21290: sys=40817: tot=1718503626: }: end={usr=21290: sys=40816: tot=1718503625: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=-1.568575449349152e+308;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=JUST_WEIGHTS;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=127;
   n_cons=2087;
   max_size {x=22: y=9: z=3: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=0;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=2;
   ct_cycle=35;
   time_inc=1;
   cycle_max=60;
   mid_minus_cycle=25;
   min_cycles=35;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=5;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=35;
   avg_cycles=36.52;
   avg_cycles_sum=2575;
   avg_cycles_n=70;
   minus_output_name="B";
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=115;
   avg_send_pct=0.04925121;
   avg_send_pct_sum=251.1234;
   avg_send_pct_n=4990;
   maxda_stopcrit=0.005;
   maxda=1.043892e-05;
   trg_max_act_stopcrit=1;
   trg_max_act=0.9420878;
   ext_rew=-1.1;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0.44;
   pvlv_pvi=0.5026621;
   pvlv_pvr=0.5185691;
   pvlv_lve=0.5281171;
   pvlv_lvi=0.5281171;
   pv_detected=0;
   avg_ext_rew_sum=8;
   avg_ext_rew_n=16;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=0.14;
   avg_norm_err_sum=8;
   avg_norm_err_n=70;
  };
 };
};
