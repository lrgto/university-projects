// ta_Dump File v3.0 -- code v5.1.0.0
LeabraProject .projects[0] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [2] {
    taDoc @[0] { };
    taDoc @[1] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [2] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
      };
    };
  };

  SelectEdit_Group @.edits = [2] {
    SelectEdit @[0] { 
      EditMbrItem_Group @.mbrs = [0] {
	EditMbrItem_Group @.gp[0] = [3] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	};
	EditMbrItem_Group @.gp[1] = [7] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	  EditMbrItem @[4] { };
	  EditMbrItem @[5] { };
	  EditMbrItem @[6] { };
	};
	EditMbrItem_Group @.gp[2] = [4] { 
	  EditMbrItem @[0] { };
	  EditMbrItem @[1] { };
	  EditMbrItem @[2] { };
	  EditMbrItem @[3] { };
	};
      };

      EditMthItem_Group @.mths = [6] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
	EditMthItem @[5] { };
      };
    };
    SelectEdit @[1] { 
      EditMbrItem_Group @.mbrs = [3] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
      };

      EditMthItem_Group @.mths = [0] {
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [1] { 
      DataTable @[0] { 
	DataTableCols @.data = [4] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp[1] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [12] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  String_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  String_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  float_Data @[6] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[7] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[8] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[9] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[10] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[11] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [8] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	};
      };
    };
    DataTable_Group @.gp[2] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [3] {
    Program @[0] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [1] {
	DynEnumType @[0] { 
	  DynEnumItem_List @.enums = [6] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	    DynEnumItem @[2] { };
	    DynEnumItem @[3] { };
	    DynEnumItem @[4] { };
	    DynEnumItem @[5] { };
	  };
	};
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [21] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
	ProgVar @[6] { };
	ProgVar @[7] { };
	ProgVar @[8] { };
	ProgVar @[9] { };
	ProgVar @[10] { };
	ProgVar @[11] { };
	ProgVar @[12] { };
	ProgVar @[13] { };
	ProgVar @[14] { };
	ProgVar @[15] { };
	ProgVar @[16] { };
	ProgVar @[17] { };
	ProgVar @[18] { };
	ProgVar @[19] { };
	ProgVar @[20] { };
      };

      Function_List @.functions = [3] {
	Function @[0] { 
	  ProgVar_List @.args = [5] {
	    ProgVar @[0] { };
	    ProgVar @[1] { };
	    ProgVar @[2] { };
	    ProgVar @[3] { };
	    ProgVar @[4] { };
	  };

	  ProgEl_List @.fun_code = [5] {
	    ProgVars @[0] { 
	      ProgVar_List @.local_vars = [3] {
		ProgVar @[0] { };
		ProgVar @[1] { };
		ProgVar @[2] { };
	      };
	    };
	    RandomCall @[1] { 
	      ProgArg_List @.meth_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    AssignExpr @[2] { };
	    AssignExpr @[3] { };
	    ForLoop @[4] { 
	      ProgEl_List @.loop_code = [1] {
		MethodCall @[0] { 
		  ProgArg_List @.meth_args = [8] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		    ProgArg @[4] { };
		    ProgArg @[5] { };
		    ProgArg @[6] { };
		    ProgArg @[7] { };
		  };
		};
	      };
	    };
	  };
	};
	Function @[1] { 
	  ProgVar_List @.args = [1] {
	    ProgVar @[0] { };
	  };

	  ProgEl_List @.fun_code = [5] {
	    ProgVars @[0] { 
	      ProgVar_List @.local_vars = [3] {
		ProgVar @[0] { };
		ProgVar @[1] { };
		ProgVar @[2] { };
	      };
	    };
	    RandomCall @[1] { 
	      ProgArg_List @.meth_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    AssignExpr @[2] { };
	    AssignExpr @[3] { };
	    ForLoop @[4] { 
	      ProgEl_List @.loop_code = [1] {
		MethodCall @[0] { 
		  ProgArg_List @.meth_args = [8] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		    ProgArg @[4] { };
		    ProgArg @[5] { };
		    ProgArg @[6] { };
		    ProgArg @[7] { };
		  };
		};
	      };
	    };
	  };
	};
	Function @[2] { 
	  ProgVar_List @.args = [1] {
	    ProgVar @[0] { };
	  };

	  ProgEl_List @.fun_code = [2] {
	    ProgVars @[0] { 
	      ProgVar_List @.local_vars = [1] {
		ProgVar @[0] { };
	      };
	    };
	    ForLoop @[1] { 
	      ProgEl_List @.loop_code = [2] {
		MethodCall @[0] { 
		  ProgArg_List @.meth_args = [4] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		  };
		};
		MethodCall @[1] { 
		  ProgArg_List @.meth_args = [4] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		  };
		};
	      };
	    };
	  };
	};
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [2] {
	ResetDataRows @[0] { };
	ForLoop @[1] { 
	  ProgEl_List @.loop_code = [18] {
	    AssignExpr @[0] { };
	    MethodCall @[1] { 
	      ProgArg_List @.meth_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    FunctionCall @[2] { 
	      ProgArg_List @.fun_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    Comment @[3] { };
	    AssignExpr @[4] { };
	    AssignExpr @[5] { };
	    AssignExpr @[6] { };
	    If @[7] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    If @[8] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    If @[9] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    RandomCall @[10] { 
	      ProgArg_List @.meth_args = [0] {
	      };
	    };
	    If @[11] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    If @[12] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    If @[13] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    If @[14] { 
	      ProgEl_List @.true_code = [1] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [5] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		    ProgArg @[4] { };
		  };
		};
	      };
	    };
	    If @[15] { 
	      ProgEl_List @.true_code = [1] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [5] {
		    ProgArg @[0] { };
		    ProgArg @[1] { };
		    ProgArg @[2] { };
		    ProgArg @[3] { };
		    ProgArg @[4] { };
		  };
		};
	      };
	    };
	    If @[16] { 
	      ProgEl_List @.true_code = [1] {
		FunctionCall @[0] { 
		  ProgArg_List @.fun_args = [1] {
		    ProgArg @[0] { };
		  };
		};
	      };
	    };
	    DoneWritingDataRow @[17] { };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [1] {
	ProgVar @[0] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [1] {
	ResetDataRows @[0] { };
      };
    };
    Program @[2] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.load_code = [0] {
      };

      ProgEl_List @.init_code = [0] {
      };

      ProgEl_List @.prog_code = [3] {
	AssignExpr @[0] { };
	AssignExpr @[1] { };
	ForLoop @[2] { 
	  ProgEl_List @.loop_code = [3] {
	    MemberAssign @[0] { };
	    MemberAssign @[1] { };
	    MemberAssign @[2] { };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [8] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	  ProgVar @[7] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [5] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [7] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [3] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	      PrintExpr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  AssignExpr @[4] { };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[2] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetGroupedDataLoop @[4] { 
	    ProgEl_List @.loop_code = [1] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[8] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @[3] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  ProgramCall @[5] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @[4] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[5] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [3] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [13] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	      NetMonItem @[10] { };
	      NetMonItem @[11] { };
	      NetMonItem @[12] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [9] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  AssignExpr @[3] { };
	  AssignExpr @[4] { };
	  AssignExpr @[5] { };
	  DataVarProg @[6] { };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @[9] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.load_code = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [2] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [2] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [9] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		    ScaleRange @[4] { };
		    ScaleRange @[5] { };
		    ScaleRange @[6] { };
		    ScaleRange @[7] { };
		    ScaleRange @[8] { };
		  };
		};
		GraphTableView @[1] { 
		  T3DataView_List @.children = [12] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		    GraphColView @[8] { };
		    GraphColView @[9] { };
		    GraphColView @[10] { };
		    GraphColView @[11] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [4] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @[0] { };
		T3SavedView @[1] { };
		T3SavedView @[2] { };
		T3SavedView @[3] { };
		T3SavedView @[4] { };
		T3SavedView @[5] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @[0] { };
	    UserDataItem @[1] { };
	    UserDataItem @[2] { };
	    UserDataItem @[3] { };
	    UserDataItem @[4] { };
	    UserDataItem @[5] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @[0] { };
	UserDataItem @[1] { };
	UserDataItem @[2] { };
	UserDataItem @[3] { };
	UserDataItem @[4] { };
	UserDataItem @[5] { };
	UserDataItem @[6] { };
	UserDataItem @[7] { };
	UserDataItem @[8] { };
	UserDataItem @[9] { };
	UserDataItem @[10] { };
	UserDataItem @[11] { };
	UserDataItem @[12] { };
	UserDataItem @[13] { };
	UserDataItem @[14] { };
	UserDataItem @[15] { };
	UserDataItem @[16] { };
	UserDataItem @[17] { };
	UserDataItem @[18] { };
   };

      BaseSpec_Group @.specs = [4] {
	LeabraTdUnitSpec @[0] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraLayerSpec @[1] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraLayerSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };
	    };
	  };
	};
	FullPrjnSpec @[2] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraConSpec @[3] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraBiasSpec @[0] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	BaseSpec_Group @.gp[0] = [2] { 
	  LeabraTdUnitSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	  LeabraTdUnitSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.noise_sched = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[1] = [2] { 
	  LeabraConSpec @[0] { 
	    BaseSpec_Group @.children = [2] {
	      TDRewPredConSpec @[0] { 
		BaseSpec_Group @.children = [0] {
		};

		Schedule @.lrate_sched = [0] {
		};
	      };
	      LeabraBiasSpec @[1] { 
		BaseSpec_Group @.children = [1] {
		  LeabraBiasSpec @[0] { 
		    BaseSpec_Group @.children = [0] {
		    };

		    Schedule @.lrate_sched = [0] {
		    };
		  };
		};

		Schedule @.lrate_sched = [0] {
		};
	      };
	    };

	    Schedule @.lrate_sched = [0] {
	    };
	  };
	  MarkerConSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    Schedule @.lrate_sched = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[2] = [4] { 
	  ExtRewLayerSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TDRewPredLayerSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TDRewIntegLayerSpec @[2] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TdLayerSpec @[3] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	};
	BaseSpec_Group @.gp[3] = [2] { 
	  FullPrjnSpec @[0] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @[1] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	};
      };

      Layer_Group @.layers = [5] {
	LeabraLayer @[0] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [12] {
	    LeabraTdUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[2] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[3] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[4] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[5] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[6] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[7] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[8] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[9] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[10] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[11] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [22] {
	    LeabraTdUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[2] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[3] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[4] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[5] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[6] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[7] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[8] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[9] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[10] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[11] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[12] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[13] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[14] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[15] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[16] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[17] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[18] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[19] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[20] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[21] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [0]		};
		LeabraRecvCons @[1] { 
	  [60]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [22] {
	    LeabraTdUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraTdUnit @[1] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[2] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[3] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[4] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[5] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[6] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[7] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[8] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[9] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[10] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[11] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[12] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[13] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[14] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[15] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[16] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[17] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[18] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[19] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[20] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	    LeabraTdUnit @[21] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [1]		};
		LeabraRecvCons @[1] { 
	  [0]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [0]		};
	      };
	    };
	  };
	};
	LeabraLayer @[3] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [1] {
	    LeabraTdUnit @[0] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [1] {
		LeabraRecvCons @[0] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @[4] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [60] {
	    LeabraTdUnit @[0] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[1] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[2] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[3] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[4] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[5] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[6] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[7] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[8] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[9] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[10] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[11] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[12] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[13] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[14] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[15] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[16] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[17] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[18] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[19] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[20] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[21] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[22] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[23] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[24] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[25] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[26] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[27] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[28] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[29] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[30] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[31] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[32] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[33] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[34] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[35] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[36] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[37] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[38] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[39] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[40] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[41] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[42] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[43] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[44] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[45] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[46] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[47] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[48] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[49] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[50] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[51] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[52] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[53] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[54] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[55] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[56] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[57] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[58] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	    LeabraTdUnit @[59] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [22]		};
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects[0] {
 name="Project_0";
 desc=;
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head></head>
<body>
= Reinforcement Learning and Classical Conditioning =

* To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

''This replaces section 6.7.3 in the Computational Explorations.. textbook''

To explore the TD learning rule (using a new version of the phase-based implementation described in the textbook in Chapter 6 -- see next section for details), we use the simple classical conditioning task discussed in the textbook section XXX.  Thus, the network will learn that a stimulus (tone) reliably predicts the reward (and then that another stimulus reliably predicts that tone).  First, we need to justify the use of the TD algorithm in this context, and motivate the nature of the stimulus representations used in the network.

You might recall that we said that the delta rule (aka the Rescorla-Wagner rule) provides a good model of classical conditioning, and thus wonder why TD is needed.  It all has to do with the issue of ''timing''.  If one ignores the timing of the stimulus relative to the response, then in fact the TD rule becomes equivalent to the delta rule when everything happens at one time step (it just trains V(t) to match r(t)).  However, animals are sensitive to the timing relationship, and, more importantly for our purposes, modeling this timing provides a particularly clear and simple demonstration of the basic properties of TD learning.

The only problem is that this simple demonstration involves a somewhat unrealistic representation of timing.  Basically, the stimulus representation has a distinct unit for each stimulus for each point in time, so that there is something unique for the TD system to learn from.  This representation is the '''complete serial compound''' (CSC) proposed by Sutton & Barto (1990), and we will see exactly how it works when we look at the model.  As we have noted, we will explore a more plausible alternative in chapter 9 where the TD error signal controls the updating of a context representation that maintains the stimulus over time.

== Important Differences From Textbook ==

This model employs a \"new and improved\" implementation of the TD (temporal differences) learning algorithm within the Leabra framework.  Instead of the single ''adaptive critic'' (AC) unit as described in the text, there are now 4 separate TD layers that each compute a part of the overall TD algorithm, as described below.  Separating out the computations like this fixes a limitation with the previous version, and is computationally necessary to do a fully accurate implementation of TD using phase-based activation states in Leabra.

Each of these layers, except the one labeled TD, uses a distributed ''Scalar Value'' representation to encode a scalar value in terms of a pattern of activity across the units.  Specifically, each unit has a preferred value for which it will fire maximally -- this value is shown above the unit in the network.  It will also fire less strongly for nearby values, in an overall Gaussian fashion.  The actual value represented across the whole layer is shown in the first unit in the layer strictly for display purposes (it does not participate in the distributed code, and is removed from sending net input to other layers because the act value is always 0 -- it is only visible when viewing the act_eq or act_m, act_p values) -- it is computed by taking the weighted average over the units in the layer of the unit's target value times its activation.

The actual TD computations are performed by the simulation code using these scalar values extracted from the associated layers, and are not directly computed by the network-level interactions among the layers themselves.  Although it is possible to get units to compute the necessary additions and subtractions required by the TD algorithm, it is much simpler and more robust to perform these calculations directly using the values represented by the layers.  The critical network-level computation is learning about the reward value of stimuli, and this is done using standard learning mechanisms in the TDRewPred layer.

Here is a description of what each layer does:
* '''ExtRew''' -- just represents the external reward input -- it doesn't do any computation, but just provides a way to display in the network what the current reward value is.  It gets input from the input data table, representing the US (unconditioned stimulus).
* '''TDRewPred''' -- this is the key learning layer, which learns to predict the reward value on the next time step based on the current stimulus inputs: V(t+1).  This prediction is generated in the ''plus phase'' of leabra settling based on its current weights from the iput layer, whereas in the minus phase the layer's state is clamped to the prediction made on the previous trial: V(t).
* '''TDRewInteg''' -- this layer integrates the reward prediction and external reward layer values, and the difference in its plus-minus phase activation states are what drive the TD delta (dopamine-like) signal.  Thus, it is most similar to the AC unit in the textbook version.  Specifically, its minus phase activation is V(t) -- the expectation of reward computed by the rew pred layer ''on the previous trial'', and its plus phase activation is the expectation of reward ''on the next trial'' plus any actual rewards being received at the present time.  Thus, its plus phase state is the sum of the ExtRew and TDRewPred values, and this sum is directly clamped as a Gaussian activation state on the layer.
* '''TD''' -- this unit computes the plus - minus values from the rew integ layer, which reflects the TD delta value and is thought to act like the dopamine signal in the brain.

== The Network ==

Let's start by examining the network (which differs from figure 6.22 in the text). The input layer (located at the top, to capture the relative anatomical locations of this cortical area relative to the midbrain dopamine system represented by the TD layers below it) contains three rows of 20 units each.  This is the CSC, where the rows each represent a different stimulus (A, B, C), and the columns represent points in time: each unit has a stimulus and a time label (e.g., A_10 = time step 10 of the A stimulus).  The TD layers are as described above.

* Click on <code>r.wt</code> in the [[.PanelTab.RlCondNet]] netview control panel tab and then on the TDRewPred units -- you will see that they all start with a uniform weight of .1.  Then, click back to viewing <code>act</code>. 

== The Basic TD Learning Mechanism ==

Let's see how the CSC works in action.  

* Do <code>Step Trial</code> in the [[.PanelTab.ControlPanel]].

Nothing should happen in the Input layer, because no stimulus is present at time step 0.  The various TD layers will exhibit their Gaussian bumps of activation representing 0 values, and the TD layer itself has a zero activation.  Thus, no reward was either expected or obtained, and there is no deviation from expectation.  Note the <code>trial_name:</code> field shown below the network -- it indicates the time step (e.g., t=0).

* Continue to Step until you see an activation in the Input layer (should be 10 more steps).

This input activation represents the fact that the conditioned stimulus (CS) A (i.e., the \"tone\" stimulus) came on at t=10.  There should be no effect of this on the TD layers, because they have not associated this CS with reward yet.

* Continue to Step some more.

You will see that this stimulus remains active for 6 more time steps (through t=15), and at the end of this time period, the ExtRew layer represents a value of 1 instead of 0, indicating that an external reward was delivered to the network.  Because the TDRewPred layer has not learned to expect this reward, the TD delta value is positive, as reflected by the activity of the TD unit, and as plotted on the graph above the network, which shows a spike at this time step 15.  This TD spike is also associated with learning in the TDRewPred layer, as we'll see the next time we go through this sequence of trials.

* Continue to Step through the end of this sequence of inputs, and through the next set (epoch) until time step 14.

You should see that the TDRewPred layer now gets activated at time step 14, signaling a prediction of reward that will come on the next time step.  This expectation of reward, even in the absence of a delivered reward on the ExtRew layer (which still shows a 0 value representation), is sufficient to drive the TD \"dopamine spike\" as shown on the graph. 

* Step one more time (t=15).

Now the situation is reversed: the ExtRew layer shows that the reward has been presented, but the TD value is 0.  This is because the TDRewPred layer accurately predicted this reward on the prior time step, and thus the reward prediction error, which TD signals, is zero!  In terms of the overall graph display, you can see that the \"dopamine spike\" of TD delta has moved forward one step in time.  This is the critical feature of the TD algorithm: by learning to anticipate rewards one time step later, it ends up moving the dopamine spike earlier in time.

* Now Run the model and see what happens with more training.

You should see that the spike moves \"forward\" in time with each training step, but can't move any further than the onset of the CS at time step 10.  This is the same process that was shown in figure 6.20.

We can also examine the weights to see what the network has learned.

* Click on r.wt and then on the TDRewPred layer units -- you should see that right around the 1.0 value (units labeled 0.9 and 1.1) there are increased weights from the A stimulus for time steps 10-14.

== Extinction and Second Order Conditioning ==

At this point, there are many standard phenomena in classical conditioning that can be explored with this model.  We will look at two: ''extinction'' and ''second order conditioning''.  Extinction occurs when the stimulus is no longer predictive of reward -- it then loses its ability to predict this reward (which is appropriate).  Second order conditioning, as we discussed earlier, is where a conditioned stimulus can serve as the unconditioned stimulus for another stimulus -- in other words, one can extend the prediction of reward backward across two separate stimuli.

We can simulate extinction by simply turning off the reward that appears at t=15.  To do this, we need to alter the parameters on the control panel that determine the nature of the stimulus input and reward.  The first parameter is the <code>env_type</code>, which determines which stimuli are being presented (CS A, CS B, and US).  Currently, we are presenting the CSA and US.  To turn off the US, select CSA_NO.  For this to take effect, you need to hit the <code>Gen Inputs</code> button at the bottom of the control panel, which uses the parameters to generate an environment.  The other parameters shown determine when the stimuli are presented, if they are selected by the env_type parameter.  We can leave these in their current state.

* Now, hit <code>Reset Trial Data</code> to clear out the trial-level data plotted in the graph view, and then Step through the sequence of inputs.

<hr>

'''Question 6.5 (a)''' <em>What happened at the point where the reward was supposed to occur?  '''(b)''' Explain why this happened using the TD equations. '''(c)''' Then, Run the network and describe what occurs next in terms of the TD error signals plotted in the graph view, and explain why TD does this.  '''(c)''' After the network is done learning again, does the stimulus still evoke an expectation of reward?</em>

<hr>

If you look at the weights into the TDRewPred layer, you'll notice something interesting.  The weights into the units around a value of 1 have not decreased very much, but the weights into the units around the 0 value have increased.  Thus, this model shows that extinction learning may be more about learning new counteracting associations, instead of unlearning the previous associations.  There is now considerable evidence for this in the brain, with some very important implications.  For example, the original associations are always \"latent\" in the system, so they can be reactivated more quickly later on.

Now, let's explore second order conditioning.  We must first retrain the network on the stimulus 1 association.  

* Select CSA_US for the env_type, do Gen Inputs, then do Init, answer Yes to Initializing the network weights, and then do Run to setup the initial association as last time.

Now, we will turn on the CS B stimulus, which starts at t=2 and lasts until time step 10.

* Select  CSA_CSB_US as the env_type (if the full text is not shown, it is the first one listed), then do Gen Inputs, and go back to viewing act if you aren't already.  Hit Reset Trial Data to clear the graph view.  Then, Step through the trial (you might need to go through twice to get a full trial, depending on where it stopped last time).

Essentially, the first stimulus ''acts just like a reward'' by triggering a positive delta value, and thus allows the second stimulus to learn to predict this first stimulus.  

* Push Run, and then Stop when the graph view stops changing.

You will see that the early anticipation of reward gets carried out to the onset of the CS B stimulus (which comes first in time).

Finally, we can present some of the limitations of the CSC representation.  One obvious problem is capacity -- each stimulus requires a different set of units for all possible time intervals that can be represented.  Also, the CSC begs the question of how time is initialized to zero at the right point so every trial is properly synchronized.  Finally, the CSC requires that the stimulus stay on (or some trace of it) up to the point of reward, which is unrealistic.  This last problem points to an important issue with the TD algorithm, which is that although it can learn to bridge temporal gaps, it requires some suitable representation to support this bridging. We will see in chapters 9 and 11 that this and the other problems can be resolved by allowing the TD system to control the updating of context-like representations associated with the prefrontal cortex.

== Advanced Explorations ==

More advanced explorations can be performed by manipulating the extra input patterns in the GenCondInputs program found under .programs in the left browser panel.  Here you can manipulate the probabilities of stimuli being presented, and introduce randomness in the timings.  Generally speaking, these manipulations tend to highlight the limitations of the CSC input represenation, and of TD more generally.  See [[http://grey.colorado.edu/emergent/index.php/Leabra_PVLV]] for information about an alternative, biologically-based approach, which is also supported by this simulation software.


</body>
</html>
";
   html_text="<html><head></head><body>
<h1> Reinforcement Learning and Classical Conditioning </h1>
<p>
</p><ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
 <i>This replaces section 6.7.3 in the Computational Explorations.. textbook</i> 
<p>
To explore the TD learning rule (using a new version of the phase-based implementation described in the textbook in Chapter 6 -- see next section for details), we use the simple classical conditioning task discussed in the textbook section XXX.  Thus, the network will learn that a stimulus (tone) reliably predicts the reward (and then that another stimulus reliably predicts that tone).  First, we need to justify the use of the TD algorithm in this context, and motivate the nature of the stimulus representations used in the network.
</p><p>
You might recall that we said that the delta rule (aka the Rescorla-Wagner rule) provides a good model of classical conditioning, and thus wonder why TD is needed.  It all has to do with the issue of  <i>timing</i> .  If one ignores the timing of the stimulus relative to the response, then in fact the TD rule becomes equivalent to the delta rule when everything happens at one time step (it just trains V(t) to match r(t)).  However, animals are sensitive to the timing relationship, and, more importantly for our purposes, modeling this timing provides a particularly clear and simple demonstration of the basic properties of TD learning.
</p><p>
The only problem is that this simple demonstration involves a somewhat unrealistic representation of timing.  Basically, the stimulus representation has a distinct unit for each stimulus for each point in time, so that there is something unique for the TD system to learn from.  This representation is the  <b>complete serial compound</b>  (CSC) proposed by Sutton &amp; Barto (1990), and we will see exactly how it works when we look at the model.  As we have noted, we will explore a more plausible alternative in chapter 9 where the TD error signal controls the updating of a context representation that maintains the stimulus over time.
</p><p>
</p><h2> Important Differences From Textbook </h2>
<p>
This model employs a \"new and improved\" implementation of the TD (temporal differences) learning algorithm within the Leabra framework.  Instead of the single  <i>adaptive critic</i>  (AC) unit as described in the text, there are now 4 separate TD layers that each compute a part of the overall TD algorithm, as described below.  Separating out the computations like this fixes a limitation with the previous version, and is computationally necessary to do a fully accurate implementation of TD using phase-based activation states in Leabra.
</p><p>
Each of these layers, except the one labeled TD, uses a distributed  <i>Scalar Value</i>  representation to encode a scalar value in terms of a pattern of activity across the units.  Specifically, each unit has a preferred value for which it will fire maximally -- this value is shown above the unit in the network.  It will also fire less strongly for nearby values, in an overall Gaussian fashion.  The actual value represented across the whole layer is shown in the first unit in the layer strictly for display purposes (it does not participate in the distributed code, and is removed from sending net input to other layers because the act value is always 0 -- it is only visible when viewing the act_eq or act_m, act_p values) -- it is computed by taking the weighted average over the units in the layer of the unit's target value times its activation.
</p><p>
The actual TD computations are performed by the simulation code using these scalar values extracted from the associated layers, and are not directly computed by the network-level interactions among the layers themselves.  Although it is possible to get units to compute the necessary additions and subtractions required by the TD algorithm, it is much simpler and more robust to perform these calculations directly using the values represented by the layers.  The critical network-level computation is learning about the reward value of stimuli, and this is done using standard learning mechanisms in the TDRewPred layer.
</p><p>
Here is a description of what each layer does:
</p><ul><li>  <b>ExtRew</b>  -- just represents the external reward input -- it doesn't do any computation, but just provides a way to display in the network what the current reward value is.  It gets input from the input data table, representing the US (unconditioned stimulus).
</li><li>  <b>TDRewPred</b>  -- this is the key learning layer, which learns to predict the reward value on the next time step based on the current stimulus inputs: V(t+1).  This prediction is generated in the  <i>plus phase</i>  of leabra settling based on its current weights from the iput layer, whereas in the minus phase the layer's state is clamped to the prediction made on the previous trial: V(t).
</li><li>  <b>TDRewInteg</b>  -- this layer integrates the reward prediction and external reward layer values, and the difference in its plus-minus phase activation states are what drive the TD delta (dopamine-like) signal.  Thus, it is most similar to the AC unit in the textbook version.  Specifically, its minus phase activation is V(t) -- the expectation of reward computed by the rew pred layer  <i>on the previous trial</i> , and its plus phase activation is the expectation of reward  <i>on the next trial</i>  plus any actual rewards being received at the present time.  Thus, its plus phase state is the sum of the ExtRew and TDRewPred values, and this sum is directly clamped as a Gaussian activation state on the layer.
</li><li>  <b>TD</b>  -- this unit computes the plus - minus values from the rew integ layer, which reflects the TD delta value and is thought to act like the dopamine signal in the brain.
</li></ul>
<h2> The Network </h2>
<p>
Let's start by examining the network (which differs from figure 6.22 in the text). The input layer (located at the top, to capture the relative anatomical locations of this cortical area relative to the midbrain dopamine system represented by the TD layers below it) contains three rows of 20 units each.  This is the CSC, where the rows each represent a different stimulus (A, B, C), and the columns represent points in time: each unit has a stimulus and a time label (e.g., A_10 = time step 10 of the A stimulus).  The TD layers are as described above.
</p><p>
</p><ul><li> Click on <code>r.wt</code> in the <a href=\"ta:.PanelTab.RlCondNet\">RlCondNet</a> netview control panel tab and then on the TDRewPred units -- you will see that they all start with a uniform weight of .1.  Then, click back to viewing <code>act</code>. 
</li></ul>
<h2> The Basic TD Learning Mechanism </h2>
<p>
Let's see how the CSC works in action.  
</p><p>
</p><ul><li> Do <code>Step Trial</code> in the <a href=\"ta:.PanelTab.ControlPanel\">ControlPanel</a>.
</li></ul>
Nothing should happen in the Input layer, because no stimulus is present at time step 0.  The various TD layers will exhibit their Gaussian bumps of activation representing 0 values, and the TD layer itself has a zero activation.  Thus, no reward was either expected or obtained, and there is no deviation from expectation.  Note the <code>trial_name:</code> field shown below the network -- it indicates the time step (e.g., t=0).
<p>
</p><ul><li> Continue to Step until you see an activation in the Input layer (should be 10 more steps).
</li></ul>
This input activation represents the fact that the conditioned stimulus (CS) A (i.e., the \"tone\" stimulus) came on at t=10.  There should be no effect of this on the TD layers, because they have not associated this CS with reward yet.
<p>
</p><ul><li> Continue to Step some more.
</li></ul>
You will see that this stimulus remains active for 6 more time steps (through t=15), and at the end of this time period, the ExtRew layer represents a value of 1 instead of 0, indicating that an external reward was delivered to the network.  Because the TDRewPred layer has not learned to expect this reward, the TD delta value is positive, as reflected by the activity of the TD unit, and as plotted on the graph above the network, which shows a spike at this time step 15.  This TD spike is also associated with learning in the TDRewPred layer, as we'll see the next time we go through this sequence of trials.
<p>
</p><ul><li> Continue to Step through the end of this sequence of inputs, and through the next set (epoch) until time step 14.
</li></ul>
You should see that the TDRewPred layer now gets activated at time step 14, signaling a prediction of reward that will come on the next time step.  This expectation of reward, even in the absence of a delivered reward on the ExtRew layer (which still shows a 0 value representation), is sufficient to drive the TD \"dopamine spike\" as shown on the graph. 
<p>
</p><ul><li> Step one more time (t=15).
</li></ul>
Now the situation is reversed: the ExtRew layer shows that the reward has been presented, but the TD value is 0.  This is because the TDRewPred layer accurately predicted this reward on the prior time step, and thus the reward prediction error, which TD signals, is zero!  In terms of the overall graph display, you can see that the \"dopamine spike\" of TD delta has moved forward one step in time.  This is the critical feature of the TD algorithm: by learning to anticipate rewards one time step later, it ends up moving the dopamine spike earlier in time.
<p>
</p><ul><li> Now Run the model and see what happens with more training.
</li></ul>
You should see that the spike moves \"forward\" in time with each training step, but can't move any further than the onset of the CS at time step 10.  This is the same process that was shown in figure 6.20.
<p>
We can also examine the weights to see what the network has learned.
</p><p>
</p><ul><li> Click on r.wt and then on the TDRewPred layer units -- you should see that right around the 1.0 value (units labeled 0.9 and 1.1) there are increased weights from the A stimulus for time steps 10-14.
</li></ul>
<h2> Extinction and Second Order Conditioning </h2>
<p>
At this point, there are many standard phenomena in classical conditioning that can be explored with this model.  We will look at two:  <i>extinction</i>  and  <i>second order conditioning</i> .  Extinction occurs when the stimulus is no longer predictive of reward -- it then loses its ability to predict this reward (which is appropriate).  Second order conditioning, as we discussed earlier, is where a conditioned stimulus can serve as the unconditioned stimulus for another stimulus -- in other words, one can extend the prediction of reward backward across two separate stimuli.
</p><p>
We can simulate extinction by simply turning off the reward that appears at t=15.  To do this, we need to alter the parameters on the control panel that determine the nature of the stimulus input and reward.  The first parameter is the <code>env_type</code>, which determines which stimuli are being presented (CS A, CS B, and US).  Currently, we are presenting the CSA and US.  To turn off the US, select CSA_NO.  For this to take effect, you need to hit the <code>Gen Inputs</code> button at the bottom of the control panel, which uses the parameters to generate an environment.  The other parameters shown determine when the stimuli are presented, if they are selected by the env_type parameter.  We can leave these in their current state.
</p><p>
</p><ul><li> Now, hit <code>Reset Trial Data</code> to clear out the trial-level data plotted in the graph view, and then Step through the sequence of inputs.
</li></ul>
<hr>
<p>
 <b>Question 6.5 (a)</b>  <em>What happened at the point where the reward was supposed to occur?   <b>(b)</b>  Explain why this happened using the TD equations.  <b>(c)</b>  Then, Run the network and describe what occurs next in terms of the TD error signals plotted in the graph view, and explain why TD does this.   <b>(c)</b>  After the network is done learning again, does the stimulus still evoke an expectation of reward?</em>
</p><p>
</p><hr>
<p>
If you look at the weights into the TDRewPred layer, you'll notice something interesting.  The weights into the units around a value of 1 have not decreased very much, but the weights into the units around the 0 value have increased.  Thus, this model shows that extinction learning may be more about learning new counteracting associations, instead of unlearning the previous associations.  There is now considerable evidence for this in the brain, with some very important implications.  For example, the original associations are always \"latent\" in the system, so they can be reactivated more quickly later on.
</p><p>
Now, let's explore second order conditioning.  We must first retrain the network on the stimulus 1 association.  
</p><p>
</p><ul><li> Select CSA_US for the env_type, do Gen Inputs, then do Init, answer Yes to Initializing the network weights, and then do Run to setup the initial association as last time.
</li></ul>
Now, we will turn on the CS B stimulus, which starts at t=2 and lasts until time step 10.
<p>
</p><ul><li> Select  CSA_CSB_US as the env_type (if the full text is not shown, it is the first one listed), then do Gen Inputs, and go back to viewing act if you aren't already.  Hit Reset Trial Data to clear the graph view.  Then, Step through the trial (you might need to go through twice to get a full trial, depending on where it stopped last time).
</li></ul>
Essentially, the first stimulus  <i>acts just like a reward</i>  by triggering a positive delta value, and thus allows the second stimulus to learn to predict this first stimulus.  
<p>
</p><ul><li> Push Run, and then Stop when the graph view stops changing.
</li></ul>
You will see that the early anticipation of reward gets carried out to the onset of the CS B stimulus (which comes first in time).
<p>
Finally, we can present some of the limitations of the CSC representation.  One obvious problem is capacity -- each stimulus requires a different set of units for all possible time intervals that can be represented.  Also, the CSC begs the question of how time is initialized to zero at the right point so every trial is properly synchronized.  Finally, the CSC requires that the stimulus stay on (or some trace of it) up to the point of reward, which is unrealistic.  This last problem points to an important issue with the TD algorithm, which is that although it can learn to bridge temporal gaps, it requires some suitable representation to support this bridging. We will see in chapters 9 and 11 that this and the other problems can be resolved by allowing the TD system to control the updating of context-like representations associated with the prefrontal cortex.
</p><p>
</p><h2> Advanced Explorations </h2>
<p>
More advanced explorations can be performed by manipulating the extra input patterns in the GenCondInputs program found under .programs in the left browser panel.  Here you can manipulate the probabilities of stimuli being presented, and introduce randomness in the timings.  Generally speaking, these manipulations tend to highlight the limitations of the CSC input represenation, and of TD more generally.  See <a href=\"http://grey.colorado.edu/emergent/index.php/Leabra_PVLV\">http://grey.colorado.edu/emergent/index.php/Leabra_PVLV</a> for information about an alternative, biologically-based approach, which is also supported by this simulation software.
</p><p>
</p><p>


</p></body></html>";
  };
  taDoc @[1] {
   name="WikiDoc";
   desc=;
   auto_open=0;
   web_doc=1;
   wiki="CCN";
   url="CECN1_Reinforcement_Learning";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Reinforcement_Learning";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" dir=\"ltr\"><head>
		<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">
		<meta http-equiv=\"Content-Style-Type\" content=\"text/css\">
		<meta name=\"generator\" content=\"MediaWiki 1.16alpha-wmf\">
		<meta name=\"keywords\" content=\"CECN1 Reinforcement Learning,CECN1 Projects,Emergent,.PanelTab.RlCondNet,.programs.LeabraTrain.Step()\">
		<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
		<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
		<link rel=\"alternate\" type=\"application/rss+xml\" title=\"Computational Cognitive Neuroscience Wiki RSS Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=rss\">
		<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom Feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
		<title>CECN1 Reinforcement Learning - Computational Cognitive Neuroscience Wiki</title>
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/shared.css?233z\" type=\"text/css\" media=\"screen\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/common/commonPrint.css?233z\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/main.css?233z\" type=\"text/css\" media=\"screen\">
		<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE50Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE55Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE60Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/monobook/IE70Fixes.css?233z\" type=\"text/css\" media=\"screen\" /><![endif]-->
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\" media=\"print\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=MediaWiki:monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=18000&amp;action=raw&amp;maxage=18000\" type=\"text/css\">
		<link rel=\"stylesheet\" href=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;maxage=18000&amp;gen=css\" type=\"text/css\">
		<!--[if lt IE 7]><script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/IEFixes.js?233z\"></script>
		<meta http-equiv=\"imagetoolbar\" content=\"no\" /><![endif]-->

		<script type=\"text/javascript\">/*<![CDATA[*/
		var skin = \"monobook\";
		var stylepath = \"/CompCogNeuro/skins\";
		var wgArticlePath = \"/CompCogNeuro/index.php/$1\";
		var wgScriptPath = \"/CompCogNeuro\";
		var wgScript = \"/CompCogNeuro/index.php\";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = \"http://grey.colorado.edu\";
		var wgCanonicalNamespace = \"\";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = \"CECN1_Reinforcement_Learning\";
		var wgTitle = \"CECN1 Reinforcement Learning\";
		var wgAction = \"view\";
		var wgArticleId = \"87\";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = \"en\";
		var wgContentLanguage = \"en\";
		var wgBreakFrames = false;
		var wgCurRevisionId = 408;
		var wgVersion = \"1.16alpha-wmf\";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = [\"\", \"\"];
		var wgDigitTransformTable = [\"\", \"\"];
		var wgMainPageTitle = \"Main Page\";
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		var wgFCKEditorDir = \"extensions/FCKeditor/fckeditor/\";
		var wgFCKEditorExtDir = \"extensions/FCKeditor\";
		var wgFCKEditorToolbarSet = \"Wiki\";
		var wgFCKEditorHeight = \"0\";
		/*]]>*/</script>

		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/wikibits.js?233z\"><!-- wikibits js --></script><style type=\"text/css\">@import \"/CompCogNeuro/skins/monobook/KHTMLFixes.css\";</style>
		<!-- Head Scripts -->
		<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/common/ajax.js?233z\"></script>
		<script type=\"text/javascript\" src=\"/CompCogNeuro/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook\"><!-- site js --></script>
	<style type=\"text/css\">@import \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";</style></head><body class=\"mediawiki ltr ns-0 ns-subject page-CECN1_Reinforcement_Learning skin-monobook\">
	<div id=\"globalWrapper\">
		<div id=\"column-content\">
	<div id=\"content\">
		<a name=\"top\" id=\"top\"></a>
				<h1 id=\"firstHeading\" class=\"firstHeading\">CECN1 Reinforcement Learning</h1>
		<div id=\"bodyContent\">
			<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
			<div id=\"contentSub\"></div>
									<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>			<!-- start content -->
			<table id=\"toc\" class=\"toc\" summary=\"Contents\"><tbody><tr><td><div id=\"toctitle\"><h2>Contents</h2> <span class=\"toctoggle\">[<a id=\"togglelink\" class=\"internal\" href=\"javascript:toggleToc()\">hide</a>]</span></div>
<ul>
<li class=\"toclevel-1\"><a href=\"#Reinforcement_Learning_and_Classical_Conditioning\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">Reinforcement Learning and Classical Conditioning</span></a></li>
<li class=\"toclevel-1\"><a href=\"#Project_Documentation\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Project Documentation</span></a>
<ul>
<li class=\"toclevel-2\"><a href=\"#Important_Differences_From_Textbook\"><span class=\"tocnumber\">2.1</span> <span class=\"toctext\">Important Differences From Textbook</span></a></li>
<li class=\"toclevel-2\"><a href=\"#The_Network\"><span class=\"tocnumber\">2.2</span> <span class=\"toctext\">The Network</span></a></li>
<li class=\"toclevel-2\"><a href=\"#The_Basic_TD_Learning_Mechanism\"><span class=\"tocnumber\">2.3</span> <span class=\"toctext\">The Basic TD Learning Mechanism</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Extinction_and_Second_Order_Conditioning\"><span class=\"tocnumber\">2.4</span> <span class=\"toctext\">Extinction and Second Order Conditioning</span></a></li>
<li class=\"toclevel-2\"><a href=\"#Advanced_Explorations\"><span class=\"tocnumber\">2.5</span> <span class=\"toctext\">Advanced Explorations</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table><script type=\"text/javascript\"> if (window.showTocToggle) { var tocShowText = \"show\"; var tocHideText = \"hide\"; showTocToggle(); } </script>
<a name=\"Reinforcement_Learning_and_Classical_Conditioning\" id=\"Reinforcement_Learning_and_Classical_Conditioning\"></a><h1> <span class=\"mw-headline\"> Reinforcement Learning and Classical Conditioning </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/0/0f/rl_cond.proj\" class=\"internal\" title=\"rl cond.proj\">rl_cond.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CECN1_Projects\" title=\"CECN1 Projects\">CECN1 Projects</a>
</p>
<a name=\"Project_Documentation\" id=\"Project_Documentation\"></a><h1> <span class=\"mw-headline\"> Project Documentation </span></h1>
<p>(note: this is a literal copy from the simulation documentation -- it contains links that will not work within the wiki)
</p>
<ul><li> To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  Alternatively, you can always return by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.
</li></ul>
<p><i>This replaces section 6.7.3 in the Computational Explorations.. textbook</i>
</p><p>To explore the TD learning rule (using a new version of the phase-based implementation described in the textbook in Chapter 6 -- see next section for details), we use the simple classical conditioning task discussed in the textbook section XXX.  Thus, the network will learn that a stimulus (tone) reliably predicts the reward (and then that another stimulus reliably predicts that tone).  First, we need to justify the use of the TD algorithm in this context, and motivate the nature of the stimulus representations used in the network.
</p><p>You might recall that we said that the delta rule (aka the Rescorla-Wagner rule) provides a good model of classical conditioning, and thus wonder why TD is needed.  It all has to do with the issue of <i>timing</i>.  If one ignores the timing of the stimulus relative to the response, then in fact the TD rule becomes equivalent to the delta rule when everything happens at one time step (it just trains V(t) to match r(t)).  However, animals are sensitive to the timing relationship, and, more importantly for our purposes, modeling this timing provides a particularly clear and simple demonstration of the basic properties of TD learning.
</p><p>The only problem is that this simple demonstration involves a somewhat unrealistic representation of timing.  Basically, the stimulus representation has a distinct unit for each stimulus for each point in time, so that there is something unique for the TD system to learn from.  This representation is the <b>complete serial compound</b> (CSC) proposed by Sutton &amp; Barto (1990), and we will see exactly how it works when we look at the model.  As we have noted, we will explore a more plausible alternative in chapter 9 where the TD error signal controls the updating of a context representation that maintains the stimulus over time.
</p>
<a name=\"Important_Differences_From_Textbook\" id=\"Important_Differences_From_Textbook\"></a><h2> <span class=\"mw-headline\"> Important Differences From Textbook </span></h2>
<p>This model employs a \"new and improved\" implementation of the TD (temporal differences) learning algorithm within the Leabra framework.  Instead of the single <i>adaptive critic</i> (AC) unit as described in the text, there are now 4 separate TD layers that each compute a part of the overall TD algorithm, as described below.  Separating out the computations like this fixes a limitation with the previous version, and is computationally necessary to do a fully accurate implementation of TD using phase-based activation states in Leabra.
</p><p>Each of these layers, except the one labeled TD, uses a distributed <i>Scalar Value</i> representation to encode a scalar value in terms of a pattern of activity across the units.  Specifically, each unit has a preferred value for which it will fire maximally -- this value is shown above the unit in the network.  It will also fire less strongly for nearby values, in an overall Gaussian fashion.  The actual value represented across the whole layer is shown in the first unit in the layer strictly for display purposes (it does not participate in the distributed code, and is removed from sending net input to other layers because the act value is always 0 -- it is only visible when viewing the act_eq or act_m, act_p values) -- it is computed by taking the weighted average over the units in the layer of the unit's target value times its activation.
</p><p>The actual TD computations are performed by the simulation code using these scalar values extracted from the associated layers, and are not directly computed by the network-level interactions among the layers themselves.  Although it is possible to get units to compute the necessary additions and subtractions required by the TD algorithm, it is much simpler and more robust to perform these calculations directly using the values represented by the layers.  The critical network-level computation is learning about the reward value of stimuli, and this is done using standard learning mechanisms in the TDRewPred layer.
</p><p>Here is a description of what each layer does:
</p>
<ul><li> <b>ExtRew</b> -- just represents the external reward input -- it doesn't do any computation, but just provides a way to display in the network what the current reward value is.  It gets input from the input data table, representing the US (unconditioned stimulus).
</li><li> <b>TDRewPred</b> -- this is the key learning layer, which learns to predict the reward value on the next time step based on the current stimulus inputs: V(t+1).  This prediction is generated in the <i>plus phase</i> of leabra settling based on its current weights from the iput layer, whereas in the minus phase the layer's state is clamped to the prediction made on the previous trial: V(t).
</li><li> <b>TDRewInteg</b> -- this layer integrates the reward prediction and external reward layer values, and the difference in its plus-minus phase activation states are what drive the TD delta (dopamine-like) signal.  Thus, it is most similar to the AC unit in the textbook version.  Specifically, its minus phase activation is V(t) -- the expectation of reward computed by the rew pred layer <i>on the previous trial</i>, and its plus phase activation is the expectation of reward <i>on the next trial</i> plus any actual rewards being received at the present time.  Thus, its plus phase state is the sum of the ExtRew and TDRewPred values, and this sum is directly clamped as a Gaussian activation state on the layer.
</li><li> <b>TD</b> -- this unit computes the plus - minus values from the rew integ layer, which reflects the TD delta value and is thought to act like the dopamine signal in the brain.
</li></ul>
<a name=\"The_Network\" id=\"The_Network\"></a><h2> <span class=\"mw-headline\"> The Network </span></h2>
<p>Let's start by examining the network (which differs from figure 6.22 in the text). The input layer (located at the top, to capture the relative anatomical locations of this cortical area relative to the midbrain dopamine system represented by the TD layers below it) contains three rows of 20 units each.  This is the CSC, where the rows each represent a different stimulus (A, B, C), and the columns represent points in time: each unit has a stimulus and a time label (e.g., A_10 = time step 10 of the A stimulus).  The TD layers are as described above.
</p>
<ul><li> Click on <code>r.wt</code> in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.RlCondNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.RlCondNet (page does not exist)\">.PanelTab.RlCondNet</a> netview control panel tab and then on the TDRewPred units -- you will see that they all start with a uniform weight of .1.  Then, click back to viewing <code>act</code>. 
</li></ul>
<a name=\"The_Basic_TD_Learning_Mechanism\" id=\"The_Basic_TD_Learning_Mechanism\"></a><h2> <span class=\"mw-headline\"> The Basic TD Learning Mechanism </span></h2>
<p>Let's see how the CSC works in action.  
</p>
<ul><li> Do <a href=\"/CompCogNeuro/index.php?title=.programs.LeabraTrain.Step()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".programs.LeabraTrain.Step() (page does not exist)\">Step</a> on the control panel.
</li></ul>
<p>Nothing should happen in the Input layer, because no stimulus is present at time step 0.  The various TD layers will exhibit their Gaussian bumps of activation representing 0 values, and the TD layer itself has a zero activation.  Thus, no reward was either expected or obtained, and there is no deviation from expectation.  Note the <code>trial_name:</code> field shown below the network -- it indicates the time step (e.g., t=0).
</p>
<ul><li> Continue to Step until you see an activation in the Input layer (should be 10 more steps).
</li></ul>
<p>This input activation represents the fact that the conditioned stimulus (CS) A (i.e., the \"tone\" stimulus) came on at t=10.  There should be no effect of this on the TD layers, because they have not associated this CS with reward yet.
</p>
<ul><li> Continue to Step some more.
</li></ul>
<p>You will see that this stimulus remains active for 6 more time steps (through t=15), and at the end of this time period, the ExtRew layer represents a value of 1 instead of 0, indicating that an external reward was delivered to the network.  Because the TDRewPred layer has not learned to expect this reward, the TD delta value is positive, as reflected by the activity of the TD unit, and as plotted on the graph above the network, which shows a spike at this time step 15.  This TD spike is also associated with learning in the TDRewPred layer, as we'll see the next time we go through this sequence of trials.
</p>
<ul><li> Continue to Step through the end of this sequence of inputs, and through the next set (epoch) until time step 14.
</li></ul>
<p>You should see that the TDRewPred layer now gets activated at time step 14, signaling a prediction of reward that will come on the next time step.  This expectation of reward, even in the absence of a delivered reward on the ExtRew layer (which still shows a 0 value representation), is sufficient to drive the TD \"dopamine spike\" as shown on the graph. 
</p>
<ul><li> Step one more time (t=15).
</li></ul>
<p>Now the situation is reversed: the ExtRew layer shows that the reward has been presented, but the TD value is 0.  This is because the TDRewPred layer accurately predicted this reward on the prior time step, and thus the reward prediction error, which TD signals, is zero!  In terms of the overall graph display, you can see that the \"dopamine spike\" of TD delta has moved forward one step in time.  This is the critical feature of the TD algorithm: by learning to anticipate rewards one time step later, it ends up moving the dopamine spike earlier in time.
</p>
<ul><li> Now Run the model and see what happens with more training.
</li></ul>
<p>You should see that the spike moves \"forward\" in time with each training step, but can't move any further than the onset of the CS at time step 10.  This is the same process that was shown in figure 6.20.
</p><p>We can also examine the weights to see what the network has learned.
</p>
<ul><li> Click on r.wt and then on the TDRewPred layer units -- you should see that right around the 1.0 value (units labeled 0.9 and 1.1) there are increased weights from the A stimulus for time steps 10-14.
</li></ul>
<a name=\"Extinction_and_Second_Order_Conditioning\" id=\"Extinction_and_Second_Order_Conditioning\"></a><h2> <span class=\"mw-headline\"> Extinction and Second Order Conditioning </span></h2>
<p>At this point, there are many standard phenomena in classical conditioning that can be explored with this model.  We will look at two: <i>extinction</i> and <i>second order conditioning</i>.  Extinction occurs when the stimulus is no longer predictive of reward -- it then loses its ability to predict this reward (which is appropriate).  Second order conditioning, as we discussed earlier, is where a conditioned stimulus can serve as the unconditioned stimulus for another stimulus -- in other words, one can extend the prediction of reward backward across two separate stimuli.
</p><p>We can simulate extinction by simply turning off the reward that appears at t=15.  To do this, we need to alter the parameters on the control panel that determine the nature of the stimulus input and reward.  The first parameter is the <code>env_type</code>, which determines which stimuli are being presented (CS A, CS B, and US).  Currently, we are presenting the CSA and US.  To turn off the US, select CSA_NO.  For this to take effect, you need to hit the <code>Gen Inputs</code> button at the bottom of the control panel, which uses the parameters to generate an environment.  The other parameters shown determine when the stimuli are presented, if they are selected by the env_type parameter.  We can leave these in their current state.
</p>
<ul><li> Now, hit <code>Reset Trial Data</code> to clear out the trial-level data plotted in the graph view, and then Step through the sequence of inputs.
</li></ul>
<hr>
<p><b>Question 6.5 (a)</b> <em>What happened at the point where the reward was supposed to occur?  <b>(b)</b> Explain why this happened using the TD equations. <b>(c)</b> Then, Run the network and describe what occurs next in terms of the TD error signals plotted in the graph view, and explain why TD does this.  <b>(c)</b> After the network is done learning again, does the stimulus still evoke an expectation of reward?</em>
</p>
<hr>
<p>If you look at the weights into the TDRewPred layer, you'll notice something interesting.  The weights into the units around a value of 1 have not decreased very much, but the weights into the units around the 0 value have increased.  Thus, this model shows that extinction learning may be more about learning new counteracting associations, instead of unlearning the previous associations.  There is now considerable evidence for this in the brain, with some very important implications.  For example, the original associations are always \"latent\" in the system, so they can be reactivated more quickly later on.
</p><p>Now, let's explore second order conditioning.  We must first retrain the network on the stimulus 1 association.  
</p>
<ul><li> Select CSA_US for the env_type, do Gen Inputs, then do Init, answer Yes to Initializing the network weights, and then do Run to setup the initial association as last time.
</li></ul>
<p>Now, we will turn on the CS B stimulus, which starts at t=2 and lasts until time step 10.
</p>
<ul><li> Select  CSA_CSB_US as the env_type (if the full text is not shown, it is the first one listed), then do Gen Inputs, and go back to viewing act if you aren't already.  Hit Reset Trial Data to clear the graph view.  Then, Step through the trial (you might need to go through twice to get a full trial, depending on where it stopped last time).
</li></ul>
<p>Essentially, the first stimulus <i>acts just like a reward</i> by triggering a positive delta value, and thus allows the second stimulus to learn to predict this first stimulus.  
</p>
<ul><li> Push Run, and then Stop when the graph view stops changing.
</li></ul>
<p>You will see that the early anticipation of reward gets carried out to the onset of the CS B stimulus (which comes first in time).
</p><p>Finally, we can present some of the limitations of the CSC representation.  One obvious problem is capacity -- each stimulus requires a different set of units for all possible time intervals that can be represented.  Also, the CSC begs the question of how time is initialized to zero at the right point so every trial is properly synchronized.  Finally, the CSC requires that the stimulus stay on (or some trace of it) up to the point of reward, which is unrealistic.  This last problem points to an important issue with the TD algorithm, which is that although it can learn to bridge temporal gaps, it requires some suitable representation to support this bridging. We will see in chapters 9 and 11 that this and the other problems can be resolved by allowing the TD system to control the updating of context-like representations associated with the prefrontal cortex.
</p>
<a name=\"Advanced_Explorations\" id=\"Advanced_Explorations\"></a><h2> <span class=\"mw-headline\"> Advanced Explorations </span></h2>
<p>More advanced explorations can be performed by manipulating the extra input patterns in the GenCondInputs program found under .programs in the left browser panel.  Here you can manipulate the probabilities of stimuli being presented, and introduce randomness in the timings.  Generally speaking, these manipulations tend to highlight the limitations of the CSC input represenation, and of TD more generally.  See <a href=\"http://grey.colorado.edu/emergent/index.php/Leabra_PVLV\" class=\"external free\" title=\"http://grey.colorado.edu/emergent/index.php/Leabra_PVLV\" rel=\"nofollow\">http://grey.colorado.edu/emergent/index.php/Leabra_PVLV</a> for information about an alternative, biologically-based approach, which is also supported by this simulation software.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 8/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:87-0!1!0!!en!2!edit=0 and timestamp 20090904083303 -->
<div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Reinforcement_Learning\">http://grey.colorado.edu/CompCogNeuro/index.php/CECN1_Reinforcement_Learning</a>\"</div>
						<!-- end content -->
						<div class=\"visualClear\"></div>
		</div>
	</div>
		</div>
		<div id=\"column-one\">
	<div id=\"p-cactions\" class=\"portlet\">
		<h5>Views</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
	
				 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CECN1_Reinforcement_Learning\" title=\"View the content page [ctrl-alt-c]\" accesskey=\"c\">Page</a></li>
				 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CECN1_Reinforcement_Learning&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [ctrl-alt-t]\" accesskey=\"t\">Discussion</a></li>
				 <li id=\"ca-viewsource\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Reinforcement_Learning&amp;action=edit\" title=\"This page is protected.
You can view its source [ctrl-alt-e]\" accesskey=\"e\">View source</a></li>
				 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Reinforcement_Learning&amp;action=history\" title=\"Past revisions of this page [ctrl-alt-h]\" accesskey=\"h\">History</a></li>			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-personal\">
		<h5>Personal tools</h5>
		<div class=\"pBody\">
			<ul lang=\"en\" xml:lang=\"en\">
				<li id=\"pt-login\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogin&amp;returnto=CECN1_Reinforcement_Learning\" title=\"You are encouraged to log in; however, it is not mandatory [ctrl-alt-o]\" accesskey=\"o\">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\" title=\"Visit the main page [ctrl-alt-z]\" accesskey=\"z\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
	<div class=\"generated-sidebar portlet\" id=\"p-navigation\">
		<h5 lang=\"en\" xml:lang=\"en\">Navigation</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main Page</a></li>
				<li id=\"n-portal\"><a href=\"/CompCogNeuro/index.php/Project:Community_Portal\" title=\"About the project, what you can do, where to find things\">Community portal</a></li>
				<li id=\"n-currentevents\"><a href=\"/CompCogNeuro/index.php/Project:Current_events\" title=\"Find background information on current events\">Current events</a></li>
				<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\" title=\"The list of recent changes in the wiki [ctrl-alt-r]\" accesskey=\"r\">Recent changes</a></li>
				<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\" title=\"Load a random page [ctrl-alt-x]\" accesskey=\"x\">Random page</a></li>
				<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\" title=\"The place to find out\">Help</a></li>
			</ul>
		</div>
	</div>
	<div id=\"p-search\" class=\"portlet\">
		<h5 lang=\"en\" xml:lang=\"en\"><label for=\"searchInput\">Search</label></h5>
		<div id=\"searchBody\" class=\"pBody\">
			<form action=\"/CompCogNeuro/index.php\" id=\"searchform\"><div>
				<input type=\"hidden\" name=\"title\" value=\"Special:Search\">
				<input id=\"searchInput\" name=\"search\" type=\"text\" title=\"Search Computational Cognitive Neuroscience Wiki [ctrl-alt-f]\" accesskey=\"f\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\" title=\"Go to a page with this exact name if exists\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\" title=\"Search the pages for this text\">
			</div></form>
		</div>
	</div>
	<div class=\"portlet\" id=\"p-tb\">
		<h5 lang=\"en\" xml:lang=\"en\">Toolbox</h5>
		<div class=\"pBody\">
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CECN1_Reinforcement_Learning\" title=\"List of all wiki pages that link here [ctrl-alt-j]\" accesskey=\"j\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CECN1_Reinforcement_Learning\" title=\"Recent changes in pages linked from this page [ctrl-alt-k]\" accesskey=\"k\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\" title=\"Upload files [ctrl-alt-u]\" accesskey=\"u\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\" title=\"List of all special pages [ctrl-alt-q]\" accesskey=\"q\">Special pages</a></li>
				<li id=\"t-print\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Reinforcement_Learning&amp;printable=yes\" rel=\"alternate\" title=\"Printable version of this page [ctrl-alt-p]\" accesskey=\"p\">Printable version</a></li>				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CECN1_Reinforcement_Learning&amp;oldid=408\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-download-as-pdf\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/render_article/&amp;arttitle=CECN1+Reinforcement+Learning&amp;oldid=408&amp;writer=rl\" rel=\"nofollow\">PDF version</a></li>			</ul>
		</div>
	</div>
	<div class=\"generated-sidebar portlet\" id=\"p-coll-create_a_book\">
		<h5 lang=\"en\" xml:lang=\"en\">Create a book</h5>
		<div class=\"pBody\">
<ul id=\"collectionPortletList\"><li id=\"coll-add_page\"><a href=\"/CompCogNeuro/index.php?title=Special:Book/add_article/&amp;arttitle=CECN1+Reinforcement+Learning&amp;oldid=0\" title=\"Add the current wiki page to your book\" onclick=\"collectionCall('AddArticle', ['removepage', wgNamespaceNumber, wgTitle, 0]); return false;\" rel=\"nofollow\">Add page to book</a></li><li id=\"coll-help_collections\"><a href=\"/CompCogNeuro/index.php/Help:Books\" title=\"Show help about the book tool\">Books help</a></li></ul><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionAddRemoveSate = \"addpage\";
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/portlet.js?2\"></script><script type=\"text/javascript\">/*<![CDATA[*/
		var wgCollectionNavPopupJSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\";
		var wgCollectionNavPopupCSSURL = \"/CompCogNeuro/extensions/Collection/collection/Gadget-navpop.css?2\";
		var wgCollectionAddPageText = \"Add linked wiki page to your book\";
		var wgCollectionAddCategoryText = \"Add wiki pages in linked category to your book\";
		var wgCollectionRemovePageText = \"Remove linked wiki page from your book\";
		var wgCollectionPopupHelpText = \"To deactivate this feature click \\\"Clear book\\\" in the \\\"Create a book\\\" box\";
		var wgCollectionArticleNamespaces = [0, 1, 2, 3, 4, 5, 8, 9, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111];
		/*]]>*/</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/json2.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popupcheck.js?2\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/popup.js\"></script><script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Collection/collection/Gadget-popups.js?2\"></script>		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class=\"visualClear\"></div>
			<div id=\"footer\">
				<div id=\"f-poweredbyico\"><a href=\"http://www.mediawiki.org/\"><img src=\"/CompCogNeuro/skins/common/images/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\"></a></div>
			<ul id=\"f-list\">
					<li id=\"lastmod\"> This page was last modified on 7 January 2009, at 09:15.</li>
					<li id=\"viewcount\">This page has been accessed 845 times.</li>
					<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
					<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
					<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type=\"text/javascript\">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served in 0.240 secs. -->
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_0";
   auto_open=0;
   n_layers=2;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
   default_net_type=LeabraNetwork;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @[0] {
   name="ControlPanel";
   auto_edit=1;
   desc="Overall Control Panel for the Reinforcement Learning Condtioning Project";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem_Group @.gp[0] {
     name="TD Parameters";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="lrate";
      desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[1][0].children[0]$$;
      mbr=LeabraConSpec::lrate;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="rew integ";
      desc=" misc specs for TDRewIntegLayerSpec<br>  discount:  discount factor for V(t+1) from TDRewPredLayer<br>  max r v:  represent the maximum of extrew (r) and tdrewpred estimate of V(t+1) instead of the sum of these two factors -- produces a kind of 'absorbing' reward function instead of a cumulative reward function";
      cust_desc=0;
      base=.projects[0].networks[0].specs.gp[2][2]$$;
      mbr=TDRewIntegLayerSpec::rew_integ;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="lambda";
      desc=" exponential decay parameter for updating activation trace values over time: these trace values are used in learning. in principle this should also include the effects of the discount (gamma) parameter from the TdRewInteg layer";
      cust_desc=0;
      base=.projects[0].networks[0].specs[0]$$;
      mbr=LeabraTdUnitSpec::lambda;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
    EditMbrItem_Group @.gp[1] {
     name="Conditioning Environment Parameters";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="env_type";
      desc="type of conditioning environment to generate, in terms of CS, US associations";
      cust_desc=1;
      base=.projects[0].programs[0].vars[0].dyn_enum_val$$;
      mbr=DynEnum::value;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[1] {
      label="csA_on";
      desc="time step (out of 20) when CS A comes on (if it is being presented according to env_type)";
      cust_desc=1;
      base=.projects[0].programs[0].vars[1]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[2] {
      label="csA_off";
      desc="time step (out of 20) when CS A goes off";
      cust_desc=1;
      base=.projects[0].programs[0].vars[2]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[3] {
      label="csB_on";
      desc="time step (out of 20) when CS B comes on (if it is being presented according to env_type)";
      cust_desc=1;
      base=.projects[0].programs[0].vars[3]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[4] {
      label="csB_off";
      desc="time step (out of 20) when CS B goes off";
      cust_desc=1;
      base=.projects[0].programs[0].vars[4]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[5] {
      label="us_on";
      desc="time step (out of 20) when US comes on (if it is being presented according to env_type)";
      cust_desc=1;
      base=.projects[0].programs[0].vars[5]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
     EditMbrItem @[6] {
      label="us_off";
      desc="time step (out of 20) when US goes off";
      cust_desc=1;
      base=.projects[0].programs[0].vars[6]$$;
      mbr=ProgVar::int_val;
      is_numeric=1;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1;
      };
     };
    };
    EditMbrItem_Group @.gp[2] {
     name="Net Data";
     el_typ=EditMbrItem;
     el_def=0;
     EditMbrItem @[0] {
      label="RlCondNet trial";
      desc=" trial counter: number of external input patterns that have been presented in the current epoch (updated by program)";
      cust_desc=0;
      base=.projects[0].networks[0]$$;
      mbr=Network::trial;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[1] {
      label="RlCondNet trial name";
      desc=" name associated with the current trial (e.g., name of input pattern, typically set by a LayerWriter)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::trial_name;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[2] {
      label="RlCondNet ext rew";
      desc=" external reward value (on this trial) -- only computed if ExtRewLayerSpec or similar exists in network -- equals PVe value in PVLV framework";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=LeabraNetwork::ext_rew;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
     EditMbrItem @[3] {
      label="RlCondNet epoch";
      desc=" epoch counter: number of times a complete set of training patterns has been presented (updated by program)";
      cust_desc=0;
      base=$.projects[0].networks[0]$;
      mbr=Network::epoch;
      is_numeric=0;
      param_search {
       search=0;
       min_val=0;
       max_val=1;
       next_val=0;
       incr=0.1000000014901161;
      };
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects[0].programs.gp[0][1]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects[0].programs.gp[0][1]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Gen Inputs";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[0]$$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[5] {
     label="Reset Trial Data";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=.projects[0].programs[1]$$;
     mth=Program::Run_Gui;
    };
   };
  };
  SelectEdit @[1] {
   name="TD";
   auto_edit=0;
   desc="standard parameters for the TD algorithm";
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="rewpred lrate";
     desc="[Default: 0.01;0.02]  [0.01 for std Leabra, .02 for CtLeabra] learning rate -- how fast do the weights change per experience";
     cust_desc=0;
     base=$.projects[0].networks[0].specs.gp[1][0].children[0]$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="extrew rew";
     desc=" misc reward computation specifications<br>  err val: [Default: 0]  reward value for errors (when network does not respond correctly)<br>  norew val: [Default: 0.5]  reward value when no feedback information is present<br>  rew val: [Default: 1]  reward value for correct responses (positive rewards)";
     cust_desc=0;
     base=.projects[0].networks[0].specs.gp[2][0]$$;
     mbr=ExtRewLayerSpec::rew;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="tdint rew integ";
     desc=" misc specs for TDRewIntegLayerSpec<br>  discount:  discount factor for V(t+1) from TDRewPredLayer<br>  max r v:  represent the maximum of extrew (r) and tdrewpred estimate of V(t+1) instead of the sum of these two factors -- produces a kind of 'absorbing' reward function instead of a cumulative reward function";
     cust_desc=0;
     base=$.projects[0].networks[0].specs.gp[2][2]$;
     mbr=TDRewIntegLayerSpec::rew_integ;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="StdInputData";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [20] "g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";
"g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";"g0";
      };
     };
     String_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [20] "t=0";"t=1";"t=2";"t=3";"t=4";"t=5";"t=6";"t=7";"t=8";"t=9";
"t=10";"t=11";"t=12";"t=13";"t=14";"t=15";"t=16";"t=17";"t=18";"t=19";
      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 20;3;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [20 3 20] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
1;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;1;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="ExtRew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 1;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      ar {
       name=;
	    [1 1 20] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;1;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     String_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[8] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[9] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="td_val";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[10] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="rew_pred";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[11] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 6 0=0.1865671575069427;
	val_type_fixed=0;
       };
      };
      name="rew_integ";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @[0] {
   name="GenCondInputs";
   short_nm="AplyIn";
   tags=;
   desc="generate conditioning environment: IMPORTANT -- the LeabraEpoch program must be set to SEQUENTIAL order!";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=DynEnumType;
    el_def=0;
    DynEnumType @[0] {
     name="EnvType";
     desc=;
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="CSA_US";
       value=0;
       desc="conditioned stimulus (CS) A is associated with unconditioned stimulus (US) (reward)";
      };
      DynEnumItem @[1] {
       name="CSA_NO";
       value=1;
       desc="conditioned stimulus (CS) A is associated with NO unconditioned stimulus (US) (reward)";
      };
      DynEnumItem @[2] {
       name="CSA_CSB_US";
       value=2;
       desc="conditioned stimulus (CS) A is associated with CS B is associated with unconditioned stimulus (US) (reward) -- second order conditioning";
      };
      DynEnumItem @[3] {
       name="CSA_CSB_NO";
       value=3;
       desc="conditioned stimulus (CS) A is associated with CS B is associated with NO unconditioned stimulus (US) (reward) -- second order conditioning";
      };
      DynEnumItem @[4] {
       name="CSB_US";
       value=4;
       desc="conditioned stimulus (CS) B is associated with unconditioned stimulus (US) (reward)";
      };
      DynEnumItem @[5] {
       name="CSB_NO";
       value=5;
       desc="conditioned stimulus (CS) B is associated with NO unconditioned stimulus (US) (reward)";
      };
     };
     bits=0;
    };
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[0][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="env_type";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[0].programs[0].types[0]$$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="type of conditioning environment to generate, in terms of CS, US associations";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="csA_on";
     var_type=T_Int;
     int_val=10;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when CS A comes on (if it is being presented according to env_type)";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="csA_off";
     var_type=T_Int;
     int_val=16;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when CS A goes off";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="csB_on";
     var_type=T_Int;
     int_val=2;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when CS B comes on (if it is being presented according to env_type)";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="csB_off";
     var_type=T_Int;
     int_val=10;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when CS B goes off";
     init_from=NULL;
    };
    ProgVar @[5] {
     name="us_on";
     var_type=T_Int;
     int_val=15;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when US comes on (if it is being presented according to env_type)";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="us_off";
     var_type=T_Int;
     int_val=16;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="time step (out of 20) when US goes off";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="time_tot";
     var_type=T_Int;
     int_val=20;
     objs_ptr=0;
     flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="total time represented in input";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="p_samples";
     var_type=T_Int;
     int_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="number of samples of trials to generate if specifying probabilities (e.g., 10 for basic probabilities, 100 for finer-grained)";
     init_from=NULL;
    };
    ProgVar @[9] {
     name="csA_p";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="probability that CS A is actually presented if env_type says it should be";
     init_from=NULL;
    };
    ProgVar @[10] {
     name="csB_p";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="probability that CS B is actually presented if env_type says it should be";
     init_from=NULL;
    };
    ProgVar @[11] {
     name="us_p";
     var_type=T_Real;
     real_val=1;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="probability that US (reward) is actually presented if env_type says it should be";
     init_from=NULL;
    };
    ProgVar @[12] {
     name="csA_time_var";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="variability (uniform +/- range around specified value) in timing of presentation of CS A (if being presented)";
     init_from=NULL;
    };
    ProgVar @[13] {
     name="csB_time_var";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="variability (uniform +/- range around specified value) in timing of presentation of CS B (if being presented)";
     init_from=NULL;
    };
    ProgVar @[14] {
     name="us_time_var";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="variability (uniform +/- range around specified value) in timing of presentation of US (if being presented)";
     init_from=NULL;
    };
    ProgVar @[15] {
     name="i";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[16] {
     name="sample";
     var_type=T_Int;
     int_val=1;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[17] {
     name="cur_st_row";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="current starting row index";
     init_from=NULL;
    };
    ProgVar @[18] {
     name="a_is_on";
     var_type=T_Bool;
     bool_val=1;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="cs a should be on for current trial";
     init_from=NULL;
    };
    ProgVar @[19] {
     name="b_is_on";
     var_type=T_Bool;
     bool_val=0;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="cs b should be on for current trial";
     init_from=NULL;
    };
    ProgVar @[20] {
     name="us_is_on";
     var_type=T_Bool;
     bool_val=1;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="us should be on for current trial";
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
    Function @[0] {
     desc=;
     flags=;
     name="RenderCS";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="cs_no";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="number of the CS (i.e., row of the input table)";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="cs_on";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="starting time";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="cs_off";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="stopping time";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="cs_var";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="variability in timing";
       init_from=NULL;
      };
      ProgVar @[4] {
       name="st_row";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="starting row index";
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ProgVars @[0] {
       desc=;
       flags=;
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
	ProgVar @[1] {
	 name="cs_on_eff";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc="effective on value (+ var)";
	 init_from=NULL;
	};
	ProgVar @[2] {
	 name="cs_off_eff";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc="effective off value (+ var)";
	 init_from=NULL;
	};
       };
      };
      RandomCall @[1] {
       desc="just to get the function info for below";
       flags=OFF;
       result_var=NULL;
       object_type=Random;
       method=Random::IntMeanRange;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="mean";
	 required=1;
	 def_val=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="range";
	 required=1;
	 def_val=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      AssignExpr @[2] {
       desc=;
       flags=;
       result_var=.projects[0].programs[0].functions[0].fun_code[0].local_vars[1]$$;
       expr {
	expr="cs_on + Random::IntMeanRange(0, cs_var)";
       };
      };
      AssignExpr @[3] {
       desc=;
       flags=;
       result_var=.projects[0].programs[0].functions[0].fun_code[0].local_vars[2]$$;
       expr {
	expr="cs_off + Random::IntMeanRange(0, cs_var)";
       };
      };
      ForLoop @[4] {
       desc="loop over time steps";
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MethodCall @[0] {
	 desc="set units active";
	 flags=;
	 result_var=NULL;
	 obj=.projects[0].programs[0].args[0]$$;
	 method=DataTable::SetMatrixValColName;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="const Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   expr {
	    expr="1.0";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="col_name";
	   required=1;
	   def_val=;
	   expr {
	    expr="\"Input\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   expr {
	    expr="st_row + i";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=int;
	   type="int";
	   name="d0";
	   required=1;
	   def_val=;
	   expr {
	    expr="i";
	   };
	  };
	  ProgArg @[4] {
	   arg_type=int;
	   type="int";
	   name="d1";
	   required=0;
	   def_val="0";
	   expr {
	    expr="cs_no";
	   };
	  };
	  ProgArg @[5] {
	   arg_type=int;
	   type="int";
	   name="d2";
	   required=0;
	   def_val="0";
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[6] {
	   arg_type=int;
	   type="int";
	   name="d3";
	   required=0;
	   def_val="0";
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[7] {
	   arg_type=bool;
	   type="bool";
	   name="quiet";
	   required=0;
	   def_val="false";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
       };
       init {
	expr="i = cs_on_eff";
       };
       test {
	expr="i < cs_off_eff";
       };
       iter {
	expr="i++";
       };
      };
     };
    };
    Function @[1] {
     desc=;
     flags=;
     name="RenderUS";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="st_row";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="starting row index";
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ProgVars @[0] {
       desc=;
       flags=;
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
	ProgVar @[1] {
	 name="us_on_eff";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc="effective on value (+ var)";
	 init_from=NULL;
	};
	ProgVar @[2] {
	 name="us_off_eff";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc="effective off value (+ var)";
	 init_from=NULL;
	};
       };
      };
      RandomCall @[1] {
       desc="just to get the function info for below";
       flags=OFF;
       result_var=NULL;
       object_type=Random;
       method=Random::IntMeanRange;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="mean";
	 required=1;
	 def_val=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="range";
	 required=1;
	 def_val=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      AssignExpr @[2] {
       desc=;
       flags=;
       result_var=.projects[0].programs[0].functions[1].fun_code[0].local_vars[1]$$;
       expr {
	expr="us_on + Random::IntMeanRange(0, us_time_var)";
       };
      };
      AssignExpr @[3] {
       desc=;
       flags=;
       result_var=.projects[0].programs[0].functions[1].fun_code[0].local_vars[2]$$;
       expr {
	expr="us_off + Random::IntMeanRange(0, us_time_var)";
       };
      };
      ForLoop @[4] {
       desc="loop over time steps";
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MethodCall @[0] {
	 desc="set units active";
	 flags=;
	 result_var=NULL;
	 obj=$.projects[0].programs[0].args[0]$;
	 method=DataTable::SetMatrixValColName;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="const Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   expr {
	    expr="1.0";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="col_name";
	   required=1;
	   def_val=;
	   expr {
	    expr="\"ExtRew\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   expr {
	    expr="st_row + i";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=int;
	   type="int";
	   name="d0";
	   required=1;
	   def_val=;
	   expr {
	    expr="0";
	   };
	  };
	  ProgArg @[4] {
	   arg_type=int;
	   type="int";
	   name="d1";
	   required=0;
	   def_val="0";
	   expr {
	    expr="0";
	   };
	  };
	  ProgArg @[5] {
	   arg_type=int;
	   type="int";
	   name="d2";
	   required=0;
	   def_val="0";
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[6] {
	   arg_type=int;
	   type="int";
	   name="d3";
	   required=0;
	   def_val="0";
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[7] {
	   arg_type=bool;
	   type="bool";
	   name="quiet";
	   required=0;
	   def_val="false";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
       };
       init {
	expr="i = us_on_eff";
       };
       test {
	expr="i < us_off_eff";
       };
       iter {
	expr="i++";
       };
      };
     };
    };
    Function @[2] {
     desc=;
     flags=;
     name="LabelRows";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="st_row";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|LOCAL_VAR|FUN_ARG|USED;
       reference=0;
       desc="starting row index";
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      ProgVars @[0] {
       desc=;
       flags=;
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
	ProgVar @[0] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 objs_ptr=0;
	 flags=NULL_CHECK|LOCAL_VAR|USED;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
       };
      };
      ForLoop @[1] {
       desc=;
       flags=;
       loop_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 obj=$.projects[0].programs[0].args[0]$;
	 method=DataTable::SetValColName;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="const Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   expr {
	    expr="\"t=\" + i";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="col_name";
	   required=1;
	   def_val="\"\"";
	   expr {
	    expr="\"Name\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   expr {
	    expr="st_row + i";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="quiet";
	   required=0;
	   def_val="false";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	MethodCall @[1] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 obj=$.projects[0].programs[0].args[0]$;
	 method=DataTable::SetValColName;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="const Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   expr {
	    expr="\"g\" + sample";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="const taString&";
	   name="col_name";
	   required=1;
	   def_val="\"\"";
	   expr {
	    expr="\"Group\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   expr {
	    expr="st_row + i";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="quiet";
	   required=0;
	   def_val="false";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
       };
       init {
	expr="i = 0";
       };
       test {
	expr="i < time_tot";
       };
       iter {
	expr="i++";
       };
      };
     };
    };
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    ResetDataRows @[0] {
     desc="start fresh";
     flags=;
     data_var=$.projects[0].programs[0].args[0]$;
    };
    ForLoop @[1] {
     desc="iterate over random samples";
     flags=;
     loop_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      AssignExpr @[0] {
       desc="start at end of current table size";
       flags=;
       result_var=.projects[0].programs[0].vars[17]$$;
       expr {
	expr="input_data.rows";
       };
      };
      MethodCall @[1] {
       desc="add the rows for the new event";
       flags=;
       result_var=NULL;
       obj=$.projects[0].programs[0].args[0]$;
       method=DataTable::AddRows;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="n";
	 required=0;
	 def_val="1";
	 expr {
	  expr="time_tot";
	 };
	};
       };
      };
      FunctionCall @[2] {
       desc=;
       flags=;
       result_var=NULL;
       fun=.projects[0].programs[0].functions[2]$$;
       fun_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=1;
	 def_val=;
	 expr {
	  expr="cur_st_row";
	 };
	};
       };
      };
      Comment @[3] {
       desc="Now figure out what is on";
       flags=;
      };
      AssignExpr @[4] {
       desc="default off";
       flags=;
       result_var=.projects[0].programs[0].vars[18]$$;
       expr {
	expr="false";
       };
      };
      AssignExpr @[5] {
       desc="default off";
       flags=;
       result_var=.projects[0].programs[0].vars[19]$$;
       expr {
	expr="false";
       };
      };
      AssignExpr @[6] {
       desc="default off";
       flags=;
       result_var=.projects[0].programs[0].vars[20]$$;
       expr {
	expr="false";
       };
      };
      If @[7] {
       desc="a is on";
       flags=;
       cond {
	expr="env_type <  CSB_US";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=;
	 result_var=$.projects[0].programs[0].vars[18]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      If @[8] {
       desc="b is on";
       flags=;
       cond {
	expr="env_type >   CSA_NO";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=;
	 result_var=$.projects[0].programs[0].vars[19]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      If @[9] {
       desc="us is on for even items!";
       flags=;
       cond {
	expr="env_type % 2 == 0";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=;
	 result_var=$.projects[0].programs[0].vars[20]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      RandomCall @[10] {
       desc="just for finding function used below";
       flags=OFF;
       result_var=NULL;
       object_type=Random;
       method=Random::ZeroOne;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
      };
      If @[11] {
       desc="probability of turning a off";
       flags=;
       cond {
	expr="Random::ZeroOne() < (1.0 - csA_p)";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc="turn off";
	 flags=;
	 result_var=$.projects[0].programs[0].vars[18]$;
	 expr {
	  expr="false";
	 };
	};
       };
      };
      If @[12] {
       desc="probability of turning b off";
       flags=;
       cond {
	expr="Random::ZeroOne() < (1.0 - csB_p)";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc="turn off";
	 flags=;
	 result_var=$.projects[0].programs[0].vars[19]$;
	 expr {
	  expr="false";
	 };
	};
       };
      };
      If @[13] {
       desc="probability of turning b off";
       flags=;
       cond {
	expr="Random::ZeroOne() < (1.0 - us_p)";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc="turn off";
	 flags=;
	 result_var=$.projects[0].programs[0].vars[20]$;
	 expr {
	  expr="false";
	 };
	};
       };
      };
      If @[14] {
       desc=;
       flags=;
       cond {
	expr="a_is_on";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=.projects[0].programs[0].functions[0]$$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="cs_no";
	   required=1;
	   def_val=;
	   expr {
	    expr="0";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="cs_on";
	   required=1;
	   def_val=;
	   expr {
	    expr="csA_on";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="cs_off";
	   required=1;
	   def_val=;
	   expr {
	    expr="csA_off";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=int;
	   type="int";
	   name="cs_var";
	   required=1;
	   def_val=;
	   expr {
	    expr="csA_time_var";
	   };
	  };
	  ProgArg @[4] {
	   arg_type=int;
	   type="int";
	   name="st_row";
	   required=1;
	   def_val=;
	   expr {
	    expr="cur_st_row";
	   };
	  };
	 };
	};
       };
      };
      If @[15] {
       desc=;
       flags=;
       cond {
	expr="b_is_on";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=$.projects[0].programs[0].functions[0]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="cs_no";
	   required=1;
	   def_val=;
	   expr {
	    expr="1";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="cs_on";
	   required=1;
	   def_val=;
	   expr {
	    expr="csB_on";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="cs_off";
	   required=1;
	   def_val=;
	   expr {
	    expr="csB_off";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=int;
	   type="int";
	   name="cs_var";
	   required=1;
	   def_val=;
	   expr {
	    expr="csB_time_var";
	   };
	  };
	  ProgArg @[4] {
	   arg_type=int;
	   type="int";
	   name="st_row";
	   required=1;
	   def_val=;
	   expr {
	    expr="cur_st_row";
	   };
	  };
	 };
	};
       };
      };
      If @[16] {
       desc=;
       flags=;
       cond {
	expr="us_is_on";
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=;
	 result_var=NULL;
	 fun=.projects[0].programs[0].functions[1]$$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="st_row";
	   required=1;
	   def_val=;
	   expr {
	    expr="cur_st_row";
	   };
	  };
	 };
	};
       };
      };
      DoneWritingDataRow @[17] {
       desc=;
       flags=;
       data_var=$.projects[0].programs[0].args[0]$;
      };
     };
     init {
      expr="sample = 0";
     };
     test {
      expr="sample < p_samples";
     };
     iter {
      expr="sample++";
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[1] {
   name="ResetTrialMonData";
   short_nm="TrlMon";
   tags=;
   desc="just clears out the trial monitor data";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="TrialOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[0].data.gp[1][0]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    ResetDataRows @[0] {
     desc=;
     flags=;
     data_var=.projects[0].programs[1].vars[0]$$;
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program @[2] {
   name="LabelInputUnits";
   short_nm="AplyIn";
   tags=;
   desc="labels the input units by stimulus and time";
   flags=NO_STOP_STEP;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=$.projects[0].networks[0]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
     reference=0;
     desc="network to train";
     init_from=NULL;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="i";
     var_type=T_Int;
     int_val=20;
     objs_ptr=0;
     flags=NULL_CHECK|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="x_size";
     var_type=T_Int;
     int_val=20;
     objs_ptr=0;
     flags=NULL_CHECK|USED|EDIT_VAL;
     reference=0;
     desc="size of layer in x dimension";
     init_from=NULL;
    };
    ProgVar @[2] {
     name="input_layer";
     var_type=T_Object;
     object_type=Layer;
     object_val=.projects[0].networks[0].layers[4]$$;
     objs_ptr=0;
     flags=USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    AssignExpr @[0] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[2]$$;
     expr {
      expr="network.layers.Input";
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=;
     result_var=.projects[0].programs[2].vars[1]$$;
     expr {
      expr="input_layer.un_geom.x";
     };
    };
    ForLoop @[2] {
     desc=;
     flags=;
     loop_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      MemberAssign @[0] {
       desc=;
       flags=;
       obj=$.projects[0].programs[2].vars[2]$;
       path="units[i].name";
       expr {
	expr="\"A_\" + i";
       };
       update_after=0;
      };
      MemberAssign @[1] {
       desc=;
       flags=;
       obj=$.projects[0].programs[2].vars[2]$;
       path="units[i + x_size].name";
       expr {
	expr="\"B_\" + i";
       };
       update_after=0;
      };
      MemberAssign @[2] {
       desc=;
       flags=;
       obj=$.projects[0].programs[2].vars[2]$;
       path="units[i + 2*x_size].name";
       expr {
	expr="\"C_\" + i";
       };
       update_after=0;
      };
     };
     init {
      expr="i = 0";
     };
     test {
      expr="i < x_size";
     };
     iter {
      expr="i++";
     };
    };
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[0].programs.gp[0][0].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][0].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][1]$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$.projects[0].programs.gp[0][0].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[1] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=500;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=72;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[0].programs.gp[0][1].types[0]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[0].programs.gp[0][1].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][1].args[2]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][1].args[0]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[6]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[5]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].vars[5]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$.projects[0].programs.gp[0][1].vars[6]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$.projects[0].programs.gp[0][1].args[0]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     IfElse @[3] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
       };
       MethodCall @[2] {
	desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
	flags=OFF;
	result_var=NULL;
	obj=.projects[0].programs.gp[0][1].vars[7]$$;
	method=DataTable::ResetData;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     AssignExpr @[4] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[0].programs.gp[0][1].vars[1]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[5] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][2]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][1].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][1].vars[1]$;
	counter=Network::epoch;
	update_after=1;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[6] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][1].vars[6]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[2] {
    name="LeabraEpochGpData";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="item_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- if we want to reset it every epoch";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[0].networks[0].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="group_index";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[6] {
      name="item_index";
      var_type=T_Int;
      int_val=9;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter: note also needs to do this in regular running program";
      flags=;
      network_var=.projects[0].programs.gp[0][2].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][2].vars[2]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=.projects[0].programs.gp[0][2].vars[4]$$;
      expr {
       expr="network.epoch_time";
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter";
      flags=;
      network_var=$.projects[0].programs.gp[0][2].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][2].vars[2]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=;
      result_var=$.projects[0].programs.gp[0][2].vars[4]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[2] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[4]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
      flags=OFF;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][2].vars[3]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetGroupedDataLoop @[4] {
      desc="iterates over groups and items within groups";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="call the trial process";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][3]$$;
	targ_ld_init="*LeabraTrial*";
       };
      };
      data_var=.projects[0].programs.gp[0][2].args[1]$$;
      group_index_var=.projects[0].programs.gp[0][2].vars[5]$$;
      item_index_var=.projects[0].programs.gp[0][2].vars[6]$$;
      group_order_var=.projects[0].programs.gp[0][2].vars[0]$$;
      item_order_var=.projects[0].programs.gp[0][2].vars[1]$$;
      group_order=PERMUTED;
      item_order=SEQUENTIAL;
      group_col=0;
      update_after=0;
      group_idx_list{ 0;      };
      item_idx_list{ 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;      };
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][2].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][2].vars[4]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[8] {
      desc="call the epoch monitor";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][8]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=.projects[0].programs.gp[0][5]$$;
    step_n=1;
   };
   Program @[3] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[0].programs.gp[0][3].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects[0].programs.gp[0][4]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][3].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][3].vars[0]$;
	counter=LeabraNetwork::phase_no;
	update_after=0;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][3].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=;
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values based on changes computed by trial program";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][3].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     ProgramCall @[5] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects[0].programs.gp[0][7]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$.projects[0].programs.gp[0][3].args[0]$;
      update_var=.projects[0].programs.gp[0][3].vars[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[4] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[0].programs.gp[0][4].args[0]$$;
      local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects[0].programs.gp[0][6]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[0].programs.gp[0][4].vars[1]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$.projects[0].programs.gp[0][4].vars[1]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects[0].programs.gp[0][5]$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$.projects[0].programs.gp[0][4].args[0]$;
	local_ctr_var=$.projects[0].programs.gp[0][4].vars[0]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][4].args[0]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$.projects[0].programs.gp[0][4].args[0]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][4].args[0]$;
      update_var=.projects[0].programs.gp[0][4].vars[2]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[5] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][5].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$.projects[0].programs.gp[0][5].args[0]$;
      update_var=.projects[0].programs.gp[0][5].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[6] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.projects[0].data.gp[0][0]$;
      network=$.projects[0].networks[0]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="ExtRew";
	net_target=LAYER;
	layer_name="ExtRew";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	na_by_range=0;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[0][0]$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[0].programs.gp[0][6].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][6].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][6].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[7] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="minus_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="td_val";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[10] {
	name="rew_pred";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[11] {
	name="rew_integ";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[12] {
	name="ext_rew";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="Aggregate": op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=$.projects[0].data.gp[1][0]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][7].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="td_val";
      var_type=T_Real;
      real_val=2.60472297668457e-05;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="rew_pred";
      var_type=T_Real;
      real_val=0.7014315724372864;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[4] {
      name="rew_integ";
      var_type=T_Real;
      real_val=0.7014576196670532;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[5] {
      name="ext_rew";
      var_type=T_Real;
      real_val=9.533668077210677e-09;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="td unit plus phase val";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[2]$$;
      expr {
       expr="network.layers.TD.units[0].act_p";
      };
     };
     AssignExpr @[3] {
      desc="rew pred minus phase = prior prediction about current state";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[3]$$;
      expr {
       expr="network.layers.TDRewPred.units[0].act_m";
      };
     };
     AssignExpr @[4] {
      desc="rew integ plus phase = overall value of current state";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[4]$$;
      expr {
       expr="network.layers.TDRewPred.units[0].act_p";
      };
     };
     AssignExpr @[5] {
      desc="external reward";
      flags=;
      result_var=.projects[0].programs.gp[0][7].vars[5]$$;
      expr {
       expr="network.layers.ExtRew.units[0].act_p";
      };
     };
     DataVarProg @[6] {
      desc=;
      flags=;
      data_var=$.projects[0].programs.gp[0][7].vars[0]$;
      set_data=1;
      row_spec=CUR_ROW;
      row_var=NULL;
      quiet=0;
      var_1=$.projects[0].programs.gp[0][7].vars[2]$;
      var_2=$.projects[0].programs.gp[0][7].vars[3]$;
      var_3=$.projects[0].programs.gp[0][7].vars[4]$;
      var_4=$.projects[0].programs.gp[0][7].vars[5]$;
     };
     MethodCall @[7] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][7].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][7].args[0]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[8] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects[0].networks[0]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects[0].networks[0]$;
      data=.projects[0].data.gp[1][1]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects[0].data.gp[1][1]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[0].programs.gp[0][8].objs[0]$$;
      objs_ptr=1;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects[0].networks[0].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[0].programs.gp[0][8].vars[2]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[1]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[0].programs.gp[0][8].vars[0]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[1]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$.projects[0].programs.gp[0][8].vars[2]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][8].vars[0]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @[9] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects[0].networks[0]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[0].programs.gp[0][9].vars[2]$$;
      obj=.projects[0].programs.gp[0][9].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$.projects[0].programs.gp[0][9].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="view_win_lft";
     value 6 0=0.001229256275109947;
     val_type_fixed=0;
    };
    UserDataItem @[1] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[2] {
     name="view_win_wd";
     value 6 0=1;
     val_type_fixed=0;
    };
    UserDataItem @[3] {
     name="view_win_ht";
     value 6 0=0.7996109127998352;
     val_type_fixed=0;
    };
    UserDataItem @[4] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @[5] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAzAAAAp4AAALlAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser2";
   m_data=.projects[0]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects[0]$;
    };
    PanelViewer @[1] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3DataViewer @[2] {
     name="T3Frames";
     m_data=NULL;
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       name="RlCondNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  name=;
	  m_data=$.projects[0].networks[0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_mv=1;
	  net_text=1;
	  net_text_xform {scale={x=0.7: y=0.7000002: z=0.7000002: }: rotate={x=1: y=0: z=0: rot=1.570796: }: translate={x=1.018512: y=0.716248: z=-1: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[4].units[0]";
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=17: y=5: z=1.5: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    name="act_p";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    name="p_act_p";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    name="p_act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    name="r.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    name="s.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[8] {
	    name="trace";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ ExtRew=0;TDRewPred=0;TDRewInteg=0;TD=0;Input=0;	  };
	 };
	 GraphTableView @[1] {
	  name=;
	  m_data=$.projects[0].data.gp[1][0]$;
FloatTransform @*(.m_transform) {scale={x=0.3416232: y=0.341623: z=0.3416229: }: rotate={x=0.9999991: y=0: z=0: rot=0.1789013: }: translate={x=0.03134418: y=1.132889: z=0.007225642: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.projects[0].data.gp[1][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.projects[0].data.gp[1][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=42: fix_max=0: max=55: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="trial";
	    m_data=.projects[0].data.gp[1][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=1: max=20: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="trial_name";
	    m_data=.projects[0].data.gp[1][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="group_name";
	    m_data=.projects[0].data.gp[1][0].data[4]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="phase_no";
	    m_data=.projects[0].data.gp[1][0].data[5]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="minus_cycles";
	    m_data=.projects[0].data.gp[1][0].data[6]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="sse";
	    m_data=.projects[0].data.gp[1][0].data[7]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="ext_rew";
	    m_data=.projects[0].data.gp[1][0].data[8]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=9.53367e-09: fix_max=0: max=1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="td_val";
	    m_data=.projects[0].data.gp[1][0].data[9]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=-1: fix_max=1: max=1.1: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="rew_pred";
	    m_data=.projects[0].data.gp[1][0].data[10]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.0159905: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="rew_integ";
	    m_data=.projects[0].data.gp[1][0].data[11]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=6.2532e-09: fix_max=0: max=1.01939: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=0.3416232: y=0.341623: z=0.3416229: }: rotate={x=0.9999991: y=0: z=0: rot=0.1789013: }: translate={x=0.03134418: y=1.132889: z=0.007225642: }: };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  label_spacing=-1;
	  width=2.5;
	  depth=1;
	  axis_font_size=0.1;
	  label_font_size=0.04;
	  x_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="trial";
	   fixed_range {fix_min=1: min=0: fix_max=1: max=20: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=20: };
	   range {min=0: max=20: };
	   n_ticks=10;
	   axis_length=2.5;
	   row_num=0;
	  };
	  z_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Z;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=27: fix_max=0: max=72: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=27: max=72: };
	   range {min=27: max=72: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="td_val";
	   fixed_range {fix_min=1: min=-1: fix_max=1: max=1.1: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-1: max=1.1: };
	   range {min=-1: max=1.1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  plot_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="rew_pred";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0.0159905: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0.01599046: };
	   range {min=0: max=0.01599046: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	   alt_y=0;
	  };
	  plot_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="rew_integ";
	   fixed_range {fix_min=0: min=6.2532e-09: fix_max=0: max=1.01939: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=6.253195e-09: max=1.019395: };
	   range {min=6.253195e-09: max=1.019395: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	   alt_y=0;
	  };
	  plot_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name="ext_rew";
	   fixed_range {fix_min=0: min=9.53367e-09: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=9.533668e-09: max=1: };
	   range {min=9.533668e-09: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	   alt_y=0;
	  };
	  plot_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	   alt_y=0;
	  };
	  plot_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CROSS;
	   alt_y=0;
	  };
	  plot_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=STAR;
	   alt_y=0;
	  };
	  plot_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=MINUS;
	   alt_y=0;
	  };
	  alt_y_1=0;
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  err_1 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_2 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_3 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_4 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_5 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_6 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_7 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_8 {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	   alt_y=0;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=VALUE_COLOR;
	  color_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name=;
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=TOP_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=0.5876094: y=1.016543: z=1.75045: };
	 orient {x=-0.9999998: y=0: z=0: rot=0.140001: };
	 focal_dist=2.000908;
	};
	T3SavedView @[1] {
	 name="Network";
	 view_saved=1;
	 pos {x=0.5876093: y=0.9830321: z=1.488463: };
	 orient {x=-1.000002: y=0: z=0: rot=0.2580006: };
	 focal_dist=1.778199;
	};
	T3SavedView @[2] {
	 name="Graph";
	 view_saved=1;
	 pos {x=0.4296093: y=1.05772: z=1.215535: };
	 orient {x=1: y=0: z=0: rot=0.1139975: };
	 focal_dist=1.455866;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3DataViewFrame @[1] {
       name="StdInputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  name=;
	  m_data=$.projects[0].data.gp[0][0]$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    name="Group";
	    m_data=.projects[0].data.gp[0][0].data[0]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    name="Name";
	    m_data=.projects[0].data.gp[0][0].data[1]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    name="Input";
	    m_data=.projects[0].data.gp[0][0].data[2]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=20;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    name="ExtRew";
	    m_data=.projects[0].data.gp[0][0].data[3]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10;
	  view_range {min=0: max=9: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=3: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs[0]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="View 0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @[1] {
	 name="View 1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="View 2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="View 3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="View 4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="View 5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_win_top";
       value 6 0=0.008754863403737545;
       val_type_fixed=0;
      };
      UserDataItem @[2] {
       name="view_win_wd";
       value 6 0=0.05961893126368523;
       val_type_fixed=0;
      };
      UserDataItem @[3] {
       name="view_win_ht";
       value 6 0=0.7285992503166199;
       val_type_fixed=0;
      };
      UserDataItem @[4] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @[5] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[1] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[2] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[3] {
     name="minus_output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[4] {
     name="minus_cycles";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[5] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[6] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[7] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[8] {
     name="sse";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[9] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[10] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[11] {
     name="group_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[12] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[13] {
     name="cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[14] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[15] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[16] {
     name="group";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @[17] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @[18] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="RlCondNet";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraTdUnitSpec @[0] {
     name="LeabraTdUnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs[3].children[0]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     spike {rise=1: decay=0.05: g_gain=4: window=20: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
     dt {integ=1: vm=0.3: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=3.333333: net_time=1.428571: };
     act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.1: i=1: h=0.01: a=0.03: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=0: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
     lambda=0;
    };
    LeabraLayerSpec @[1] {
     name="HiddenLayer";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input_Output";
       desc=;
       unique{ inhib;kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       inhib {
	type=KWTA_INHIB;
	kwta_pt=0.25;
	min_i=0;
	fb_act_thr=0;
	ff_pct=0;
	fb_max_dt=0.1;
	comp_thr=0.5;
	comp_gain=2;
	gp_pt=0.2;
       };
       kwta {k_from=USE_PAT_K: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
       i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
       adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=1: };
       ct_inhib_mod {
	use_sin=0;
	burst_i=0.02;
	trough_i=0.02;
	use_fin=0;
	inhib_i=0;
       };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_AVG_INHIB;
      kwta_pt=0.6;
      min_i=0;
      fb_act_thr=0;
      ff_pct=0;
      fb_max_dt=0.1;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
     adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=1: };
     ct_inhib_mod {
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[2] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     add_rnd_wts=0;
    };
    LeabraConSpec @[3] {
     name="LeabraConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
       wt_scale_init {init=0: abs=1: rel=1: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       wt_sig {gain=6: off=1.25: };
       lmix {hebb=0.001: err=0.999: err_sb=1: };
       xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
       savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
     wt_scale_init {init=0: abs=1: rel=1: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     wt_sig {gain=6: off=1.25: };
     lmix {hebb=0.001: err=0.999: err_sb=1: };
     xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
     savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    BaseSpec_Group @.gp[0] {
     name="TD_Units";
     el_typ=LeabraTdUnitSpec;
     el_def=0;
     LeabraTdUnitSpec @[0] {
      name="TDRewPredUnits";
      desc=;
      unique{ g_bar;act;      };
      children {
       name=;
       el_typ=LeabraTdUnitSpec;
       el_def=0;
      };
      act_range {min=0: max=1: range=1: scale=1: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[1]$$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0: avg_init=0.15: i_thr=STD: };
      spike {rise=1: decay=0.05: g_gain=4: window=20: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
      dt {integ=1: vm=0.3: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=100: vm_eq_dt=1: integ_time=1: vm_time=3.333333: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=0.015: a=0.045: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
      lambda=0;
     };
     LeabraTdUnitSpec @[1] {
      name="TdUnits";
      desc=;
      unique{ act_range;clamp_range;      };
      children {
       name=;
       el_typ=LeabraTdUnitSpec;
       el_def=0;
      };
      act_range {min=-2: max=2: range=4: scale=0.25: };
      bias_con_type=LeabraCon;
      bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[1].children[0]$$: };
      sse_tol=0.5;
      act_fun=NOISY_XX1;
      act {gelin=0: thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
      spike {rise=1: decay=0.05: g_gain=4: window=20: eq_gain=10: eq_dt=0.02: };
      spike_misc {
       exp_slope=0.02;
       spk_thr=1.2;
       clamp_max_p=0.11;
       clamp_type=REGULAR;
       vm_r=0.3;
       vm_dend=0.3;
       vm_dend_dt=0.16;
       vm_dend_time=6.25;
      };
      opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
      maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
      clamp_range {min=-2: max=2: range=4: scale=0.25: };
      vm_range {min=0: max=1: range=1: scale=1: };
      v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
      dt {integ=1: vm=0.3: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=3.333333: net_time=1.428571: };
      act_avg {l_gain=3: l_dt=0.005: ml_dt=0.4: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=200: ml_time=2.5: m_time=10: s_time=5: ss_time=1: };
      g_bar {e=1: l=0.1: i=1: h=0.01: a=0.03: };
      e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
      hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
      acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
      adapt {
       on=0;
       dt=0.007;
       vm_gain=0.04;
       spike_gain=0.00805;
       interval=10;
       dt_time=142.8571;
      };
      depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
      syn_delay {
       on=0;
       delay=4;
      };
      da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
      noise_type=NO_NOISE;
      noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
      noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
      noise_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=1;
       cur_val=0;
      };
      lambda=0;
     };
    };
    BaseSpec_Group @.gp[1] {
     name="TD_Cons";
     el_typ=LeabraConSpec;
     el_def=0;
     LeabraConSpec @[0] {
      name="LearnCons";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TDRewPredConSpec;
       el_def=0;
       TDRewPredConSpec @[0] {
	name="TDRewPredCons";
	desc=;
	unique{ lmix;rnd;wt_limits;wt_sig;lrate;	};
	children {
	 name=;
	 el_typ=TDRewPredConSpec;
	 el_def=0;
	};
	rnd {name="": type=UNIFORM: mean=0.1: var=0: par=1: };
	wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0.1;
	cur_lrate=0.1;
	lrs_value=EPOCH;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	};
	wt_sig {gain=1: off=1: };
	lmix {hebb=0: err=1: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.1;
	};
       };
       LeabraBiasSpec @[1] {
	name="BgBias";
	desc=;
	unique{ rnd;wt_limits;wt_scale;wt_scale_init;lrate;	};
	children {
	 name=;
	 el_typ=LeabraBiasSpec;
	 el_def=0;
	 LeabraBiasSpec @[0] {
	  name="FixedBias";
	  desc=;
	  unique{ rnd;wt_limits;wt_scale;wt_scale_init;lrate;	  };
	  children {
	   name=;
	   el_typ=LeabraBiasSpec;
	   el_def=0;
	  };
	  rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	  wt_limits {type=NONE: min=-1: max=5: sym=0: };
	  learn_rule=LEABRA_CHL;
	  inhib=0;
	  wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	  wt_scale_init {init=0: abs=1: rel=1: };
	  lrate=0;
	  cur_lrate=0;
	  lrs_value=EPOCH;
	  lrate_sched {
	   name=;
	   el_typ=SchedItem;
	   el_def=0;
	   last_ctr=-1;
	   default_val=1;
	   interpolate=0;
	   cur_val=0;
	  };
	  wt_sig {gain=6: off=1.25: };
	  lmix {hebb=0.01: err=0.99: err_sb=1: };
	  xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	  savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
	  rel_net_adapt {
	   on=0;
	   trg_fm_input=0.85;
	   trg_fm_output=0.15;
	   trg_lateral=0;
	   trg_sum=1;
	   tol_lg=0.05;
	   tol_sm=0.2;
	   rel_lrate=0.1;
	  };
	  dwt_thresh=0.1;
	 };
	};
	rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
	wt_limits {type=NONE: min=-1: max=5: sym=0: };
	learn_rule=LEABRA_CHL;
	inhib=0;
	wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
	wt_scale_init {init=0: abs=1: rel=1: };
	lrate=0;
	cur_lrate=0;
	lrs_value=EPOCH;
	lrate_sched {
	 name=;
	 el_typ=SchedItem;
	 el_def=0;
	 last_ctr=-1;
	 default_val=1;
	 interpolate=0;
	 cur_val=0;
	};
	wt_sig {gain=6: off=1.25: };
	lmix {hebb=0.01: err=0.99: err_sb=1: };
	xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
	savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
	rel_net_adapt {
	 on=0;
	 trg_fm_input=0.85;
	 trg_fm_output=0.15;
	 trg_lateral=0;
	 trg_sum=1;
	 tol_lg=0.05;
	 tol_sm=0.2;
	 rel_lrate=0.1;
	};
	dwt_thresh=0.1;
       };
      };
      rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
      wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
      learn_rule=LEABRA_CHL;
      inhib=0;
      wt_scale {abs=1: rel=1: sem_extra=2: old=0: };
      wt_scale_init {init=0: abs=1: rel=1: };
      lrate=0.01;
      cur_lrate=0.01;
      lrs_value=EPOCH;
      lrate_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=0;
       cur_val=0;
      };
      wt_sig {gain=6: off=1.25: };
      lmix {hebb=0.01: err=0.99: err_sb=1: };
      xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
      savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
      rel_net_adapt {
       on=0;
       trg_fm_input=0.85;
       trg_fm_output=0.15;
       trg_lateral=0;
       trg_sum=1;
       tol_lg=0.05;
       tol_sm=0.2;
       rel_lrate=0.1;
      };
     };
     MarkerConSpec @[1] {
      name="MarkerCons";
      desc=;
      unique{ rnd;wt_limits;wt_scale;lrate;      };
      children {
       name=;
       el_typ=MarkerConSpec;
       el_def=0;
      };
      rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
      wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
      learn_rule=LEABRA_CHL;
      inhib=0;
      wt_scale {abs=1: rel=0: sem_extra=2: old=0: };
      wt_scale_init {init=0: abs=1: rel=1: };
      lrate=0;
      cur_lrate=0;
      lrs_value=EPOCH;
      lrate_sched {
       name=;
       el_typ=SchedItem;
       el_def=0;
       last_ctr=-1;
       default_val=1;
       interpolate=0;
       cur_val=0;
      };
      wt_sig {gain=6: off=1.25: };
      lmix {hebb=0.001: err=0.999: err_sb=1: };
      xcal {s_mix=0.9: m_mix=0.1: thr_l_mix=0.01: thr_m_mix=0.99: d_rev=0.1: d_gain=1: d_thr=0.0001: d_rev_ratio=9: };
      savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
      rel_net_adapt {
       on=0;
       trg_fm_input=0.85;
       trg_fm_output=0.15;
       trg_lateral=0;
       trg_sum=1;
       tol_lg=0.05;
       tol_sm=0.2;
       rel_lrate=0.1;
      };
     };
    };
    BaseSpec_Group @.gp[2] {
     name="TD_Layers";
     el_typ=ExtRewLayerSpec;
     el_def=0;
     ExtRewLayerSpec @[0] {
      name="ExtRewLayer";
      desc=;
      unique{ kwta;inhib_group;inhib;decay;ct_inhib_mod;      };
      children {
       name=;
       el_typ=ExtRewLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_AVG_INHIB;
       kwta_pt=0.9;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=0: phase2=0: clamp_phase2=1: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.1;
      };
      scalar {rep=GAUSSIAN: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=-0.5: max=1.5: range=2: scale=0.5: };
      bias_val {un=NO_UN: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0: };
      val_range {min=-0.35: max=1.35: range=1.7: scale=0.5882353: };
      rew_type=EXT_REW;
      avg_rew {sub_avg=0: avg_dt=0.005: };
      out_err {err_tol=0.5: graded=0: no_off_err=0: scalar_val_max=1: };
      rew {err_val=0: norew_val=0: rew_val=1: };
     };
     TDRewPredLayerSpec @[1] {
      name="TDRewPredLayer";
      desc=;
      unique{ kwta;inhib_group;inhib;decay;ct_inhib_mod;      };
      children {
       name=;
       el_typ=TDRewPredLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.1;
      };
      scalar {rep=GAUSSIAN: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=-0.5: max=3.5: range=4: scale=0.25: };
      bias_val {un=GC: un_shp=VAL: un_gain=2: wt=NO_WT: wt_gain=1: val=0: };
      val_range {min=-0.35: max=3.35: range=3.7: scale=0.2702703: };
     };
     TDRewIntegLayerSpec @[2] {
      name="TDRewIntegLayer";
      desc=;
      unique{ kwta;inhib_group;inhib;decay;ct_inhib_mod;      };
      children {
       name=;
       el_typ=TDRewIntegLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.1;
      };
      scalar {rep=GAUSSIAN: un_width=0.3: norm_width=0: clamp_pat=0: min_sum_act=0.2: clip_val=1: send_thr=0: init_nms=1: };
      unit_range {min=-0.5: max=3.5: range=4: scale=0.25: };
      bias_val {un=NO_UN: un_shp=VAL: un_gain=1: wt=NO_WT: wt_gain=1: val=0: };
      val_range {min=-0.35: max=3.35: range=3.7: scale=0.2702703: };
      rew_integ {discount=0.95: max_r_v=0: };
     };
     TdLayerSpec @[3] {
      name="TDLayer";
      desc=;
      unique{ decay;kwta;inhib_group;inhib;ct_inhib_mod;      };
      children {
       name=;
       el_typ=TdLayerSpec;
       el_def=0;
      };
      inhib_group=ENTIRE_LAYER;
      inhib {
       type=KWTA_INHIB;
       kwta_pt=0.25;
       min_i=0;
       fb_act_thr=0;
       ff_pct=0;
       fb_max_dt=0.1;
       comp_thr=0.5;
       comp_gain=2;
       gp_pt=0.2;
      };
      kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
      tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
      i_netin_mod {on=0: max_mod=0.02: mod_gain=10: max_top_k=0.4: };
      adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
      clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
      decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
      ct_inhib_mod {
       use_sin=0;
       burst_i=0.02;
       trough_i=0.02;
       use_fin=0;
       inhib_i=0;
      };
      abs_net_adapt {
       on=0;
       trg_net=0.5;
       tol=0.1;
       abs_lrate=0.1;
      };
     };
    };
    BaseSpec_Group @.gp[3] {
     name="TD_Prjns";
     el_typ=FullPrjnSpec;
     el_def=0;
     FullPrjnSpec @[0] {
      name="FullPrjn";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=FullPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
     };
     OneToOnePrjnSpec @[1] {
      name="OneToOne";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=1;
      init_wts=0;
      add_rnd_wts=0;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    max_size {x=17: y=5: z=2: };
    LeabraLayer @[0] {
     name="ExtRew";
     desc=;
     flags=;
     layer_type=TARGET;
     pos {x=0: y=0: z=0: };
     disp_scale=1;
     un_geom {x=12: y=1: n_not_xy=0: n=12: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=12: y=1: n_not_xy=0: n=12: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[1];
     };
     units {
      name=;
      el_typ=LeabraTdUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=12: y=1: n_not_xy=0: n=12: };
      units_lesioned=0;
      output_name=;
      LeabraTdUnit @[0] {
       name="val";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[2].projections[1]$$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[1] {
       name="-0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[2] {
       name="-0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[3] {
       name="-0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[4] {
       name="0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[5] {
       name="0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[6] {
       name="0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[7] {
       name="0.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=7: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[8] {
       name="0.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=8: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[9] {
       name="1.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=9: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[10] {
       name="1.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=10: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[11] {
       name="1.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=11: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
     };
     unit_spec {type=LeabraTdUnitSpec: spec=.projects[0].networks[0].specs.gp[0][0]$$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="-0.1";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.2109479: max=0.8908577: max_i=3: };
     acts_m {cmpt=1: avg=0.2109479: max=0.8908577: max_i=3: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=0.08333334: pct_c=0.9166667: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.08333334: i_kwta_pt=0.9: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=ExtRewLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][0]$: };
     hard_clamped=0;
     avg_l_avg=1.401298e-45;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[1] {
     name="TDRewPred";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=2: z=0: };
     disp_scale=1;
     un_geom {x=22: y=1: n_not_xy=0: n=22: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=22: y=1: n_not_xy=0: n=22: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_TD";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[3]$$;
       spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[3][1]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=MarkerConSpec: spec=.projects[0].networks[0].specs.gp[1][1]$$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=$.projects[0].networks[0].layers[4]$;
       spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[3][0]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=TDRewPredConSpec: spec=$.projects[0].networks[0].specs.gp[1][0].children[0]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=LeabraTdUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=22: y=1: n_not_xy=0: n=22: };
      units_lesioned=0;
      output_name=;
      LeabraTdUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="val";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[1].projections[0]$$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[1].projections[1]$$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[2].projections[0]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=61;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.1209081: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[2] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.74966: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[3] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.781715: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[4] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.781715: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[5] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=5: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.74966: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[6] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=6: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.1209081: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[7] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=7: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.008494854: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[8] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=8: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0.0002389845: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[9] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=9: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=2.948347e-06: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[10] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=10: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.379406e-08: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[11] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=11: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=2.72796e-11: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[12] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {12; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=12: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=2.295728e-14: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[13] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {13; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=13: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=7.451739e-18: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[14] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {14; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=14: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.058756e-21: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[15] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {15; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=15: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=5.912389e-26: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[16] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {16; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=16: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.384342e-30: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[17] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {17; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=17: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=1.304476e-35: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[18] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {18; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=18: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=5.189569e-41: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[19] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {19; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=19: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[20] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {20; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=20: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[21] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 60;
	 units = {0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; };
	 wt = {0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; 0.1; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {21; };
	wt = {0; };
       };
       n_recv_cons=60;
       pos {x=21: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
     };
     unit_spec {type=LeabraTdUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="0.7";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.1012272: max=0.856402: max_i=7: };
     acts_m {cmpt=1: avg=0.1095057: max=0.9090456: max_i=7: };
     phase_dif_ratio=1.081781;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=3: pct=0.1363636: pct_c=0.8636364: adth_k=1: k_ithr=2.403427: k1_ithr=2.349718: ithr_r=0.02260034: ithr_diff=0.02234685: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1363636: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=TDRewPredLayerSpec: spec=.projects[0].networks[0].specs.gp[2][1]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[2] {
     name="TDRewInteg";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=4: z=0: };
     disp_scale=1;
     un_geom {x=22: y=1: n_not_xy=0: n=22: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=22: y=1: n_not_xy=0: n=22: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_TDRewPred";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[1]$$;
       spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_ExtRew";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[0]$$;
       spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
     };
     units {
      name=;
      el_typ=LeabraTdUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=22: y=1: n_not_xy=0: n=22: };
      units_lesioned=0;
      output_name=;
      LeabraTdUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="val";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects[0].networks[0].layers[3].projections[0]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[1] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[2] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[3] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="-0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {3; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[4] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {4; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[5] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {5; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=5: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[6] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {6; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {6; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=6: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[7] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {7; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {7; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=7: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[8] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="0.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {8; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {8; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=8: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[9] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {9; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {9; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=9: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[10] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {10; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {10; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=10: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[11] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {11; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {11; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=2;
       pos {x=11: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[12] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {12; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {12; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=12: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[13] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="1.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {13; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {13; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=13: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[14] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {14; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {14; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=14: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[15] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {15; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {15; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=15: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[16] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {16; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {16; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=16: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[17] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {17; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {17; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=17: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[18] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="2.9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {18; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {18; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=18: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[19] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {19; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {19; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=19: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[20] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {20; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {20; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=20: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[21] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="3.5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {21; };
	 wt = {0; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[2].projections[1]$;
	 other_idx=0;
	};
	{ con_alloc = 0;
	 units = {};
	 wt = {};
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {21; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=21: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
     };
     unit_spec {type=LeabraTdUnitSpec: spec=$.projects[0].networks[0].specs.gp[0][0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="n/a";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_m {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=3: pct=0.1363636: pct_c=0.8636364: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.1363636: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=TDRewIntegLayerSpec: spec=$.projects[0].networks[0].specs.gp[2][2]$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[3] {
     name="TD";
     desc=;
     flags=;
     layer_type=HIDDEN;
     pos {x=16: y=0: z=0: };
     disp_scale=1;
     un_geom {x=1: y=1: n_not_xy=0: n=1: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=1: y=1: n_not_xy=0: n=1: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_TDRewInteg";
       from_type=CUSTOM;
       from=.projects[0].networks[0].layers[2]$$;
       spec {type=OneToOnePrjnSpec: spec=$.projects[0].networks[0].specs.gp[3][1]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=MarkerConSpec: spec=$.projects[0].networks[0].specs.gp[1][1]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
     };
     units {
      name=;
      el_typ=LeabraTdUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=1: y=1: n_not_xy=0: n=1: };
      units_lesioned=0;
      output_name=;
      LeabraTdUnit @[0] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name=;
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[3].projections[0]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[0]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=1;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
     };
     unit_spec {type=LeabraTdUnitSpec: spec=.projects[0].networks[0].specs.gp[0][1]$$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=-0.0006767511: max=-0.0006767511: max_i=0: };
     acts_m {cmpt=1: avg=0: max=0: max_i=0: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=1: pct=1: pct_c=0: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=1: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=TdLayerSpec: spec=.projects[0].networks[0].specs.gp[2][3]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=-0.0006767511;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
    LeabraLayer @[4] {
     name="Input";
     desc=;
     flags=;
     layer_type=INPUT;
     pos {x=0: y=1: z=1: };
     disp_scale=1;
     un_geom {x=20: y=3: n_not_xy=0: n=60: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=20: y=3: n_not_xy=0: n=60: };
     scaled_act_geom {x=1: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
     };
     units {
      name=;
      el_typ=LeabraTdUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=20: y=3: n_not_xy=0: n=60: };
      units_lesioned=0;
      output_name=;
      LeabraTdUnit @[0] {
       name="A_0";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[1] {
       name="A_1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[2] {
       name="A_2";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[3] {
       name="A_3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {3; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[4] {
       name="A_4";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {4; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[5] {
       name="A_5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {5; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[6] {
       name="A_6";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {6; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[7] {
       name="A_7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {7; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=7: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[8] {
       name="A_8";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {8; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=8: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[9] {
       name="A_9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {9; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=9: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[10] {
       name="A_10";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {10; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=10: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[11] {
       name="A_11";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {11; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=11: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[12] {
       name="A_12";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {12; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=12: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[13] {
       name="A_13";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {13; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=13: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[14] {
       name="A_14";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {14; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=14: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[15] {
       name="A_15";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {15; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=15: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[16] {
       name="A_16";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {16; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=16: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[17] {
       name="A_17";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {17; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=17: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[18] {
       name="A_18";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {18; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=18: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[19] {
       name="A_19";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {19; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=19: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[20] {
       name="B_0";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {20; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[21] {
       name="B_1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {21; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[22] {
       name="B_2";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {22; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[23] {
       name="B_3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {23; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[24] {
       name="B_4";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {24; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[25] {
       name="B_5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {25; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[26] {
       name="B_6";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {26; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[27] {
       name="B_7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {27; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=7: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[28] {
       name="B_8";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {28; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=8: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[29] {
       name="B_9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {29; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=9: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[30] {
       name="B_10";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {30; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=10: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[31] {
       name="B_11";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {31; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=11: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[32] {
       name="B_12";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {32; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=12: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[33] {
       name="B_13";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {33; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=13: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[34] {
       name="B_14";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {34; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=14: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[35] {
       name="B_15";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {35; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=15: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[36] {
       name="B_16";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {36; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=16: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[37] {
       name="B_17";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {37; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=17: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[38] {
       name="B_18";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {38; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=18: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[39] {
       name="B_19";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {39; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=19: y=1: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[40] {
       name="C_0";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {40; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[41] {
       name="C_1";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {41; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[42] {
       name="C_2";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {42; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[43] {
       name="C_3";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {43; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=3: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[44] {
       name="C_4";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {44; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=4: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[45] {
       name="C_5";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {45; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=5: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[46] {
       name="C_6";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {46; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=6: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[47] {
       name="C_7";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {47; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=7: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[48] {
       name="C_8";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {48; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=8: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[49] {
       name="C_9";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {49; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=9: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[50] {
       name="C_10";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {50; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=10: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[51] {
       name="C_11";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {51; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=11: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[52] {
       name="C_12";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {52; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=12: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[53] {
       name="C_13";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {53; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=13: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[54] {
       name="C_14";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {54; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=14: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[55] {
       name="C_15";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {55; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=15: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[56] {
       name="C_16";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {56; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=16: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[57] {
       name="C_17";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {57; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=17: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[58] {
       name="C_18";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {58; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=18: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
      LeabraTdUnit @[59] {
       name="C_19";
       ext_flag=;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects[0].networks[0].layers[1].projections[1]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {59; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=19: y=2: z=0: };
       act_eq=0;
       act_nd=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_p2=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_ml=0.15;
       avg_l=0.15;
       l_thr=0.45;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       maint_h=0;
       spk_amp=2;
       p_act_m=-0.01;
       p_act_p=-0.01;
       trace=0;
      };
     };
     unit_spec {type=LeabraTdUnitSpec: spec=$.projects[0].networks[0].specs[0]$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name="B_9";
     sse=0;
     icon_value=0;
     netin {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     netin_top_k {cmpt=1: avg=0: max=0: max_i=-1: };
     i_thrs {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts {cmpt=1: avg=0: max=-3.402823e+38: max_i=-1: };
     acts_p {cmpt=1: avg=0.01583333: max=0.95: max_i=29: };
     acts_m {cmpt=1: avg=0.01583333: max=0.95: max_i=29: };
     phase_dif_ratio=1;
     acts_p2 {cmpt=1: avg=0: max=0: max_i=-1: };
     acts_m2 {cmpt=1: avg=0: max=0: max_i=-1: };
     kwta {k=12: pct=0.2: pct_c=0.8: adth_k=1: k_ithr=-0.1: k1_ithr=-0.1: ithr_r=0: ithr_diff=0: tie_brk_gain=0: eff_loser_gain=1: tie_brk=0: };
     i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: i_netin_mod=0: };
     un_g_i {cmpt=0: avg=0: max=-3.402823e+38: max_i=-1: };
     adapt_i {avg_avg=0.2: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     maxda=0;
     act_max_avg=0;
     spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs[1].children[0]$$: };
     hard_clamped=0;
     avg_l_avg=0;
     dav=0;
     avg_netin {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_sum {cmpt=1: avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     norm_err=0;
     da_updt=0;
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=0;
   group=0;
   trial=0;
   tick=0;
   cycle=0;
   time=0;
   group_name=;
   trial_name=;
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   pct_err=0;
   pct_cor=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="TimeUsed_0": start={usr=85015: sys=40281: tot=1718939356: }: end={usr=84118: sys=39925: tot=1718924536: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   epoch_time {name="TimeUsed_1": start={usr=98384: sys=45980: tot=1718963069: }: end={usr=98384: sys=45980: tot=1718963068: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   trial_time {name="TimeUsed_2": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   settle_time {name="TimeUsed_3": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   cycle_time {name="TimeUsed_4": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   wt_sync_time {name="TimeUsed_5": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   misc_time {name="TimeUsed_6": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=0;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=117;
   n_cons=1356;
   max_size {x=17: y=5: z=2: };
   learn_rule=LEABRA_CHL;
   phase_order=MINUS_PLUS;
   no_plus_test=0;
   sequence_init=DO_NOTHING;
   phase=MINUS_PHASE;
   nothing_phase=0;
   phase_no=0;
   phase_max=2;
   ct_cycle=10;
   time_inc=1;
   cycle_max=60;
   mid_minus_cycle=-1;
   min_cycles=5;
   min_cycles_phase2=35;
   ct_time {
    minus=50;
    plus=20;
    inhib=20;
    n_avg_only_epcs=1;
    total_cycles=90;
    inhib_start=70;
   };
   ct_sravg {
    start=30;
    end=20;
    interval=2;
    plus_s_st=19;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.05;
    trough_i=0.05;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   sravg_vals {
    s_sum=0;
    s_nrm=0;
    m_sum=0;
    m_nrm=0;
    do_s=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
    lrn_min=0;
    lrn_min_cyc=0;
    lrn_min_thr=0;
    lrn_min_sum=0;
    lrn_min_cyc_sum=0;
    lrn_min_thr_sum=0;
    lrn_plus=0;
    lrn_plus_cyc=0;
    lrn_plus_thr=0;
    lrn_plus_sum=0;
    lrn_plus_cyc_sum=0;
    lrn_plus_thr_sum=0;
    lrn_noth=0;
    lrn_noth_cyc=0;
    lrn_noth_thr=0;
    lrn_noth_sum=0;
    lrn_noth_cyc_sum=0;
    lrn_noth_thr_sum=0;
    lrn_stats_n=0;
   };
   minus_cycles=0;
   avg_cycles=0;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   minus_output_name=;
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   send_pct=0;
   send_pct_n=0;
   send_pct_tot=0;
   avg_send_pct=0;
   avg_send_pct_sum=0;
   avg_send_pct_n=0;
   maxda_stopcrit=0.005;
   maxda=0;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   ext_rew_avail=0;
   norew_val=0.5;
   avg_ext_rew=0;
   pvlv_pvi=0;
   pvlv_pvr=0;
   pvlv_lve=0;
   pvlv_lvi=0;
   pv_detected=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
   off_errs=1;
   on_errs=1;
   norm_err=0;
   avg_norm_err=1;
   avg_norm_err_sum=0;
   avg_norm_err_n=0;
  };
 };
};
